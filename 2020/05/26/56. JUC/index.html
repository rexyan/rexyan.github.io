<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rexyan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"top","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JUCJUC 全称是 java.util.concurrent，作用是在并发编程中使用的工具类 进程的状态NEW,(新建)RUNNABLE,（准备就绪）BLOCKED,（阻塞）WAITING,（不见不散）TIMED_WAITING,（过时不候）TERMINATED, (终结) wait/sleep 的区别功能都是当前线程暂停，区别在于 wait 是放开手去睡，放开手里的锁。sleep 是握紧手去睡">
<meta name="keywords" content="JUC">
<meta property="og:type" content="article">
<meta property="og:title" content="56. JUC">
<meta property="og:url" content="https://rexyan.github.io/2020/05/26/56. JUC/index.html">
<meta property="og:site_name" content="星尘">
<meta property="og:description" content="JUCJUC 全称是 java.util.concurrent，作用是在并发编程中使用的工具类 进程的状态NEW,(新建)RUNNABLE,（准备就绪）BLOCKED,（阻塞）WAITING,（不见不散）TIMED_WAITING,（过时不候）TERMINATED, (终结) wait/sleep 的区别功能都是当前线程暂停，区别在于 wait 是放开手去睡，放开手里的锁。sleep 是握紧手去睡">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjHiT3yPbxb*9hcy6orKXiX0OXtJGJ2r2OcrP2fRhBTbbOVt*yQYd7Q69K2nIOvAIyw!!/mnull&bo=NwPlADcD5QADCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjOWaOnzQD7xDhfsQ*UnjRuQFqEFNtwr1JZIQghm4DPgYqP.6szsQPbQ23ZQPVNGmZg!!/mnull&bo=0QLBAdECwQEDCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjLxN4I9f9lFyupobAlcmU5hf3zTIdXLlguh3e2VFv.c8paDS.tdIDlEbMR3DybZyDA!!/mnull&bo=*QIZAf0CGQEDCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjHx32*0XLNdML*8DmpJfnfx96zA7oIxOH2uqZAE5*suXhddVu.TETsOpLVb8MUaWFg!!/mnull&bo=JgWMASYFjAEDCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjIUYvWPF*x1WGlvR7qIaBsbc*9eMBmUVGy9oIF1iIVTF4Nt2ntaWYH2W.zBzaT53hQ!!/mnull&bo=vwPYAL8D2AADCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjKjp07OeHooKhlCKTKnhRwbSeOfyJrpYXZjmN1CrhxlAPp*Wf3rsnzKbHazPhueLNw!!/mnull&bo=XwPuAF8D7gADCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjEWgilRtE1YyOa6hApyiQ9FldyULhEjhRa9HgqWQULCa1CxSAfRxJ86PWKPo.Jm30g!!/mnull&bo=JAPmASQD5gEDCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjMaZgjxXbCcefPZ6ZQSu*.Q2J6e0IQGVrV3HuDs8*xhqPVCevqJSXu1o*ZWvf3Amaw!!/mnull&bo=ugU.BboFPgUDCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjIjwi6wUzUmIuwA*qOWKQQzE6aH6wofLJZGkGRq1xKBKuK3S8XWe7CofJLKhFVD7EQ!!/mnull&bo=2ANbAdgDWwEDCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">
<meta property="og:updated_time" content="2025-10-31T03:20:39.388Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="56. JUC">
<meta name="twitter:description" content="JUCJUC 全称是 java.util.concurrent，作用是在并发编程中使用的工具类 进程的状态NEW,(新建)RUNNABLE,（准备就绪）BLOCKED,（阻塞）WAITING,（不见不散）TIMED_WAITING,（过时不候）TERMINATED, (终结) wait/sleep 的区别功能都是当前线程暂停，区别在于 wait 是放开手去睡，放开手里的锁。sleep 是握紧手去睡">
<meta name="twitter:image" content="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjHiT3yPbxb*9hcy6orKXiX0OXtJGJ2r2OcrP2fRhBTbbOVt*yQYd7Q69K2nIOvAIyw!!/mnull&bo=NwPlADcD5QADCSw!&rf=photolist&t=5/r/_yake_qzoneimgout.png">

<link rel="canonical" href="https://rexyan.github.io/2020/05/26/56. JUC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>56. JUC | 星尘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css" />
  <!-- 自定义为霞鹜文楷字体 -->
  <style>
	  body,div.post-body,h1,h2,h3,h4 {
		font-family: "LXGW WenKai Screen", sans-serif;
		font-size: 104%;
	  }
  </style>
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">星尘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-读书">

    <a href="/books/" rel="section"><i class="address-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-瞎扯">

    <a href="/crap/" rel="section"><i class="crap fa-fw"></i>瞎扯</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



<script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script>

<meta name="referrer" content="never">




  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rexyan.github.io/2020/05/26/56. JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
      <meta itemprop="name" content="Rex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星尘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          56. JUC
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-26 22:40:57" itemprop="dateCreated datePublished" datetime="2020-05-26T22:40:57+00:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-31 03:20:39" itemprop="dateModified" datetime="2025-10-31T03:20:39+00:00">2025-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-大数据/" itemprop="url" rel="index"><span itemprop="name">Java 大数据</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><p>JUC 全称是 java.util.concurrent，作用是在并发编程中使用的工具类</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>NEW,(新建)<br>RUNNABLE,（准备就绪）<br>BLOCKED,（阻塞）<br>WAITING,（不见不散）<br>TIMED_WAITING,（过时不候）<br>TERMINATED, (终结)</p>
<h3 id="wait-sleep-的区别"><a href="#wait-sleep-的区别" class="headerlink" title="wait/sleep 的区别"></a>wait/sleep 的区别</h3><p>功能都是当前线程暂停，区别在于 wait 是放开手去睡，放开手里的锁。sleep 是握紧手去睡，醒了手里还有锁。</p>
<h3 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发/并行"></a>并发/并行</h3><p>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点。例子，小米9今天上午10点，限量抢购，春运抢票，电商秒杀…<br>并行：多项工作一起执行，之后再汇总。例子，泡方便面，电水壶烧水，一边撕调料倒入桶中</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Lock 和 Synchronized 的区别：Lock 实现提供了比使用 Synchronized 方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。而且 Lock 是手动上锁和解锁，Synchronized 则控制不了。</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>可重入锁，Lock 接口的实现，<a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/SaleTicket.java" target="_blank" rel="noopener">代码地址</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 买票操作</span></span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"卖出："</span> + number-- + <span class="string">"号票，还剩："</span> + number + <span class="string">"张"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">// 售票员 AA, lambda 表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();&#125;, <span class="string">"AA"</span>).start();</span><br><span class="line">        <span class="comment">// 售票员 BB, lambda 表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();&#125;, <span class="string">"BB"</span>).start();</span><br><span class="line">        <span class="comment">// 售票员 CC, lambda 表达式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();&#125;, <span class="string">"CC"</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                for (int i = 0; i &lt; 40; i++) &#123;</span></span><br><span class="line"><span class="comment">//                    ticket.sale();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, "AA").start();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // 售票员 BB</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                for (int i = 0; i &lt; 40; i++) &#123;</span></span><br><span class="line"><span class="comment">//                    ticket.sale();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, "BB").start();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // 售票员 CC</span></span><br><span class="line"><span class="comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                for (int i = 0; i &lt; 40; i++) &#123;</span></span><br><span class="line"><span class="comment">//                    ticket.sale();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, "CC").start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java8特性"><a href="#java8特性" class="headerlink" title="java8特性"></a>java8特性</h3><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>在 java.util.function 包下面的都是函数式接口。函数式接口都有 @FunctionalInterface 注解。</p>
<h4 id="内置四大函数式接口"><a href="#内置四大函数式接口" class="headerlink" title="内置四大函数式接口"></a>内置四大函数式接口</h4><p><code>Consumer&lt;T&gt;</code> : 消费型接口，有参无返回值。范型 T 是参数类型<br><code>Supplier&lt;T&gt;</code> : 供给型接口，无参有返回值。范型 T 是返回值类型<br><code>Function&lt;T, R&gt;</code> : 函数型接口，有参有返回值。范型 T 是参数类型，R 是返回值类型<br><code>Predicate&lt;T&gt;</code> : 断定型接口，有参，返回值为 bool。范型 T 是参数类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  void accept(T t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = t-&gt; &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">"ABC"</span>);  <span class="comment">// ABC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// T get();</span></span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DEF"</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier.get());  <span class="comment">// DEF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  R apply(T t);</span></span><br><span class="line">        Function&lt;String, Integer&gt; function = (t) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> t.length();</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"zhangsan"</span>));  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean test(T t);</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = (t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> t.length() &gt; <span class="number">10</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"zhangsan"</span>));  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h4><p>Stream 流是数据渠道，用于操作数据源（集合，数组等）。“集合注重的是数据，流注重的是计算“。</p>
<p>特点：</p>
<ol>
<li>Stream 自己不会存储元素</li>
<li>Stream 不会改变源对象，相反，会返回一个新的持有结果的 Stream 流</li>
<li>Stream 的操作是延迟的，这意味着他们会等到需要结果的时候才执行</li>
</ol>
<p>例子：</p>
<p>按照给出的数据，找出偶数ID，年龄大于 24，用户名转为大写，用户名字幕倒序，只输出一个用于名字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请按照给出数据，找出</span></span><br><span class="line"><span class="comment"> * 偶数ID</span></span><br><span class="line"><span class="comment"> * 年龄大于24</span></span><br><span class="line"><span class="comment"> * 用户名转为大写</span></span><br><span class="line"><span class="comment"> * 用户名字母倒排序</span></span><br><span class="line"><span class="comment"> * 只输出一个</span></span><br><span class="line"><span class="comment"> * 用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">11</span>, <span class="string">"a"</span>, <span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">12</span>, <span class="string">"b"</span>, <span class="number">24</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">13</span>, <span class="string">"c"</span>, <span class="number">22</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">14</span>, <span class="string">"d"</span>, <span class="number">28</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">16</span>, <span class="string">"e"</span>, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line">        list.stream().filter((t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> t.getId() % <span class="number">2</span> == <span class="number">0</span>;  <span class="comment">// 筛选出 偶数ID</span></span><br><span class="line">        &#125;).filter((t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> t.getAge() &gt; <span class="number">24</span>;  <span class="comment">// 筛选出 年龄大于24</span></span><br><span class="line">        &#125;).map((t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> t.getUserName().toUpperCase();  <span class="comment">// 用户名转为大写</span></span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);  <span class="comment">// 用户名字母倒排序</span></span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);  <span class="comment">// E</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java 的语言表达能力得到了提升。</p>
<p>Lambda 表达式在 Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或剪头操作符。它将 Lambda 分为两个部分，左侧：指定了 Lambda 表达式需要的所有参数，右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p>
<p>使用 Lambda 表达式的条件是 lambda 表达式，必须是函数式接口，即必须只有一个方法，如果接口只有一个方法 java 默认它为函数式接口。为了正确使用Lambda表达式，需要给接口加个注解：@FunctionalInterface，如有两个方法，立刻报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FunctionalInterface</span> <span class="comment">// 函数式接口（只能有一个实现的方法）</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现方式1: 内部类实现</span></span><br><span class="line">        Foo foo = <span class="keyword">new</span> Foo() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(foo.add(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现方式2: lambda 表达式实现（使用 lambda 的条件是必须是函数式接口，即只有一个实现的方法）</span></span><br><span class="line">        Foo foo1 = (<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(foo1.add(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口里是否能有实现方法"><a href="#接口里是否能有实现方法" class="headerlink" title="接口里是否能有实现方法"></a>接口里是否能有实现方法</h4><p><a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/LambdaDemo.java" target="_blank" rel="noopener">代码地址</a></p>
<p>在 Java 8 中接口新增了 default 方法和静态方法。即，一个接口中可以有多个 default 方法，也可以有多个静态当法。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FunctionalInterface</span> <span class="comment">// 函数式接口（只能有一个实现的方法）</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// default 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x - y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x / y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aa</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y + <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bb</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x - y - <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现方式1: 内部类实现</span></span><br><span class="line">        Foo foo = <span class="keyword">new</span> Foo() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(foo.add(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现方式2: lambda 表达式实现（使用 lambda 的条件是必须是函数式接口，即只有一个实现的方法）</span></span><br><span class="line">        Foo foo1 = (<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(foo1.add(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(foo1.div(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(foo1.sub(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>需求： 四个线程 ABCD。两个线程进行 + 1。另外个线程进行 -1。要求 +1 和 -1 交替进行。每个线程执行 10 次</p>
<h4 id="synchronized-实现"><a href="#synchronized-实现" class="headerlink" title="synchronized 实现"></a>synchronized 实现</h4><p><a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/SyncNotifyWait.java" target="_blank" rel="noopener">代码地址</a></p>
<p>注意⚠️：在使用 object 中的 wait 方法的时候，一定要为 wait 使用 while 循环。if 判断只会判断一次，如果使用 if 当线程再次被唤醒的时候，因为执行过判断了，就有可能绕过条件（以前判断过了，认为没问题，但是其实已经不满足条件了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四个线程 ABCD。两个线程进行 + 1。另外个线程进行 -1</span></span><br><span class="line"><span class="comment"> * 要求 +1 和 -1 交替进行。每个线程执行 10 次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyWaitDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1判断</span></span><br><span class="line">        <span class="comment">// 这里使用 while 判断而不使用 if 的原因是因为 if 只判断一次</span></span><br><span class="line">        <span class="comment">// 如果使用 if 判断，线程被唤醒的时候不在进行判断，那么就有可能会绕过条件</span></span><br><span class="line">        <span class="comment">// 使用 while 的目的就是让线程每次被唤醒的时候，每次都进行判断</span></span><br><span class="line">        <span class="keyword">while</span> (number !=<span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//2干活</span></span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+number);</span><br><span class="line">         <span class="comment">//3通知</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         <span class="comment">// 1判断</span></span><br><span class="line">         <span class="comment">// 这里使用 while 判断而不使用 if 的原因是因为 if 只判断一次</span></span><br><span class="line">         <span class="comment">// 如果使用 if 判断，线程被唤醒的时候不在进行判断，那么就有可能会绕过条件</span></span><br><span class="line">         <span class="comment">// 使用 while 的目的就是让线程每次被唤醒的时候，每次都进行判断</span></span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 2干活</span></span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">         <span class="comment">// 3通知</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NotifyWaitDemo notifyWaitDemo = <span class="keyword">new</span> NotifyWaitDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        notifyWaitDemo.increment();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        notifyWaitDemo.decrement();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        notifyWaitDemo.increment();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        notifyWaitDemo.decrement();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程B	0</span><br><span class="line">线程A	1</span><br><span class="line">线程B	0</span><br><span class="line">线程A	1</span><br><span class="line">线程B	0</span><br><span class="line">......</span><br><span class="line">线程D	0</span><br></pre></td></tr></table></figure>
<p>上述代码中，如果不使用 while ，那么就会出现值大于1或者小于 0 的情况。</p>
<h4 id="lock-实现"><a href="#lock-实现" class="headerlink" title="lock 实现"></a>lock 实现</h4><p><a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/LockSingalAwait.java" target="_blank" rel="noopener">代码地址</a></p>
<p>与 synchronized 相比，lock 中实现释放当前线程资源的方法是 Condition 中的 await 方法。唤醒其他线程的方法是 Condition 中的 signal 方法。</p>
<p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjHiT3yPbxb*9hcy6orKXiX0OXtJGJ2r2OcrP2fRhBTbbOVt*yQYd7Q69K2nIOvAIyw!!/mnull&amp;bo=NwPlADcD5QADCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 四个线程 ABCD。两个线程进行 + 1。另外个线程进行 -1</span></span><br><span class="line"><span class="comment"> * 要求 +1 和 -1 交替进行。每个线程执行 10 次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSingalAwait</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number !=<span class="number">0</span> ) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+number);</span><br><span class="line">            <span class="comment">//3通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (number !=<span class="number">1</span> ) &#123;</span><br><span class="line">                 condition.await();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//2干活</span></span><br><span class="line">             number--;</span><br><span class="line">             System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+number);</span><br><span class="line">             <span class="comment">//3通知</span></span><br><span class="line">             condition.signalAll();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockSingalAwait syncNotifyWait = <span class="keyword">new</span> LockSingalAwait();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        syncNotifyWait.increment();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        syncNotifyWait.decrement();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        syncNotifyWait.increment();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程C"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        syncNotifyWait.decrement();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程间定制化通信"><a href="#线程间定制化通信" class="headerlink" title="线程间定制化通信"></a>线程间定制化通信</h3><p><a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/LockSingalAwait2.java" target="_blank" rel="noopener">代码地址</a></p>
<p>需求：三个线程 AA，BB，CC，现要求，AA BB CC 按顺序执行，且 AA 打印5次，BB 打印 10次，CC 打印 15 次，然后循环10次。</p>
<p>在 lock 中我们可以唤醒指定的线程，只需要使用 signal 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：三个线程 AA，BB，CC，现要求，AA BB CC 按顺序执行</span></span><br><span class="line"><span class="comment"> * 且 AA 打印5次，BB 打印 10次，CC 打印 15 次，然后循环10次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSingalAwait2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程标志，1 表示该 AA 执行，2 BB 执行，3 CC 执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition(); <span class="comment">// AA 线程的 Condition</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition(); <span class="comment">// BB 线程的 Condition</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition(); <span class="comment">// CC 线程的 Condition</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 (不等于1的时候，需要等待)</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程 :"</span> + Thread.currentThread().getName() + <span class="string">" 打印："</span> + i + <span class="string">"次，当前第："</span> + loopCount + <span class="string">"轮"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知 (修改标识位，并唤醒线程 BB)</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不管怎么样都要释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">(<span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 (不等于2的时候，需要等待)</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程 :"</span> + Thread.currentThread().getName() + <span class="string">" 打印："</span> + i + <span class="string">"次，当前第："</span> + loopCount + <span class="string">"轮"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知 (修改标识位，并唤醒线程 CC)</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不管怎么样都要释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">(<span class="keyword">int</span> loopCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断 (不等于2的时候，需要等待)</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程 :"</span> + Thread.currentThread().getName() + <span class="string">" 打印："</span> + i + <span class="string">"次，当前第："</span> + loopCount + <span class="string">"轮"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通知 (修改标识位，并唤醒线程 AA【此处又回到 AA】)</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不管怎么样都要释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockSingalAwait2 lockSingalAwait2 = <span class="keyword">new</span> LockSingalAwait2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lockSingalAwait2.print5(i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"AA"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lockSingalAwait2.print10(i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"BB"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lockSingalAwait2.print15(i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"CC"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中 AA 执行完成之后唤醒 BB 执行，BB 执行之后唤醒 CC，最后 CC 又唤醒 AA，直到最后循环 10 次。</p>
<h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p><strong>Vector、HashTable、Properties 是线程安全的；</strong></p>
<p><strong>ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap 等都是线程不安全的。</strong></p>
<h4 id="List-线程安全"><a href="#List-线程安全" class="headerlink" title="List 线程安全"></a>List 线程安全</h4><p>ArrayList 是线程不安全的，我们可以使用 CopyOnWriteArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 会出现并发修改异常 java.util.ConcurrentModificationException</span></span><br><span class="line">                    list.add(UUID.randomUUID().toString());</span><br><span class="line">                    System.out.println(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><br><span class="line">	at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><br><span class="line">	at java.util.AbstractCollection.toString(AbstractCollection.java:461)</span><br><span class="line">	at java.lang.String.valueOf(String.java:2994)</span><br><span class="line">	at java.io.PrintStream.println(PrintStream.java:821)</span><br><span class="line">	at com.atguigu.juc.ArrayListDemo$1.run(ArrayListDemo.java:16)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>
<p>解决方法有三种，最好的是第三种，前两种都不推荐使用。<a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/ArrayListDemo.java" target="_blank" rel="noopener">代码地址</a></p>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>解决方法1：Vector。Vector 也是 List 的实现类，但是查看 Vector 的源码发现，Vector 的 add 方法上有 synchronized，所以 Vector 是线程安全的。但是实际使用过程中，并不推荐使用 Vector 因为很老了，而且速度很慢。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noSafeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// List&lt;String&gt; list = new ArrayList&lt;&gt;();  // 线程不安全</span></span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();  <span class="comment">// 线程安全，但是效率低下</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><p>解决方法2: Collections。 Collections 工具类提供了一些 synchronized方法，例如 synchronizedList，synchronizedMap, synchronizedSet 之类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noSafeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// List&lt;String&gt; list = new ArrayList&lt;&gt;();  // 线程不安全</span></span><br><span class="line">  <span class="comment">// List&lt;String&gt; list = new Vector&lt;&gt;();  // 线程安全，但是效率低下</span></span><br><span class="line">  List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());  <span class="comment">// 线程安全</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><p>解决方法3: CopyOnWriteArrayList。CopyOnWriteArrayList 是 java.util.concurrent 包下的。底层原理是写时复制。对应的还有解决 set 线程不方法的方法 CopyOnWriteArraySet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noSafeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// List&lt;String&gt; list = new ArrayList&lt;&gt;();  // 线程不安全</span></span><br><span class="line">  <span class="comment">// List&lt;String&gt; list = new Vector&lt;&gt;();  // 线程安全，但是效率低下</span></span><br><span class="line">  <span class="comment">// List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());  // 线程安全</span></span><br><span class="line">  CopyOnWriteArrayList list = <span class="keyword">new</span> CopyOnWriteArrayList();  <span class="comment">//  线程安全，推荐使用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CopyOnWriteArrayList 是 arraylist 的一种线程安全变体，其中所有可变操作（add、set等）都是通过生成底层数组的新副本来实现的。</p>
<p>CopyOnWrite 容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器 Object[] 添加，而是先将当前容器 Object[] 进行Copy，复制出一个新的容器 Object[] newElements，然后向新的容器Object[] newElements 里添加元素。添加元素后，再将原容器的引用指向新的容器。这样做的好处是可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。如下图：</p>
<p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjOWaOnzQD7xDhfsQ*UnjRuQFqEFNtwr1JZIQghm4DPgYqP.6szsQPbQ23ZQPVNGmZg!!/mnull&amp;bo=0QLBAdECwQEDCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<p><a href="https://www.cnblogs.com/heqiyoujing/p/11144803.html" target="_blank" rel="noopener">其他资料，CopyOnWrite 优缺点 </a></p>
<h4 id="Set-线程安全"><a href="#Set-线程安全" class="headerlink" title="Set 线程安全"></a>Set 线程安全</h4><p>HashSet 是线程不安全的，我们可以使用 CopyOnWriteArraySet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noSafeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Set set = new HashSet();  // 线程不安全</span></span><br><span class="line">  CopyOnWriteArraySet set = <span class="keyword">new</span> CopyOnWriteArraySet(); <span class="comment">//  线程安全，推荐使用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        set.add(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(set);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet 的底层是 HashMap 实现的，在 HashSet 中 add 新增的值，作为了 HashMap 的 key，value 是一个 PRESENT 常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet add 方法实现原理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet 底层使用的是 HashMap，key 为 HashSet 元素的值，value 为 PRESENT</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<h4 id="Map-线程安全"><a href="#Map-线程安全" class="headerlink" title="Map 线程安全"></a>Map 线程安全</h4><p>HashMap 也是线程不安全的，我们可以使用 ConcurrentHashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noSafeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //  线程不安全</span></span><br><span class="line">  ConcurrentHashMap&lt;String, Object&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.put(UUID.randomUUID().toString(), Thread.currentThread().getName());</span><br><span class="line">        System.out.println(map);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p><a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/CallableDemo.java" target="_blank" rel="noopener">代码地址</a></p>
<p>获得多线程的方式主要有四种，之前的继承 Thread 类和实现 Runable 接口。还有现在的实现 Callable 接口和 java 线程池。</p>
<p>Callable 接口和 Runable 的三点不同：</p>
<ol>
<li>Callable 实现的方法有返回值</li>
<li>Callable 实现的方法有异常</li>
<li>Callable 实现的方法是 call，Runable 实现的方法是 run</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseCallable</span> <span class="keyword">implements</span>  <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>new Thread()</code>的时候，可以传入一个  Runable 对象，Callable 是否也可以直接传入呢？答案是不可以的，但是可以借助一个中间人 FutureTask，FutureTask 实现了Runable接口，同时也接受 Callable 类型的实现。这样就能连接起来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseCallable</span> <span class="keyword">implements</span>  <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// new Thread(new UseRunable(), "Runable 方式实现的线程").start();</span></span><br><span class="line"></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> UseCallable());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"CallableD 方式实现的线程 - A"</span>).start();</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// "CallableD 方式实现的线程 - B" 不会被执行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"CallableD 方式实现的线程 - B"</span>).start();  </span><br><span class="line">        <span class="keyword">while</span> (!futureTask.isDone())&#123;</span><br><span class="line">            System.out.println(<span class="string">"运算未完成!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(futureTask.get());  <span class="comment">// 取值放在最后，不然 main 主进程会被阻塞。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 FutureTask 对象在后台完成，当主线程将来需要时，就可以通过 FutureTask 对象获得后台作业的计算结果或者执行状态。仅在 FutureTask 计算完成时才能检索结果；如果计算尚未完成，就调用 get 方法获取结果，那么主进程就会被阻塞。而且一旦 FutureTask 计算完成，就不能再重新开始或取消计算。所以 FutureTask 有两点需要注意：</p>
<ol>
<li>一个 FutureTask 对象只计算一次。</li>
<li>get 方法需要放到最后，即主线程可以在完成自己的任务后，再去获取结果。（否则未计算完获取结果会被阻塞）</li>
</ol>
<h3 id="JUC-强大辅助类"><a href="#JUC-强大辅助类" class="headerlink" title="JUC 强大辅助类"></a>JUC 强大辅助类</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p><a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/CountDownLatchDemo.java" target="_blank" rel="noopener">代码地址</a></p>
<p>CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这些线程会阻塞。</p>
<p>其它线程调用 countDown 方法会将计数器减1(调用 countDown 方法的线程不会阻塞)，当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行！！"</span>);</span><br><span class="line">                    <span class="comment">// 让 CountDownLatch 的计数进行减 1 操作</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"线程"</span> + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"循环创建的线程全部执行完毕，我最后执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarrier 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过 CyclicBarrier 的 await() 方法。</p>
<p>举例：只有集齐七颗龙珠，才能召唤出神龙。<a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/CyclicBarrierDemo.java" target="_blank" rel="noopener">源码地址</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CyclicBarrier 第一个参数是需要到达的次数，第二个是达到次数后调用的 Runnable 方法</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"集齐七颗龙珠, 可以召唤神龙！！！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动多个线程(如果将这里的循环次数改为6，那么是达不到 CyclicBarrier Runnable 方法执行的条件的)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"被收集"</span>);</span><br><span class="line">                        <span class="comment">// 如果未达到 CyclicBarrier 设置的计数，那么会被阻塞</span></span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"龙珠"</span> + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">龙珠2被收集</span><br><span class="line">龙珠4被收集</span><br><span class="line">龙珠3被收集</span><br><span class="line">龙珠1被收集</span><br><span class="line">龙珠6被收集</span><br><span class="line">龙珠5被收集</span><br><span class="line">龙珠7被收集</span><br><span class="line">集齐七颗龙珠, 可以召唤神龙！！！</span><br></pre></td></tr></table></figure>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</p>
<p>在信号量上我们定义两种操作：</p>
<ol>
<li>acquire（获取） 当一个线程调用 acquire 操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li>
<li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li>
</ol>
<p>举例：停车场只有三个停车位，但是有六辆车需要停。停车场每辆车停留的时间有限，当停车场有空时，发出信号，外面的车辆可以进入停车场。<a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/SemaphoreDemo.java" target="_blank" rel="noopener">源码地址</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 三个停车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个线程一辆车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取信号量</span></span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" 进入停车场"</span>);</span><br><span class="line">                        <span class="comment">// 模拟车在里面停留</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 释放信号量</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" 开出停车场"</span>);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"车辆"</span> + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>Java 并发库中 ReetrantReadWriteLock 实现了 ReadWriteLock 接口并添加了可重入的特性。ReetrantReadWriteLock 读写锁的效率明显高于 synchronized 关键字。ReetrantReadWriteLock 读写锁的实现中，读锁使用共享模式；写锁使用独占模式，换句话说，读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。ReetrantReadWriteLock 读写锁的实现中，需要注意的，当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁。</p>
<p>以下代码实例就是没有加读写锁的情况，写操作 set 是一起进行的，并没有独占。<a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/ReadWriteLockDemo.java" target="_blank" rel="noopener">代码地址</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="comment">// volatile 表示这个对象是经常变化的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"正在写"</span>+ key);</span><br><span class="line">            <span class="comment">// 暂停一会儿线程</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"写入"</span>+ key+<span class="string">"完成"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"正在获取"</span>+ key + <span class="string">"的值"</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"正在获取"</span>+ key + <span class="string">"的值结束"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 五个线程进行写操作，五个线程进行读操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    myCache.set(String.valueOf(num), UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(num)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    myCache.get(String.valueOf(num));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(num)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">线程：1正在写1</span><br><span class="line">线程：4正在写4</span><br><span class="line">线程：3正在写3</span><br><span class="line">线程：2正在写2</span><br><span class="line">线程：0正在写0</span><br><span class="line">线程：5正在获取5的值</span><br><span class="line">线程：5正在获取5的值结束</span><br><span class="line">线程：6正在获取6的值</span><br><span class="line">线程：6正在获取6的值结束</span><br><span class="line">线程：7正在获取7的值</span><br><span class="line">线程：7正在获取7的值结束</span><br><span class="line">线程：8正在获取8的值</span><br><span class="line">线程：8正在获取8的值结束</span><br><span class="line">线程：9正在获取9的值</span><br><span class="line">线程：9正在获取9的值结束</span><br><span class="line">线程：4写入4完成</span><br><span class="line">线程：2写入2完成</span><br><span class="line">线程：1写入1完成</span><br><span class="line">线程：3写入3完成</span><br><span class="line">线程：0写入0完成</span><br></pre></td></tr></table></figure>
<p>以下代码是加上读写锁之后的，可以看见写操作是独占的，读操作的并发的。<a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/ReadWriteLockDemo2.java" target="_blank" rel="noopener">代码地址</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache2</span></span>&#123;</span><br><span class="line">    <span class="comment">// volatile 表示这个对象是经常变化的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一把读写锁</span></span><br><span class="line">    ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 加上写锁</span></span><br><span class="line">            readWriteLock.writeLock().lock();</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"正在写"</span>+ key);</span><br><span class="line">            <span class="comment">// 暂停一会儿线程</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"写入"</span>+ key+<span class="string">"完成"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 最后要释放写锁</span></span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 加上读锁</span></span><br><span class="line">            readWriteLock.readLock().lock();</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"正在获取"</span>+ key + <span class="string">"的值"</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"正在获取"</span>+ key + <span class="string">"的值结束"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 最后要释放读锁</span></span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 五个线程进行写操作，五个线程进行读操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyCache2 myCache2 = <span class="keyword">new</span> MyCache2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    myCache2.set(String.valueOf(num), UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(num)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    myCache2.get(String.valueOf(num));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(num)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">线程：0正在写0</span><br><span class="line">线程：0写入0完成</span><br><span class="line">线程：1正在写1</span><br><span class="line">线程：1写入1完成</span><br><span class="line">线程：4正在写4</span><br><span class="line">线程：4写入4完成</span><br><span class="line">线程：2正在写2</span><br><span class="line">线程：2写入2完成</span><br><span class="line">线程：3正在写3</span><br><span class="line">线程：3写入3完成</span><br><span class="line">线程：5正在获取5的值</span><br><span class="line">线程：5正在获取5的值结束</span><br><span class="line">线程：6正在获取6的值</span><br><span class="line">线程：7正在获取7的值</span><br><span class="line">线程：9正在获取9的值</span><br><span class="line">线程：9正在获取9的值结束</span><br><span class="line">线程：8正在获取8的值</span><br><span class="line">线程：8正在获取8的值结束</span><br><span class="line">线程：6正在获取6的值结束</span><br><span class="line">线程：7正在获取7的值结束</span><br></pre></td></tr></table></figure>
<p>现象变成了写操作是独占的了，也就是一个写操作完成之后在进行下一个写操作。读操作还是并发的</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素，当队列是空的，从队列中获取元素的操作将会被阻塞。当队列是满的，从队列中添加元素的操作将会被阻塞，试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。</p>
<p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjLxN4I9f9lFyupobAlcmU5hf3zTIdXLlguh3e2VFv.c8paDS.tdIDlEbMR3DybZyDA!!/mnull&amp;bo=*QIZAf0CGQEDCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<p>为什么需要 BlockingQueue？好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手包办了。在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p>
<h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjHx32*0XLNdML*8DmpJfnfx96zA7oIxOH2uqZAE5*suXhddVu.TETsOpLVb8MUaWFg!!/mnull&amp;bo=JgWMASYFjAEDCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<ol>
<li><strong>ArrayBlockingQueue</strong>：由数组结构组成的有界阻塞队列。（需要指定大小）</li>
<li><strong>LinkedBlockingQueue</strong>：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li>
<li><strong>SynchronousQueue</strong>：不存储元素的阻塞队列，也即单个元素的队列。</li>
<li>LinkedTransferQueue：由链表组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：由链表组成的双向阻塞队列。</li>
</ol>
<p>125标记为粗体的比较常用。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjIUYvWPF*x1WGlvR7qIaBsbc*9eMBmUVGy9oIF1iIVTF4Nt2ntaWYH2W.zBzaT53hQ!!/mnull&amp;bo=vwPYAL8D2AADCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjKjp07OeHooKhlCKTKnhRwbSeOfyJrpYXZjmN1CrhxlAPp*Wf3rsnzKbHazPhueLNw!!/mnull&amp;bo=XwPuAF8D7gADCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p><a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/BlockingQueueDemo.java" target="_blank" rel="noopener">代码地址</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 抛出异常</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.add("a"));  // true</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.add("b"));  // true</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.add("c"));  // true</span></span><br><span class="line"><span class="comment">        // blockingQueue.add("d");  // java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.remove());  // a</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.remove());  // b</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.remove());  // c</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.remove()); // java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 特殊值</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.offer("a"));  // true</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.offer("b"));  // true</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.offer("c"));  // true</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.offer("d"));  // false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.poll());  // a</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.poll());  // b</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.poll());  // c</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.poll());  // null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 阻塞</span></span><br><span class="line"><span class="comment">        blockingQueue.put("a");</span></span><br><span class="line"><span class="comment">        blockingQueue.put("b");</span></span><br><span class="line"><span class="comment">        blockingQueue.put("b");</span></span><br><span class="line"><span class="comment">        // blockingQueue.put("d");  // 会导致阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.take());  // a</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.take());  // b</span></span><br><span class="line"><span class="comment">        System.out.println(blockingQueue.take());  // c</span></span><br><span class="line"><span class="comment">        // System.out.println(blockingQueue.take());  // 会导致阻塞</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超时</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"a"</span>, <span class="number">4</span>, TimeUnit.SECONDS));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"b"</span>, <span class="number">4</span>, TimeUnit.SECONDS));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">"c"</span>, <span class="number">4</span>, TimeUnit.SECONDS));  <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.offer("d", 4, TimeUnit.SECONDS));  // 超过4s返回 false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll(<span class="number">4</span>, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(blockingQueue.poll(<span class="number">4</span>, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(blockingQueue.poll(<span class="number">4</span>, TimeUnit.SECONDS));</span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.poll(4, TimeUnit.SECONDS));  // 超过4s返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池（非常重要）"><a href="#线程池（非常重要）" class="headerlink" title="线程池（非常重要）"></a>线程池（非常重要）</h3><p>获得多线程的方式主要有四种，之前的继承 Thread 类和实现 Runable 接口。还有现在的实现 Callable 接口和 java 线程池。</p>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>线程池的优势：<br>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。它的主要特点为：线程复用;控制最大并发数;管理线程。</p>
<p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor 这几个类</p>
<p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjEWgilRtE1YyOa6hApyiQ9FldyULhEjhRa9HgqWQULCa1CxSAfRxJ86PWKPo.Jm30g!!/mnull&amp;bo=JAPmASQD5gEDCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>左边的 Executors 是工具类。这里类比 List 对象的创建，既可以用 new ArrayList ，也可以使用 Arrays.asList。同理创建线程池可以使用 Executors 工具类，也可以使用 new 的方式。</p>
<ol>
<li><p>Executors.newFixedThreadPool(int) : 创建一个线程池，一池有N个固定的线程，有固定线程数的线程。执行长期任务性能好。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">newFixedThreadPool 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的是LinkedBlockingQueue 阻塞队列。该队列最大可以存储 Integer.MAX_VALUE 个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Executors.newSingleThreadExecutor()：一个任务一个任务的执行，一池一线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">newSingleThreadExecutor 创建的线程池 corePoolSize 和 maximumPoolSize 值都是1，它使用的是LinkedBlockingQueue 阻塞队列。该队列最大可以存储 Integer.MAX_VALUE 个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Executors.newCachedThreadPool()：执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强。即自动扩充。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">newCachedThreadPool 创建的线程池将 corePoolSize 设置为0，将 maximumPoolSize 设置为Integer.MAX_VALUE，它使用的是 SynchronousQueue 队列，该队列最大可以一个值，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用示例：<a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/ThreadPoolDemo.java" target="_blank" rel="noopener">代码地址</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程池，并指定大小为 3</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(3);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程池，里面就只有一个线程</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程池，里面的线程自动扩充</span></span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 将 10 个或者更多的任务交给线程池中的线程执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"执行了任务！"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>FixedThreadPool, SingleThreadExecutor，CachedThreadPool 底层都是调用 ThreadPoolExecutor 的，只是参数不同而已。ThreadPoolExecutor 的参数有七个，列举如下：</p>
<ol>
<li>corePoolsize: 线程池中常驻的核心线程数。核心线程是懒加载的，也就是说例如 corePoolsize 是 5，new 的时候并没有真正的创建出 5 个线程出来，而是在调用 execute 方法的时候才创建。</li>
<li>maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</li>
<li>keepAliveTime：多余的空闲线程的存活时间，当前池中线程数量超过 corePoolSize 时，当空闲时间达到keepAliveTime 时，多余线程会被销毁直到只剩下 corePoolSize 个线程为止。</li>
<li>unit：keepAliveTime的单位 </li>
<li>workQueue：任务队列，被提交但尚未被执行的任务</li>
<li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可</li>
<li>handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的 runnable 的策略。</li>
</ol>
<h4 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h4><p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjMaZgjxXbCcefPZ6ZQSu*.Q2J6e0IQGVrV3HuDs8*xhqPVCevqJSXu1o*ZWvf3Amaw!!/mnull&amp;bo=ugU.BboFPgUDCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<ol>
<li>在创建了线程池后，线程池中的线程数为零。</li>
<li>当调用 execute() 方法添加一个请求任务时，线程池会做出如下判断：<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>
<li>如果这个时候队列满了且正在运行的线程数量还小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务，注意⚠️这里不是将它放入队列，因为队列已经满了，而是马上创建线程来执行这个任务，创建的线程是直接执行这个任务，不去队列里面取任务。当执行完这个任务，才回去队列里面取任务。</li>
<li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li>
</ul>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li>
</ol>
<h4 id="哪种方式创建线程池最好"><a href="#哪种方式创建线程池最好" class="headerlink" title="哪种方式创建线程池最好"></a>哪种方式创建线程池最好</h4><p>答案是一个都不用，只使用自定义的！！！</p>
<p><img src="https://r.photo.store.qq.com/psc?/V12EvAd609VbnF/ChQ0KIcA.iub3F93BayOjIjwi6wUzUmIuwA*qOWKQQzE6aH6wofLJZGkGRq1xKBKuK3S8XWe7CofJLKhFVD7EQ!!/mnull&amp;bo=2ANbAdgDWwEDCSw!&amp;rf=photolist&amp;t=5/r/_yake_qzoneimgout.png" alt></p>
<h4 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h4><ol>
<li>AbortPolicy(默认)：直接抛出 RejectedExecutionException 异常阻止系统正常运行。即当核心线程数满后，且阻塞队列也满后，如果是该策略，那么会抛出异常。</li>
<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。 即当核心线程数满后，且阻塞队列也满后，如果是该策略，任务从哪儿来，就回到哪儿去。</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。即当核心线程数满后，且阻塞队列也满后，如果是该策略，那么新的线程任务会替换掉队列中的最老的任务。</li>
<li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。即当核心线程数满后，且阻塞队列也满后，如果是该策略，任务直接就丢失了。</li>
</ol>
<h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p><a href="https://github.com/rexyan/it_guigu/blob/master/juc/src/main/java/com/atguigu/juc/MyThreadPool.java" target="_blank" rel="noopener">代码地址</a></p>
<h5 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h5><p>上面了解到，实际生产环境中，我们并不会去用 Excutors 来创建线程池，一般都是自己使用 ThreadPoolExecutor 来实现。下面就是示例，并且用到了各个拒绝策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,  <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>,  <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">3L</span>,  <span class="comment">// 回收非核心线程的时间</span></span><br><span class="line">                TimeUnit.SECONDS,  <span class="comment">// 回收非核心线程的时间单位</span></span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),  <span class="comment">// 阻塞队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),  <span class="comment">// 默认线程池工厂</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()  <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> ; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +<span class="string">"执行"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用的是 AbortPolicy 拒绝策略。当 for 循环中的 i&lt;= 5 的时候，都是核心线程在执行。原因是 5 大于核心线程数，大于后，会将任务放入阻塞队列中，阻塞队列大小是3，正好将 3 个放进去。（类比去银行办理业务，只有两个柜台在办理，三个等候的位置，那么来五个人是核心线程可以处理的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"执行"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-2执行  // 两个核心线程就能完成工作</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br></pre></td></tr></table></figure>
<p>此时，如果将 for 循环中的 i 的值改为 6 的时候，核心线程就处理不过来了，因为核心线程数为 2，队列里面最多可以阻塞3个，还剩1个任务没有地方处理，但是现在线程数量没有达到最大的线程数，此时可以启动新的线程来处理任务，只要保证线程的最大数量不能超过 5 个，即 核心线程 + 新的非核心线程 &lt;= 5 即可。所以 i 的值为 6-8 之间都需要创建新的线程来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span> ; i++) &#123;</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"执行"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1执行  </span><br><span class="line">线程：pool-1-thread-3执行  // 两个线程已经不能完成任务了，又创建了 3，4，5 三个非核心线程来帮忙</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-5执行</span><br></pre></td></tr></table></figure>
<p>但是一旦超过 8，假设 i 的值为 9，此时核心线程为2，队列阻塞3个，创建新线程运行3个，那就还剩下一个任务没有被处理，那么此时就会走拒绝策略了。而此时的拒绝策略是 AbortPolicy，所以直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span> ; i++) &#123;</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"执行"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-5执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task com.atguigu.juc.MyThreadPool$1@66d3c617 rejected from java.util.concurrent.ThreadPoolExecutor@63947c6b[Running, pool size = 5, active threads = 0, queued tasks = 0, completed tasks = 8]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)</span><br><span class="line">	at com.atguigu.juc.MyThreadPool.main(MyThreadPool.java:22)</span><br></pre></td></tr></table></figure>
<h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p>当任务数量 i 可以被处理时，处理的方法和上面 AbortPolicy 分析一样的，这里只说明当任务数量不能被处理，运行 CallerRunsPolicy 的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,  <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>,  <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">3L</span>,  <span class="comment">// 回收非核心线程的时间</span></span><br><span class="line">                TimeUnit.SECONDS,  <span class="comment">// 回收非核心线程的时间单位</span></span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),  <span class="comment">// 阻塞队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),  <span class="comment">// 默认线程池工厂</span></span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.AbortPolicy()  // 拒绝策略</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">33</span> ; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"执行"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-5执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：main执行   // 当处理不了的时候，从哪儿来就回哪儿去</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><p>当任务数量 i 可以被处理时，处理的方法和上面 AbortPolicy 分析一样的，这里只说明当任务数量不能被处理，运行 DiscardOldestPolicy 的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,  <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>,  <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">3L</span>,  <span class="comment">// 回收非核心线程的时间</span></span><br><span class="line">                TimeUnit.SECONDS,  <span class="comment">// 回收非核心线程的时间单位</span></span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),  <span class="comment">// 阻塞队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),  <span class="comment">// 默认线程池工厂</span></span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.AbortPolicy()  // 拒绝策略</span></span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.CallerRunsPolicy()</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">33</span> ; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"执行"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-5执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-5执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br></pre></td></tr></table></figure>
<p>有一部分老的任务没有执行，被新的任务给替代了</p>
<h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><p>当任务数量 i 可以被处理时，处理的方法和上面 AbortPolicy 分析一样的，这里只说明当任务数量不能被处理，运行 DiscardPolicy 的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,  <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>,  <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">3L</span>,  <span class="comment">// 回收非核心线程的时间</span></span><br><span class="line">                TimeUnit.SECONDS,  <span class="comment">// 回收非核心线程的时间单位</span></span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">3</span>),  <span class="comment">// 阻塞队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),  <span class="comment">// 默认线程池工厂</span></span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.AbortPolicy()  // 拒绝策略</span></span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.CallerRunsPolicy()</span></span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.DiscardOldestPolicy()</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">33</span> ; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span> + Thread.currentThread().getName() + <span class="string">"执行"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-5执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-4执行</span><br><span class="line">线程：pool-1-thread-1执行</span><br><span class="line">线程：pool-1-thread-3执行</span><br><span class="line">线程：pool-1-thread-2执行</span><br><span class="line">线程：pool-1-thread-5执行</span><br></pre></td></tr></table></figure>
<p>尽自己最大的努力执行，能执行多少就执行多少。</p>
<h3 id="分支合并框架"><a href="#分支合并框架" class="headerlink" title="分支合并框架"></a>分支合并框架</h3><h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3>
    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"><i class="fa fa-tag"></i> JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/19/55. Zookeeper/" rel="prev" title="55. Zookeeper">
      <i class="fa fa-chevron-left"></i> 55. Zookeeper
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/14/57. MP 使用/" rel="next" title="57. MP 使用">
      57. MP 使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC"><span class="nav-number">1.</span> <span class="nav-text">JUC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的状态"><span class="nav-number">2.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-sleep-的区别"><span class="nav-number">3.</span> <span class="nav-text">wait/sleep 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发-并行"><span class="nav-number">4.</span> <span class="nav-text">并发/并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock"><span class="nav-number">5.</span> <span class="nav-text">Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">5.1.</span> <span class="nav-text">ReentrantLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java8特性"><span class="nav-number">6.</span> <span class="nav-text">java8特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数式接口"><span class="nav-number">6.1.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内置四大函数式接口"><span class="nav-number">6.2.</span> <span class="nav-text">内置四大函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream-流"><span class="nav-number">6.3.</span> <span class="nav-text">Stream 流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda-表达式"><span class="nav-number">6.4.</span> <span class="nav-text">lambda 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口里是否能有实现方法"><span class="nav-number">6.5.</span> <span class="nav-text">接口里是否能有实现方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程间通信"><span class="nav-number">7.</span> <span class="nav-text">线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-实现"><span class="nav-number">7.1.</span> <span class="nav-text">synchronized 实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lock-实现"><span class="nav-number">7.2.</span> <span class="nav-text">lock 实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程间定制化通信"><span class="nav-number">8.</span> <span class="nav-text">线程间定制化通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程不安全"><span class="nav-number">9.</span> <span class="nav-text">线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List-线程安全"><span class="nav-number">9.1.</span> <span class="nav-text">List 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Vector"><span class="nav-number">9.1.1.</span> <span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Collections"><span class="nav-number">9.1.2.</span> <span class="nav-text">Collections</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">9.1.3.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set-线程安全"><span class="nav-number">9.2.</span> <span class="nav-text">Set 线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map-线程安全"><span class="nav-number">9.3.</span> <span class="nav-text">Map 线程安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable"><span class="nav-number">10.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC-强大辅助类"><span class="nav-number">11.</span> <span class="nav-text">JUC 强大辅助类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">11.1.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">11.2.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore"><span class="nav-number">11.3.</span> <span class="nav-text">Semaphore</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁"><span class="nav-number">12.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列"><span class="nav-number">13.</span> <span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介"><span class="nav-number">13.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现类"><span class="nav-number">13.2.</span> <span class="nav-text">实现类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法"><span class="nav-number">13.3.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实例"><span class="nav-number">13.4.</span> <span class="nav-text">代码实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池（非常重要）"><span class="nav-number">14.</span> <span class="nav-text">线程池（非常重要）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介-1"><span class="nav-number">14.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体实现"><span class="nav-number">14.2.</span> <span class="nav-text">具体实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">14.3.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池底层工作原理"><span class="nav-number">14.4.</span> <span class="nav-text">线程池底层工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哪种方式创建线程池最好"><span class="nav-number">14.5.</span> <span class="nav-text">哪种方式创建线程池最好</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池拒绝策略"><span class="nav-number">14.6.</span> <span class="nav-text">线程池拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义线程池"><span class="nav-number">14.7.</span> <span class="nav-text">自定义线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AbortPolicy"><span class="nav-number">14.7.1.</span> <span class="nav-text">AbortPolicy</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CallerRunsPolicy"><span class="nav-number">14.8.</span> <span class="nav-text">CallerRunsPolicy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DiscardOldestPolicy"><span class="nav-number">14.9.</span> <span class="nav-text">DiscardOldestPolicy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DiscardPolicy"><span class="nav-number">14.10.</span> <span class="nav-text">DiscardPolicy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支合并框架"><span class="nav-number">15.</span> <span class="nav-text">分支合并框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步回调"><span class="nav-number">16.</span> <span class="nav-text">异步回调</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rex"
      src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
  <p class="site-author-name" itemprop="name">Rex</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">446</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa-hand-o-right"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rex</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
