<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rexyan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"top","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="摘要 本书 《Python Concurrency with asyncio》, 是 manning 上的一本关于 Python asyncio 的书籍，在这之前对 Python 的协程接触不多，读完后了解了大概，知道了一些使用套路和常用的 API，是一本不错的 Python asyncio 的数据。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python Concurrency with asyncio">
<meta property="og:url" content="https://rexyan.github.io/2023/06/27/Python Concurrency with asyncio/index.html">
<meta property="og:site_name" content="星尘">
<meta property="og:description" content="摘要 本书 《Python Concurrency with asyncio》, 是 manning 上的一本关于 Python asyncio 的书籍，在这之前对 Python 的协程接触不多，读完后了解了大概，知道了一些使用套路和常用的 API，是一本不错的 Python asyncio 的数据。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230731191426.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202306272157794.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202306272206608.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202306272219244.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202306272224187.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230629102649.png">
<meta property="og:updated_time" content="2025-10-31T03:20:39.398Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python Concurrency with asyncio">
<meta name="twitter:description" content="摘要 本书 《Python Concurrency with asyncio》, 是 manning 上的一本关于 Python asyncio 的书籍，在这之前对 Python 的协程接触不多，读完后了解了大概，知道了一些使用套路和常用的 API，是一本不错的 Python asyncio 的数据。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230731191426.png">

<link rel="canonical" href="https://rexyan.github.io/2023/06/27/Python Concurrency with asyncio/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python Concurrency with asyncio | 星尘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css" />
  <!-- 自定义为霞鹜文楷字体 -->
  <style>
	  body,div.post-body,h1,h2,h3,h4 {
		font-family: "LXGW WenKai Screen", sans-serif;
		font-size: 104%;
	  }
  </style>
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">星尘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-读书">

    <a href="/books/" rel="section"><i class="address-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-瞎扯">

    <a href="/crap/" rel="section"><i class="crap fa-fw"></i>瞎扯</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



<script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script>

<meta name="referrer" content="never">




  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rexyan.github.io/2023/06/27/Python Concurrency with asyncio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
      <meta itemprop="name" content="Rex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星尘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python Concurrency with asyncio
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-27 23:04:57" itemprop="dateCreated datePublished" datetime="2023-06-27T23:04:57+00:00">2023-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-31 03:20:39" itemprop="dateModified" datetime="2025-10-31T03:20:39+00:00">2025-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-进阶/" itemprop="url" rel="index"><span itemprop="name">Python 进阶</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/阅读/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230731191426.png" alt></p>
<p>本书 <a href="https://www.manning.com/books/python-concurrency-with-asyncio" target="_blank" rel="noopener">《Python Concurrency with asyncio》</a>, 是 manning 上的一本关于 Python asyncio 的书籍，在这之前对 Python 的协程接触不多，读完后了解了大概，知道了一些使用套路和常用的 API，是一本不错的 Python asyncio 的数据。</p>
<a id="more"></a>
<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><p>并发，我们可以同时进行多个任务，但在给定时间点只有一个是我们正在积极进行的。而并行则表示多个任务同时进行且我们正在同时积极地处理多个任务。</p>
<h4 id="GIL-锁"><a href="#GIL-锁" class="headerlink" title="GIL 锁"></a>GIL 锁</h4><p>GIL防止一个Python进程在任何给定时间执行多于一个的Python字节码指令，也就是说，即使我们在具有多个核心的机器上拥有多个线程，Python进程也只能一次运行一个线程的Python代码。</p>
<p>即，<strong>GIL锁是每个进程一个，当在一个进程中有多个线程时，由于GIL的存在，这些线程并不能并发运行。</strong>由于每个 Python 进程都有自己的 GIL，所以<strong>多进程可以并发地运行多个字节码指令。</strong></p>
<p>全局解释器锁在发生 I/O 操作时被释放。这允许我们使用线程在处理 I/O 时进行并发工作，但不适用于 CPU 密集型的 Python 代码本身，所以多线程适合IO密集的场景。</p>
<blockquote>
<p>这是因为在I/O的情况下，低级别的系统调用在Python运行时之外。这使得GIL可以被释放因为它没有直接与Python对象交互。在这种情况下，只有当接收到的数据被转换成Python对象时，GIL才会被重新获得。然后，在操作系统级别上，I/O操作会同时执行。</p>
</blockquote>
<p>asyncio 并没有规避 GIL，我们仍旧受到其限制。如果我们有一个 CPU密集的任务，仍然需要使用多个进程并发执行，这样才能高效率。</p>
<h4 id="多进程代码示例"><a href="#多进程代码示例" class="headerlink" title="多进程代码示例"></a>多进程代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_from_process</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f'Hello from child process <span class="subst">&#123;os.getpid()&#125;</span>!'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    hello_process = multiprocessing.Process(target=hello_from_process)</span><br><span class="line">    hello_process.start()</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">f'Hello from parent process <span class="subst">&#123;os.getpid()&#125;</span>'</span>)</span><br><span class="line"> </span><br><span class="line">    hello_process.join()</span><br></pre></td></tr></table></figure>
<h4 id="多线程代码示例"><a href="#多线程代码示例" class="headerlink" title="多线程代码示例"></a>多线程代码示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_example</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    response = requests.get(<span class="string">'https://www.example.com'</span>)</span><br><span class="line">    print(response.status_code)</span><br><span class="line">    </span><br><span class="line">thread_1 = threading.Thread(target=read_example)</span><br><span class="line">thread_2 = threading.Thread(target=read_example)</span><br><span class="line"></span><br><span class="line">thread_start = time.time()</span><br><span class="line"></span><br><span class="line">thread_1.start()</span><br><span class="line">thread_2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'All threads running!'</span>)</span><br><span class="line"></span><br><span class="line">thread_1.join()</span><br><span class="line">thread_2.join()</span><br><span class="line"></span><br><span class="line">thread_end = time.time()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'Running with threads took <span class="subst">&#123;thread_end - thread_start:<span class="number">.4</span>f&#125;</span> seconds.'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="操作系统事件通知"><a href="#操作系统事件通知" class="headerlink" title="操作系统事件通知"></a>操作系统事件通知</h4><p>asyncio 被抽象化了，它会根据我们的操作系统支持的通知系统的不同而切换。以下是特定操作系统使用的事件通知系统：</p>
<ul>
<li><p>kqueue - FreeBSD和MacOS</p>
</li>
<li><p>epoll—Linuxepoll - Linux</p>
</li>
<li><p>IOCP - Windows</p>
</li>
</ul>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h4 id="简单协程示例"><a href="#简单协程示例" class="headerlink" title="简单协程示例"></a>简单协程示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine_add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">result = asyncio.run(coroutine_add_one(<span class="number">1</span>))</span><br><span class="line">print(coroutine_add_one(<span class="number">1</span>))  <span class="comment"># &lt;coroutine object coroutine_add_one at 0x0000022183C8ADC0&gt;</span></span><br><span class="line">print(result)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h4 id="添加-await-关键字"><a href="#添加-await-关键字" class="headerlink" title="添加 await 关键字"></a>添加 await 关键字</h4><p>使用 await 关键字会使其后面的协程运行，不同于直接调用协程会生成一个协程对象。await 表达式还会暂停包含它的协程（父协程），直到我们等待的协程完成并返回结果。当等待的协程完成后，我们将可以访问返回的结果，并且包含它的协程（父协程）将会“唤醒”以处理结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    one_plus_one = <span class="keyword">await</span> add_one(<span class="number">1</span>) <span class="comment"># 暂停一下，等待add_one(1)的结果</span></span><br><span class="line">    two_plus_one = <span class="keyword">await</span> add_one(<span class="number">2</span>) <span class="comment"># 暂停一下，等待add_one(2)的结果</span></span><br><span class="line">    print(one_plus_one)</span><br><span class="line">    print(two_plus_one)</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>目前而言，这段代码与普通的顺序代码执行没有区别。<img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202306272157794.png" alt></p>
<h4 id="asyncio-sleep"><a href="#asyncio-sleep" class="headerlink" title="asyncio.sleep"></a>asyncio.sleep</h4><p>asyncio.sleep本身就是一个协程，因此我们必须使用await关键字来调用它。如果我们仅仅调用它本身，我们将会得到一个协程对象。由于asyncio.sleep是一个协程，这意味着当一个协程等待它时，其他的代码会被执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_world_message</span><span class="params">()</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 暂停hello_world_message 1秒钟</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">	message = hello_world_message()  <span class="comment"># 等待hello_world_message完成后再继续主程序</span></span><br><span class="line">    print(message)</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>下面的 delay 是自己封装的 asyncio.sleep 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(delay_seconds: int)</span> -&gt; int:</span></span><br><span class="line">    print(<span class="string">f'sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay_seconds)</span><br><span class="line">    print(<span class="string">f'finished sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">return</span> delay_seconds</span><br></pre></td></tr></table></figure>
<p>两个协程示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">1</span>)  <span class="comment"># delay 是自己封装的 asyncio.sleep 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    message = <span class="keyword">await</span> hello_world()  <span class="comment"># 在 hello_world_message 返回之前，暂停主程序</span></span><br><span class="line">    one_plus_one = <span class="keyword">await</span> add_one(<span class="number">1</span>)  <span class="comment"># 在 add_one 返回之前暂停主程序</span></span><br><span class="line">    print(one_plus_one)</span><br><span class="line">    print(message)</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>当我们运行此代码时，需要等待1秒钟才会打印出两个函数调用的结果。因为 await 使我们的当前协程暂停，并且在 await 表达式给出一个值之前，不会执行协程中的任何其他代码。由于需要1秒钟才能让 hello_world 函数给我们一个值，因此主协程会暂停1秒钟。这种情况下，我们的代码的行为就如同是顺序执行的。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202306272206608.png" alt></p>
<p><strong>任务</strong>是协程的包装器，可以调度协程尽快在事件循环上运行。此调度和执行以非阻塞方式进行，意味着一旦我们创建任务，我们可以在任务运行时立即执行其他代码。这与使用 await 关键字形成对比，await 以阻塞方式运行，意味着我们暂停整个协程，直到 await 表达式的结果返回。</p>
<p>创建任务可以通过使用 asyncio.create_task 函数来实现。当我们调用此函数时，我们将协程传递给它运行，它会立即返回一个任务对象。一旦我们有了一个任务对象，我们就可以将它放在一个等待表达式中，在任务完成时提取返回值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    sleep_for_three = asyncio.create_task(delay(<span class="number">3</span>))  <span class="comment"># 创建一个任务，创建后立即返回</span></span><br><span class="line">    print(type(sleep_for_three))   <span class="comment"># 立即返回</span></span><br><span class="line">    result = <span class="keyword">await</span> sleep_for_three  <span class="comment"># 阻塞3s后打印 result</span></span><br><span class="line">    print(result)</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="运行多个任务"><a href="#运行多个任务" class="headerlink" title="运行多个任务"></a>运行多个任务</h4><p>示例一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    sleep_for_three = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line">    sleep_again = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line">    sleep_once_more = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">await</span> sleep_for_three</span><br><span class="line">    <span class="keyword">await</span> sleep_again</span><br><span class="line">    <span class="keyword">await</span> sleep_once_more</span><br><span class="line">    </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>我们启动了三个任务，每个任务花费3秒钟来完成。每次调用 create_task 都会立即返回，所以我们很快进入 await sleep_for_three 语句。在创建任务后第一次遇到 await 语句时，任何待处理的任务都会随着 await 触发事件循环的迭代而运行。</p>
<p>所以从 await sleep_for_three 开始，所有三个任务开始运行并将同时进行任何睡眠操作。这意味着上面代码约在 3s 左右完成。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202306272219244.png" alt></p>
<p>示例二:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_every_second</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">"I'm running other code while I'm waiting!"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    first_delay = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line">    second_delay = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">await</span> hello_every_second()</span><br><span class="line">    <span class="keyword">await</span> first_delay</span><br><span class="line">    <span class="keyword">await</span> second_delay</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">sleeping for 3 second(s)</span></span><br><span class="line"><span class="string">sleeping for 3 second(s)</span></span><br><span class="line"><span class="string">I'm running other code while I'm waiting!</span></span><br><span class="line"><span class="string">I'm running other code while I'm waiting!</span></span><br><span class="line"><span class="string">finished sleeping for 3 second(s)</span></span><br><span class="line"><span class="string">finished sleeping for 3 second(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202306272224187.png" alt></p>
<p>上述代码中创建了两个任务，每个任务需要3秒钟才能完成。当这些任务在等待时，我们的应用程序处于空闲状态，这给了我们运行其他代码的机会。在这种情况下，我们运行一个名为 hello_every_second 的协程，它每秒钟打印一次消息，共打印2次。</p>
<h4 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h4><p>取消任务很简单。每个任务对象都有一个叫做 cancel 的方法，我们可以在任何时候调用它来停止任务。取消任务将导致该任务在我们等待它时引发一个 CancelledError。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> CancelledError</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    long_task = asyncio.create_task(delay(<span class="number">10</span>))</span><br><span class="line"> </span><br><span class="line">    seconds_elapsed = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> long_task.done():</span><br><span class="line">        print(<span class="string">'Task not finished, checking again in a second.'</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        seconds_elapsed = seconds_elapsed + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> seconds_elapsed == <span class="number">5</span>:</span><br><span class="line">            long_task.cancel()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> long_task</span><br><span class="line">    <span class="keyword">except</span> CancelledError:</span><br><span class="line">        print(<span class="string">'Our task was cancelled'</span>)</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述我们创建了一个需要运行10秒的任务。然后，我们创建了一个 while 循环来检查该任务是否完成。任务上的done方法会在任务完成时返回 True，否则返回False。每秒钟，我们都会检查任务是否完成，记录已经检查了多少秒。如果任务已经进行了5秒钟，我们将取消该任务。然后，我们将进行等待 long_task，并且我们将看到打印出 Our task was cancelled，表示我们已经捕获了 CancelledError。</p>
<h4 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h4><h5 id="超时后任务被取消"><a href="#超时后任务被取消" class="headerlink" title="超时后任务被取消"></a>超时后任务被取消</h5><p>asyncio.wait_for 函数接受一个协程或任务对象，以及以秒为单位指定的超时。然后它返回一个我们可以等待的协程。如果完成任务所需的时间比我们指定的超时时间长，则会引发 TimeoutException。一旦达到超时阈值，任务将自动取消。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    delay_task = asyncio.create_task(delay(<span class="number">2</span>))  <span class="comment"># sleep 2 秒</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(delay_task, timeout=<span class="number">1</span>)  <span class="comment"># 在1s的时候超时，得到 TimeoutError</span></span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">except</span> asyncio.exceptions.TimeoutError:</span><br><span class="line">        print(<span class="string">'Got a timeout!'</span>)</span><br><span class="line">        print(<span class="string">f'Was the task cancelled? <span class="subst">&#123;delay_task.cancelled()&#125;</span>'</span>)  <span class="comment"># 通过 cancelled() 方法判断是否被取消</span></span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">Got a timeout!</span></span><br><span class="line"><span class="string">Was the task cancelled? True</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h5 id="超时后任务不取消"><a href="#超时后任务不取消" class="headerlink" title="超时后任务不取消"></a>超时后任务不取消</h5><p>调用 wait_for 并将任务包装在 shield 中，这将防止任务被取消。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task = asyncio.create_task(delay(<span class="number">10</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(asyncio.shield(task), <span class="number">5</span>)</span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">except</span> TimeoutError:</span><br><span class="line">        print(<span class="string">"任务已超时，但不会停止运行!"</span>)</span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(result)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">sleeping for 10 second(s)</span></span><br><span class="line"><span class="string">任务已超时，但不会停止运行!</span></span><br><span class="line"><span class="string">finished sleeping for 10 second(s)</span></span><br><span class="line"><span class="string">finished &lt;function delay at 0x10e8cf820&gt; in 10 second(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h4 id="future"><a href="#future" class="headerlink" title="future"></a>future</h4><p>future 是一个 Python 对象，其中包含您期望在未来某个时刻获得但可能尚未获得的单个值。通常，当你创建一个 future 时，它没有任何价值，因为它还不存在。在这种状态下，它被认为是不完整的、未解决的或根本没有完成。我们可以设定 future 的值。到那时，我们就可以认为它完成了，并从 future 提取结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Future</span><br><span class="line"> </span><br><span class="line">my_future = Future()</span><br><span class="line"> </span><br><span class="line">print(<span class="string">f'Is my_future done? <span class="subst">&#123;my_future.done()&#125;</span>'</span>)  <span class="comment"># False</span></span><br><span class="line"> </span><br><span class="line">my_future.set_result(<span class="number">42</span>)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">f'Is my_future done? <span class="subst">&#123;my_future.done()&#125;</span>'</span>)  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">f'What is the result of my_future? <span class="subst">&#123;my_future.result()&#125;</span>'</span>)  <span class="comment"># 42</span></span><br></pre></td></tr></table></figure>
<p>Future 也可以用在 await 表达式中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_request</span><span class="params">()</span> -&gt; Future:</span></span><br><span class="line">    future = Future()</span><br><span class="line">    asyncio.create_task(set_future_value(future)) <span class="comment"># 创建一个任务来异步设置 future 的值。</span></span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">set_future_value</span><span class="params">(future)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 等待 1 秒后再设置 future 的值</span></span><br><span class="line">    future.set_result(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    future = make_request()</span><br><span class="line">    print(<span class="string">f"Is the future done? <span class="subst">&#123;future.done()&#125;</span>"</span>)</span><br><span class="line">    value = <span class="keyword">await</span> future  <span class="comment"># 暂停 main 直到 future 的值被设置</span></span><br><span class="line">    print(<span class="string">f"Is the future done? <span class="subst">&#123;future.done()&#125;</span>"</span>)</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Is the future done? False</span></span><br><span class="line"><span class="string">Is the future done? True</span></span><br><span class="line"><span class="string">42</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码在 make_request 中创建了一个 future，并将其传入到了 task 中，然后在 set_future_value 中进行 future 值的设置。可以使用 future.done() 的来获取 future 的状态。</p>
<h4 id="Awaitable"><a href="#Awaitable" class="headerlink" title="Awaitable"></a>Awaitable</h4><p>task 和 future 之间存在着密切的关系，task  直接继承自 future。当我们创建一个 task 时，可以理解为正在创建一个空的 future 并运行协程。然后，当协程完成并出现异常或结果时，在将值设置到 future  中。</p>
<p>这些类型都可以在await 表达式中使用？但是任何实现<code>__await__</code>方法的东西都可以在等待表达式中使用。协程直接继承自 Awaitable，future 也是如此。然后 task 继承自 future。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230629102649.png" alt></p>
<h4 id="协程装饰器"><a href="#协程装饰器" class="headerlink" title="协程装饰器"></a>协程装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Callable, Any</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_timed</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func: Callable)</span> -&gt; Callable:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span> -&gt; Any:</span></span><br><span class="line">            print(<span class="string">f'starting <span class="subst">&#123;func&#125;</span> with args <span class="subst">&#123;args&#125;</span> <span class="subst">&#123;kwargs&#125;</span>'</span>)</span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                end = time.time()</span><br><span class="line">                total = end - start</span><br><span class="line">                print(<span class="string">f'finished <span class="subst">&#123;func&#125;</span> in <span class="subst">&#123;total:<span class="number">.4</span>f&#125;</span> second(s)'</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(delay_seconds: int)</span> -&gt; int:</span></span><br><span class="line">    print(<span class="string">f'sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay_seconds)</span><br><span class="line">    print(<span class="string">f'finished sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">return</span> delay_seconds</span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_one = asyncio.create_task(delay(<span class="number">2</span>))</span><br><span class="line">    task_two = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> task_one</span><br><span class="line">    <span class="keyword">await</span> task_two</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">starting &lt;function main at 0x109111ee0&gt; with args () &#123;&#125;</span></span><br><span class="line"><span class="string">starting &lt;function delay at 0x1090dc700&gt; with args (2,) &#123;&#125;</span></span><br><span class="line"><span class="string">starting &lt;function delay at 0x1090dc700&gt; with args (3,) &#123;&#125;</span></span><br><span class="line"><span class="string">finished &lt;function delay at 0x1090dc700&gt; in 2.0032 second(s)</span></span><br><span class="line"><span class="string">finished &lt;function delay at 0x1090dc700&gt; in 3.0003 second(s)</span></span><br><span class="line"><span class="string">finished &lt;function main at 0x109111ee0&gt; in 3.0004 second(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h4 id="两种错误的异步场景"><a href="#两种错误的异步场景" class="headerlink" title="两种错误的异步场景"></a>两种错误的异步场景</h4><h5 id="将CPU密集型任务运行在协程中"><a href="#将CPU密集型任务运行在协程中" class="headerlink" title="将CPU密集型任务运行在协程中"></a>将CPU密集型任务运行在协程中</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"> </span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cpu_bound_work</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>):  <span class="comment"># CPU 密集型任务</span></span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_one = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    task_two = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    <span class="keyword">await</span> task_one</span><br><span class="line">    <span class="keyword">await</span> task_two</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">starting &lt;function main at 0x10a8f6c10&gt; with args () &#123;&#125;</span></span><br><span class="line"><span class="string">starting &lt;function cpu_bound_work at 0x10a8c0430&gt; with args () &#123;&#125;</span></span><br><span class="line"><span class="string">finished &lt;function cpu_bound_work at 0x10a8c0430&gt; in 4.6750 second(s)</span></span><br><span class="line"><span class="string">starting &lt;function cpu_bound_work at 0x10a8c0430&gt; with args () &#123;&#125;</span></span><br><span class="line"><span class="string">finished &lt;function cpu_bound_work at 0x10a8c0430&gt; in 4.6680 second(s)</span></span><br><span class="line"><span class="string">finished &lt;function main at 0x10a8f6c10&gt; in 9.3434 second(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>尽管上述代码创建了两个任务，但我们的代码仍然按顺序执行。首先，我们运行 task_one，然后运行 task_two，这意味着我们的总运行时间将是对 cpu_bound_work 的两次调用的总和。</p>
<p>下面代码也存在同样的问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed, delay</span><br><span class="line"> </span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cpu_bound_work</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>):  <span class="comment"># CPU 密集型任务</span></span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"> </span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_one = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    task_two = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    delay_task = asyncio.create_task(delay(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">await</span> task_one  <span class="comment"># 先 await CPU 密集型任务</span></span><br><span class="line">    <span class="keyword">await</span> task_two</span><br><span class="line">    <span class="keyword">await</span> delay_task</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>为什么会出现这样的现象呢？因为我们首先创建了两个 CPU 密集型任务，这实际上阻止了事件循环运行其他任何任务。这将导致我们的任务会按照顺序执行。</p>
<p>如果我们需要执行 CPU 密集型工作并且仍然想使用 async/await 语法。 那么我们需要将 asyncio 和进程池进行结合使用。</p>
<h5 id="使用阻塞的-I-O-操作"><a href="#使用阻塞的-I-O-操作" class="headerlink" title="使用阻塞的 I/O 操作"></a>使用阻塞的 I/O 操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"> </span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_example_status</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> requests.get(<span class="string">'http://www.example.com'</span>).status_code</span><br><span class="line"> </span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_1 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_2 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_3 = asyncio.create_task(get_example_status())</span><br><span class="line">    <span class="keyword">await</span> task_1</span><br><span class="line">    <span class="keyword">await</span> task_2</span><br><span class="line">    <span class="keyword">await</span> task_3</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">starting &lt;function main at 0x1102e6820&gt; with args () &#123;&#125;</span></span><br><span class="line"><span class="string">starting &lt;function get_example_status at 0x1102e6700&gt; with args () &#123;&#125;</span></span><br><span class="line"><span class="string">finished &lt;function get_example_status at 0x1102e6700&gt; in 0.0839 second(s)</span></span><br><span class="line"><span class="string">starting &lt;function get_example_status at 0x1102e6700&gt; with args () &#123;&#125;</span></span><br><span class="line"><span class="string">finished &lt;function get_example_status at 0x1102e6700&gt; in 0.0441 second(s)</span></span><br><span class="line"><span class="string">starting &lt;function get_example_status at 0x1102e6700&gt; with args () &#123;&#125;</span></span><br><span class="line"><span class="string">finished &lt;function get_example_status at 0x1102e6700&gt; in 0.0419 second(s)</span></span><br><span class="line"><span class="string">finished &lt;function main at 0x1102e6820&gt; in 0.1702 second(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，主协程的总运行时间大致是所有任务运行的时间总和，这意味着我们没有任何并发优势。</p>
<p>为什么会这样呢？这是因为 request 库不返回协程，是一个阻塞的API。在上面的示例中，我们可以使用 aiohttp 等库来替换 request。如果不想换库，就是需要使用 requests 库，我们仍然可以使用 async 语法，但需要显式告诉 asyncio 使用线程池来执行。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>目前，我们已经使用 asyncio.run 来运行我们的应用程序并在幕后为我们创建事件循环。我们还有其他方式可以创建事件循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.new_event_loop()  <span class="comment"># 返回一个事件循环实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    loop.run_until_complete(main())  <span class="comment"># 接受一个协程并运行它直到完成</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure>
<p>我们还可以获取当前的事件循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_later</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'm being called in the future!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()  <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop.call_soon(call_later)  <span class="comment"># 执行函数在事件循环的下一次迭代中运行</span></span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())  <span class="comment"># asyncio.run 会创建一个事件循环</span></span><br></pre></td></tr></table></figure>
<p>除了 asyncio.get_running_loop 函数可以获取事件循环外，另一个函数 asyncio.get_event _loop 也可以。区别在于如果在事件循环未运行期间调用 asyncio.get_event _loop，则会创建一个新的事件循环，这样可能会导致一些奇怪的问题。所以建议使用  asyncio.get_running_loop 来获取当前的事件循环。</p>
<h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><p>方式一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncio.run(coroutine(), debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -X dev program.py</span><br></pre></td></tr></table></figure>
<p>方式三：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYTHONASYINCIODEBUG=<span class="number">1</span> python3 program.py</span><br></pre></td></tr></table></figure>
<p>在早于 3.9 的 Python 版本中, 使用 asyncio.run 时，只有 debug 参数才有效。命令行参数和环境变量仅在手动管理事件循环时才起作用。</p>
<p>例如在 CPU 密集型操作中，如果协程花费的时间太长，我们在 debug 模式下将会看到一些信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"> </span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cpu_bound_work</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>):  <span class="comment"># CPU 密集型操作</span></span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    task_one = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    <span class="keyword">await</span> task_one</span><br><span class="line"> </span><br><span class="line">asyncio.run(main(), debug=<span class="literal">True</span>)  <span class="comment"># 调试模式</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Executing &lt;Task finished name='Task-2' coro=&lt;cpu_bound_work() done, defined at D:\project\autoexpense\aaaa.py:4&gt; result=100000000 created at C:\Users\hongji\.conda\envs\3.10\lib\asyncio\tasks.py:337&gt; took 3.984 seconds</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>默认时间超过 100ms 就会出现上述提示，我们可以更改这个提示的时间，例如将其改为 250 毫秒。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.slow_callback_duration = <span class="number">.250</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main(), debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h4 id="异步上下文"><a href="#异步上下文" class="headerlink" title="异步上下文"></a>异步上下文</h4><p>异步上下文管理器是实现两个特殊协程方法的类：<code>__aenter__</code>用于异步获取资源，<code>__aexit__</code>用于关闭该资源。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncContextManager</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aenter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"进入上下文管理器"</span>)</span><br><span class="line">        <span class="comment"># 在这里可以执行一些异步操作</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进入上下文管理器成功"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aexit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">        print(<span class="string">"离开上下文管理器"</span>)</span><br><span class="line">        <span class="comment"># 在这里可以执行一些异步操作</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">f"发生异常：<span class="subst">&#123;exc_type&#125;</span>, <span class="subst">&#123;exc_value&#125;</span>, <span class="subst">&#123;traceback&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"没有发生异常"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> result:</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -Iv aiohttp</span><br></pre></td></tr></table></figure>
<p>默认情况下ClientSession将创建最多100个连接</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_status</span><span class="params">(session: ClientSession, url: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> result:</span><br><span class="line">        <span class="keyword">return</span> result.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url = <span class="string">'https://www.example.com'</span></span><br><span class="line">        status = <span class="keyword">await</span> fetch_status(session, url)</span><br><span class="line">        print(<span class="string">f'Status for <span class="subst">&#123;url&#125;</span> was <span class="subst">&#123;status&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">开始执行函数 main 参数: () &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 fetch_status 参数: (&lt;aiohttp.client.ClientSession object at 0x7fbdd40e9e70&gt;, 'https://www.example.com') &#123;&#125;</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.9957 秒(s)</span></span><br><span class="line"><span class="string">Status for https://www.example.com was 200</span></span><br><span class="line"><span class="string">完成执行函数 main 花费 0.9963 秒(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><strong>设置超时时间</strong></p>
<p>超时时间可以在 session 会话上设置，也可以在每个 session 发起请求的时候设置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_status</span><span class="params">(session: ClientSession, url: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 覆盖main中的设置，设置总超时时间为10毫秒</span></span><br><span class="line">    ten_millis = aiohttp.ClientTimeout(total=<span class="number">.01</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, timeout=ten_millis) <span class="keyword">as</span> result:</span><br><span class="line">        <span class="keyword">return</span> result.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 总超时时间为1秒，100毫秒的连接超时时间</span></span><br><span class="line">    session_timeout = aiohttp.ClientTimeout(total=<span class="number">1</span>, connect=<span class="number">.1</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(timeout=session_timeout) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">await</span> fetch_status(session, <span class="string">'https://baidu.com'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="列表推导式下的并发"><a href="#列表推导式下的并发" class="headerlink" title="列表推导式下的并发"></a>列表推导式下的并发</h4><p><strong>❌不正确的做法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed, delay</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    delay_times = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">    [<span class="keyword">await</span> asyncio.create_task(delay(seconds)) <span class="keyword">for</span> seconds <span class="keyword">in</span> delay_times]</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>理想情况下希望任务并发运行，我们期望主方法大约在3秒内完成。然而，在这种情况下，由于所有事情都是依次完成的，需要花费9秒钟来运行。</p>
<p>这是因为我们在创建任务时就使用了 await。这意味着我们会暂停列表推导和主协程，直到我们创建的每个延迟任务完成。在这种情况下，我们每次只会运行一个任务，而不是同时运行多个任务。</p>
<p><strong>✅正确的做法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed, delay</span><br><span class="line"> </span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    delay_times = [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">    tasks = [asyncio.create_task(delay(seconds)) <span class="keyword">for</span> seconds <span class="keyword">in</span> delay_times]</span><br><span class="line">    [<span class="keyword">await</span> task <span class="keyword">for</span> task <span class="keyword">in</span> tasks]</span><br><span class="line"> </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>这种情况下 create_task会立即返回，直到所有任务都被创建后才会等待它们运行完成。</p>
<h4 id="gather"><a href="#gather" class="headerlink" title="gather"></a>gather</h4><p>上述列表推导式的写法存在一些问题：</p>
<ol>
<li>它由多行代码组成，我们必须明确地记住将任务创建与等待分开</li>
<li>不够灵活，如果我们的某个协程比其他协程早完成，我们将被困在第二个列表的运行中，等待所有其他协程完成。</li>
<li>最大的问题是异常处理。如果我们的某个协程有异常，如果将错误抛出，意味着我们将无法处理任何成功完成的任务，因为其中一个异常将停止我们的执行。</li>
</ol>
<p><strong>gather</strong> 函数接受一个 awaitable 序列，可以在一行代码中同时运行它们。如果我们传递的任何 awaitable 是一个协程，gather 将自动将其包装在任务中以确保其并发运行。这意味着我们不必像上面那样分别使用 asyncio.create_task 来进行包装。</p>
<p>asyncio.gather 返回一个可等待对象。当我们在 await 表达式中使用它时。它将暂停，直到我们传递给它的所有可等待对象都完成为止。一旦我们传递的所有对象都完成了，asyncio.gather 将返回已完成结果的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> fetch_status</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        urls = [<span class="string">'https://baidu.com'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">        requests = [fetch_status(session, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        status_codes = <span class="keyword">await</span> asyncio.gather(*requests)</span><br><span class="line">        print(status_codes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">完成执行函数 main 花费 6.2282 秒(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>gather的一个好处是，无论我们的可等待对象何时完成，我们都保证结果会按照我们传递它们的顺序返回</p>
<p>如果是采用同步的方式，如下所示，那将会很耗时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed, fetch_status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        urls = [<span class="string">'https://baidu.com'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">        status_codes = [<span class="keyword">await</span> fetch_status(session, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        print(status_codes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">完成执行函数 main 花费 60.4100 秒(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><strong>gather 中的异常</strong></p>
<p>asyncio.gather 给我们提供了一个可选参数 return_exceptions，是一个布尔值，它允许我们指定如何处理来自awaitable的异常。</p>
<ol>
<li>True:  gather 将会在我们 await 它时将任何异常作为结果列表的一部分返回。gather 的调用本身不会抛出任何异常，我们将能够根据自己的意愿处理所有异常。</li>
<li>False:  默认值。在这种情况下，如果我们的任一协程引发异常，当我们 await 它时，我们的 gather 调用也会抛出该异常。然而，即使其中一个协程失败了，我们的其他协程也不会被取消，只要我们处理异常或异常不会导致事件循环停止和取消任务，它们就会继续运行。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> fetch_status, async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        urls = [<span class="string">'python://example.com'</span>, <span class="string">'https://baidu.com'</span>]</span><br><span class="line">        tasks = [fetch_status(session, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        status_codes = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        print(status_codes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述代码会发生异常，但是能正确的请求百度。</p>
<p>当 return_exceptions 默认为 False 的时候存在一个问题，那就是如果发生多个异常，我们只能看到在等待gather时发生的第一个异常。我们可以通过使用 return_exceptions=True 来解决这个问题，这将返回我们在运行协程时遇到的所有异常。然后我们可以过滤掉任何异常并根据需要处理它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed, fetch_status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        urls = [<span class="string">'https://baidu.com'</span>, <span class="string">'python://example.com'</span>]</span><br><span class="line">        tasks = [fetch_status(session, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*tasks, return_exceptions=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历所有的结果，获取异常的结果</span></span><br><span class="line">        exceptions = [res <span class="keyword">for</span> res <span class="keyword">in</span> results <span class="keyword">if</span> isinstance(res, Exception)]</span><br><span class="line">        <span class="comment"># 遍历所有的结果，获取正常的结果</span></span><br><span class="line">        successful_results = [res <span class="keyword">for</span> res <span class="keyword">in</span> results <span class="keyword">if</span> <span class="keyword">not</span> isinstance(res, Exception)]</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f'All results: <span class="subst">&#123;results&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'Finished successfully: <span class="subst">&#123;successful_results&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'Threw exceptions: <span class="subst">&#123;exceptions&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">开始执行函数 main 参数: () &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 fetch_status 参数: (&lt;aiohttp.client.ClientSession object at 0x7f7fa1264220&gt;, 'https://baidu.com') &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 fetch_status 参数: (&lt;aiohttp.client.ClientSession object at 0x7f7fa1264220&gt;, 'python://example.com') &#123;&#125;</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.0003 秒(s)</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.2335 秒(s)</span></span><br><span class="line"><span class="string">All results: [200, AssertionError()]</span></span><br><span class="line"><span class="string">Finished successfully: [200]</span></span><br><span class="line"><span class="string">Threw exceptions: [AssertionError()]</span></span><br><span class="line"><span class="string">完成执行函数 main 花费 0.2343 秒(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h4 id="as-completed"><a href="#as-completed" class="headerlink" title="as_completed"></a>as_completed</h4><p><code>asyncio.gather()</code>存在一些缺点，即在允许访问任何结果之前，它会等待所有协程完成。如果我们想要在接收到结果后立即处理结果，这就是一个问题。如果我们有一些协程可能会很快完成，而另一些协程可能需要一些时间，因为<code>gather()</code>会等待所有任务完成。</p>
<p>asyncio 暴露了一个名为 as_completed 的API函数。这个方法接受一个可等待对象列表并返回一个 future 的迭代器。然后我们可以遍历这些 future，并等待结果返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(session: ClientSession, url: str, delay: int = <span class="number">0</span>)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> result:</span><br><span class="line">        <span class="keyword">return</span> result.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        fetchers = [</span><br><span class="line">            request(session, <span class="string">'https://baidu.com'</span>, <span class="number">1</span>),  <span class="comment"># 睡1s</span></span><br><span class="line">            request(session, <span class="string">'https://baidu.com'</span>, <span class="number">1</span>),  <span class="comment"># 睡1s</span></span><br><span class="line">            request(session, <span class="string">'https://baidu.com'</span>, <span class="number">3</span>)   <span class="comment"># 睡3s</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> finished_task <span class="keyword">in</span> asyncio.as_completed(fetchers):</span><br><span class="line">            print(<span class="keyword">await</span> finished_task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">开始执行函数 main 参数: () &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 request 参数: (&lt;aiohttp.client.ClientSession object at 0x7fd820268280&gt;, 'https://baidu.com', 1) &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 request 参数: (&lt;aiohttp.client.ClientSession object at 0x7fd820268280&gt;, 'https://baidu.com', 1) &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 request 参数: (&lt;aiohttp.client.ClientSession object at 0x7fd820268280&gt;, 'https://baidu.com', 3) &#123;&#125;</span></span><br><span class="line"><span class="string">完成执行函数 request 花费 1.2250 秒(s)</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">完成执行函数 request 花费 1.2322 秒(s)</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">完成执行函数 request 花费 3.0688 秒(s)</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">完成执行函数 main 花费 3.0698 秒(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，在背后，每个协程被包装在一个 task 中，并开始并发运行。该协程立即返回一个迭代器开始循环。当我们进入 for 循环时，我们碰到了 await finished_task。在这里我们暂停执行并等待我们的第一个结果。在这种情况下，我们的第一个结果在1秒钟后到达，并打印状态码。然后我们再次到达 await finished_task，由于我们的请求同时运行，我们应该几乎立即看到第二个结果。最后，我们的3秒钟的请求将完成，我们的循环将结束。</p>
<p>这个函数还可以更好地控制异常处理。当一个任务抛出异常时，我们可以在它发生时处理它，因为该异常在我们 awit feture 时抛出。</p>
<p><strong>as_completed 超时控制</strong></p>
<p>as_completed 函数通过提供一个可选的超时参数来支持此用例，我们可以指定一个以秒为单位的超时时间。这将跟踪 as_completed 调用所花费的时间；如果它花费的时间超过超时时间，那么迭代器中的每个 awaitable 在我们await 它时都会抛出一个TimeoutException。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(session: ClientSession, url: str, delay: int = <span class="number">0</span>)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> result:</span><br><span class="line">        <span class="keyword">return</span> result.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        fetchers = [</span><br><span class="line">            request(session, <span class="string">'https://baidu.com'</span>, <span class="number">1</span>),</span><br><span class="line">            request(session, <span class="string">'https://baidu.com'</span>, <span class="number">1</span>),</span><br><span class="line">            request(session, <span class="string">'https://baidu.com'</span>, <span class="number">5</span>)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置超时时间为 2s</span></span><br><span class="line">        <span class="keyword">for</span> done_task <span class="keyword">in</span> asyncio.as_completed(fetchers, timeout=<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = <span class="keyword">await</span> done_task</span><br><span class="line">                print(result)</span><br><span class="line">            <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">                print(<span class="string">'获取到一个超时错误!'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.tasks.all_tasks():</span><br><span class="line">            print(task)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">开始执行函数 main 参数: () &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 request 参数: (&lt;aiohttp.client.ClientSession object at 0x7faa57320610&gt;, 'https://baidu.com', 1) &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 request 参数: (&lt;aiohttp.client.ClientSession object at 0x7faa57320610&gt;, 'https://baidu.com', 5) &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 request 参数: (&lt;aiohttp.client.ClientSession object at 0x7faa57320610&gt;, 'https://baidu.com', 1) &#123;&#125;</span></span><br><span class="line"><span class="string">完成执行函数 request 花费 1.2148 秒(s)</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">完成执行函数 request 花费 1.2217 秒(s)</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">获取到一个超时错误!</span></span><br><span class="line"><span class="string">&lt;Task pending name='Task-3' coro=&lt;request() ...        # 一个请求仍在运行</span></span><br><span class="line"><span class="string">&lt;Task pending name='Task-1' coro=&lt;main() ...</span></span><br><span class="line"><span class="string">完成执行函数 main 花费 2.0010 秒(s)</span></span><br><span class="line"><span class="string">完成执行函数 request 花费 2.0010 秒(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，我们将看到一个超时错误。我们还将看到一个请求仍在运行。</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>as_completed 对于尽快获取结果而言效果很好，但有一些缺点。首先，顺序是完全不确定的，因此无法轻松查看我们正在等待的哪个协程或任务。如果我们不关心顺序，这可能是可以接受的。</p>
<p>第二个问题是，使用超时时，虽然我们会正确地抛出异常并继续执行，但任何创建的任务仍然会在后台运行。</p>
<p>wait 方法有几个选项可供选择，取决于我们想要何时获得结果。此外，此方法返回两个集合：一个已完成的任务集合（包含结果集或异常集），以及一个当前运行的任务集合。该函数还允许我们指定超时时间，其行为与其他API方法运行方式不同；它不会抛出异常。</p>
<p>wait 方法的基本签名是一个可等待项目列表，后跟可选的超时和可选的 return_when 字符串。该字符串有几个预定义的值：</p>
<ol>
<li><p>ALL_COMPLETED：默认值，将等待所有任务完成后才返回</p>
</li>
<li><p>FIRST_EXCEPTION：遇到第一个异常就返回</p>
</li>
<li><p>FIRST_COMPLETED：运行完第一个任务就返回</p>
</li>
</ol>
<p>在处理错误方面，我们可以将 await 放在 try except 块中来处理异常，或者我们可以使用 task.result() 和task.exception() 方法，来获取结果和异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> fetch_status, async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        good_request = fetch_status(session, <span class="string">'https://baidu.com'</span>)</span><br><span class="line">        bad_request = fetch_status(session, <span class="string">'python://bad'</span>)</span><br><span class="line"></span><br><span class="line">        fetchers = [</span><br><span class="line">            asyncio.create_task(good_request),</span><br><span class="line">            asyncio.create_task(bad_request)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 默认是所有任务完成才返回。还可以指定超时时间</span></span><br><span class="line">        done, pending = <span class="keyword">await</span> asyncio.wait(fetchers)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f'已完成的任务数量: <span class="subst">&#123;len(done)&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'阻塞的任务数量: <span class="subst">&#123;len(pending)&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> done_task <span class="keyword">in</span> done:</span><br><span class="line">            <span class="comment"># 判断 task 是否有异常</span></span><br><span class="line">            <span class="keyword">if</span> done_task.exception() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 获取 task 结果</span></span><br><span class="line">                print(done_task.result())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logging.error(<span class="string">"请求异常"</span>, exc_info=done_task.exception())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">开始执行函数 main 参数: () &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 fetch_status 参数: (&lt;aiohttp.client.ClientSession object at 0x7f8aa3c6c250&gt;, 'https://baidu.com') &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 fetch_status 参数: (&lt;aiohttp.client.ClientSession object at 0x7f8aa3c6c250&gt;, 'python://bad') &#123;&#125;</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.0003 秒(s)</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.2308 秒(s)</span></span><br><span class="line"><span class="string">已完成的任务数量: 2</span></span><br><span class="line"><span class="string">阻塞的任务数量: 0</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">完成执行函数 main 花费 0.2345 秒(s)</span></span><br><span class="line"><span class="string">ERROR:root:请求异常</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">  packages/aiohttp/connector.py", line 1144, in _create_direct_connection</span></span><br><span class="line"><span class="string">    assert port is not None</span></span><br><span class="line"><span class="string">AssertionError</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><strong>监听异常</strong></p>
<p>FIRST_EXCEPTION ，如果所有任务都没有发生异常，则此选项等同于ALL_COMPLETED，如果有任何任务抛出异常，wait 将立即返回一旦异常被抛出。done 集将包含任何成功完成的协程以及任何带有异常的协程。在这种情况下，done 集保证至少有一个失败的任务，但可能还有成功完成的任务。挂起的集合可能为空，但也可能有仍在运行的任务。</p>
<p>异常情况下取消正在运行的任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed, fetch_status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        fetchers = [</span><br><span class="line">            asyncio.create_task(fetch_status(session, <span class="string">'python://bad.com'</span>)),</span><br><span class="line">            asyncio.create_task(fetch_status(session, <span class="string">'https://www.baidu.com'</span>, delay=<span class="number">3</span>)),</span><br><span class="line">            asyncio.create_task(fetch_status(session, <span class="string">'https://www.baidu.com'</span>, delay=<span class="number">3</span>))</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        done, pending = <span class="keyword">await</span> asyncio.wait(fetchers, return_when=asyncio.FIRST_EXCEPTION)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f'已完成的任务数量: <span class="subst">&#123;len(done)&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'阻塞的任务数量: <span class="subst">&#123;len(pending)&#125;</span>'</span>)</span><br><span class="line">        <span class="keyword">for</span> done_task <span class="keyword">in</span> done:</span><br><span class="line">            <span class="keyword">if</span> done_task.exception() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                print(done_task.result())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logging.error(<span class="string">"请求异常"</span>, exc_info=done_task.exception())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取消正在运行的请求</span></span><br><span class="line">        <span class="keyword">for</span> pending_task <span class="keyword">in</span> pending:</span><br><span class="line">            print(<span class="string">f"取消任务: <span class="subst">&#123;pending_task&#125;</span>"</span>)</span><br><span class="line">            pending_task.cancel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p><strong>逐个处理结果</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed, fetch_status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url = <span class="string">'https://www.baidu.com'</span></span><br><span class="line">        pending = [</span><br><span class="line">            asyncio.create_task(fetch_status(session, url)),</span><br><span class="line">            asyncio.create_task(fetch_status(session, url)),</span><br><span class="line">            asyncio.create_task(fetch_status(session, url, delay=<span class="number">3</span>))</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pending:</span><br><span class="line">            done, pending = <span class="keyword">await</span> asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">f'完成任务数量: <span class="subst">&#123;len(done)&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">f'阻塞任务数量: <span class="subst">&#123;len(pending)&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> done_task <span class="keyword">in</span> done:</span><br><span class="line">                print(<span class="keyword">await</span> done_task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">完成任务数量: 1</span></span><br><span class="line"><span class="string">阻塞任务数量: 2</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.1010 秒(s)</span></span><br><span class="line"><span class="string">完成任务数量: 1</span></span><br><span class="line"><span class="string">阻塞任务数量: 1</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 3.0169 秒(s)</span></span><br><span class="line"><span class="string">完成任务数量: 1</span></span><br><span class="line"><span class="string">阻塞任务数量: 0</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码中使用 while 循环 pending，直到 pending 为空。然后再次更新完成的任务和阻塞中的任务。依次在 for 循环中循环已完成的任务，然后获取结果。</p>
<p><strong>超时处理</strong></p>
<p>wait 中的超时与我们迄今为止所看到的 wait_for 和 as_completed 不同：</p>
<ol>
<li>当我们使用 wait_for 时，如果我们的协程超时，它会自动请求取消。但 wait 并不是这种情况，它的行为更接近于我们在 gather 和 as_completed 中看到的方法。如果我们想由于超时而取消协程，我们必须显式地遍历这些任务并将它们取消。</li>
<li>wait 不像 wait_for 和 as_completed，wait 超时不会被引发错误。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed, fetch_status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url = <span class="string">'https://baidu.com'</span></span><br><span class="line">        fetchers = [</span><br><span class="line">            asyncio.create_task(fetch_status(session, url)),</span><br><span class="line">            asyncio.create_task(fetch_status(session, url)),</span><br><span class="line">            asyncio.create_task(fetch_status(session, url, delay=<span class="number">3</span>))</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        done, pending = <span class="keyword">await</span> asyncio.wait(fetchers, timeout=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f'Done task count: <span class="subst">&#123;len(done)&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'Pending task count: <span class="subst">&#123;len(pending)&#125;</span>'</span>)</span><br><span class="line">        <span class="keyword">for</span> done_task <span class="keyword">in</span> done:</span><br><span class="line">            result = <span class="keyword">await</span> done_task</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">开始执行函数 main 参数: () &#123;&#125;</span></span><br><span class="line"><span class="string">开始执行函数 fetch_status 参数: ...</span></span><br><span class="line"><span class="string">开始执行函数 fetch_status 参数: ...</span></span><br><span class="line"><span class="string">开始执行函数 fetch_status 参数: ...</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.2293 秒(s)</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.2010 秒(s)</span></span><br><span class="line"><span class="string">Done task count: 2</span></span><br><span class="line"><span class="string">Pending task count: 1</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">完成执行函数 main 花费 1.0023 秒(s)</span></span><br><span class="line"><span class="string">完成执行函数 fetch_status 花费 0.9705 秒(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>pending 待处理任务集中的任务并未被取消，并且尽管超时仍将继续运行。如果我们希望终止待处理任务，则需要显式遍历待处理集，并在每个任务上调用取消操作来手工取消。</p>
<p><strong>传递给 wait 和协程最好包装在 tasks 中</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> fetch_status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        api_a = fetch_status(session, <span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">        api_b = fetch_status(session, <span class="string">'https://www.baidu.com'</span>, delay=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        done, pending = <span class="keyword">await</span> asyncio.wait([api_a, api_b], timeout=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> pending:</span><br><span class="line">            <span class="keyword">if</span> task <span class="keyword">is</span> api_b:</span><br><span class="line">                <span class="comment"># 期待结果为取消 api_b，但是并没有执行</span></span><br><span class="line">                print(<span class="string">'API B too slow, cancelling'</span>)</span><br><span class="line">                task.cancel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>原因是在我们将协程传递给 wait 函数时，每个协程会被自动转换为 task（创建一个 新的 task 对象）。这样在进行 is 比较的时候就会是 false，所以没有得到期待的结果。所以推荐的做法是使用 asyncio.create_task 方法将其包一层。</p>
<h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p>全局解释器锁防止多个 Python 字节代码并行运行。这意味着对于除了 I/O 绑定任务以外的任何东西，大多数使用多线程并不会带来任何性能优势。</p>
<p>我们可以不使用父进程生成线程来并行处理任务，而是生成子进程来处理我们的工作。每个子进程都将有自己的Python解释器，并受到GIL的控制，但是我们将有多个解释器，每个解释器都有自己的GIL。这意味着我们可以有效地并行处理任何CPU密集型工作负载。即使我们的进程数多于核心数，我们的操作系统也将使用抢占式多任务处理，以允许我们的多个任务并发运行。</p>
<h4 id="多进程示例"><a href="#多进程示例" class="headerlink" title="多进程示例"></a>多进程示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(count_to: int)</span> -&gt; int:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; count_to:</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'Finished counting to <span class="subst">&#123;count_to&#125;</span> in <span class="subst">&#123;end - start&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    to_one_hundred_million = Process(target=count, args=(<span class="number">100000000</span>,))</span><br><span class="line">    to_two_hundred_million = Process(target=count, args=(<span class="number">200000000</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始这个进程。这个方法会立即返回</span></span><br><span class="line">    to_one_hundred_million.start()</span><br><span class="line">    to_two_hundred_million.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待进程完成。此方法会阻塞直到进程完成</span></span><br><span class="line">    to_one_hundred_million.join()</span><br><span class="line">    to_two_hundred_million.join()</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(<span class="string">f'Completed in <span class="subst">&#123;end_time - start_time&#125;</span>'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Finished counting to 100000000 in 4.116375923156738</span></span><br><span class="line"><span class="string">Finished counting to 200000000 in 8.063395977020264</span></span><br><span class="line"><span class="string">Completed in 8.145723104476929</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h4 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name: str)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Hi there, <span class="subst">&#123;name&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool() <span class="keyword">as</span> process_pool:</span><br><span class="line">        hi_jeff = process_pool.apply(say_hello, args=(<span class="string">'Jeff'</span>,))</span><br><span class="line">        hi_john = process_pool.apply(say_hello, args=(<span class="string">'John'</span>,))</span><br><span class="line">        print(hi_jeff)</span><br><span class="line">        print(hi_john)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Hi there, Jeff</span></span><br><span class="line"><span class="string">Hi there, John</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>我们使用<code>with Pool() as process_pool</code>创建了一个进程池。这是一个上下文管理器，因为一旦我们使用完池，我们需要适当地关闭创建的 Python 进程。</p>
<p>当我们实例化此池时，它将自动创建与您正在运行的计算机上的CPU内核数量相等的Python进程。您可以通过运行multiprocessing.cpu_count() 函数在Python中确定您拥有的CPU内核数</p>
<h4 id="异步运行"><a href="#异步运行" class="headerlink" title="异步运行"></a>异步运行</h4><p>apply 方法会阻塞，直到函数完成。这意味着，如果每次调用 say_hello 需要 10 秒钟，我们整个程序的运行时间将会约为 20 秒。</p>
<p>每次调用 apply 方法都会阻塞，直到我们的函数完成。如果我们想建立一个真正的并行工作流程，这是不可行的。为了解决这个问题，我们可以使用 apply_async 方法。这种方法会立即返回 AsyncResult，然后在后台开始运行进程。一旦我们有了 AsyncResult，我们就可以使用它的 get 方法来阻塞并获取函数调用的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name: str)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Hi there, <span class="subst">&#123;name&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool() <span class="keyword">as</span> process_pool:</span><br><span class="line">        hi_jeff = process_pool.apply_async(say_hello, args=(<span class="string">'Jeff'</span>,))</span><br><span class="line">        hi_john = process_pool.apply_async(say_hello, args=(<span class="string">'John'</span>,))</span><br><span class="line">        print(hi_jeff.get())</span><br><span class="line">        print(hi_john.get())</span><br></pre></td></tr></table></figure>
<p>当我们调用 apply_async 时，say_hello 的两个调用会立即在不同的进程中启动。然后，当我们调用 get 方法时，父进程将会阻塞，直到每个进程返回一个值。这使得方法可以并发运行。</p>
<h4 id="进程池执行器"><a href="#进程池执行器" class="headerlink" title="进程池执行器"></a>进程池执行器</h4><p>上面多进程程序中，如果 hi_jeff 运行了 10 秒，而 hi_john 只需 1 秒，该怎么办呢？因为 hi_jeff 先调用了 get，所以会阻塞一直等到完成后才会运行 hi_john。</p>
<p>还有一种需求是，如果我们需要轻松地更改并发处理方式，无缝地在进程和线程之间切换，该怎么办？</p>
<p>concurrent.futures 模块通过 Executor 抽象类为我们提供了这种抽象化。这个类定义了两种异步运行工作的方法。第一个是submit，它将接受一个可调用对象并返回一个Future（请注意，这不是 asyncio futures，而是concurrent.futures 模块的一部分）这相当于我们在上一节中看到的 Pool.apply_async 方法。第二个方法是map。此方法将接受可调用对象和函数参数列表，然后异步执行列表中的每个参数。它返回结果的迭代器，类似于asyncio.as_completed，即结果在完成后可用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(count_to: int)</span> -&gt; int:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; count_to:</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'Finished counting to <span class="subst">&#123;count_to&#125;</span> in <span class="subst">&#123;end - start&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> process_pool:</span><br><span class="line">        numbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">100000000</span>, <span class="number">5</span>, <span class="number">22</span>]</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> process_pool.map(count, numbers):</span><br><span class="line">            print(result)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Finished counting to 1 in 0.0</span></span><br><span class="line"><span class="string">Finished counting to 3 in 9.5367431640625e-07</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">Finished counting to 5 in 1.1920928955078125e-06</span></span><br><span class="line"><span class="string">Finished counting to 22 in 1.9073486328125e-06</span></span><br><span class="line"><span class="string">Finished counting to 100000000 in 4.075898885726929     // 被阻塞</span></span><br><span class="line"><span class="string">100000000</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">22</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>虽然看起来这与 asyncio.as_completed 的工作方式相同，但迭代的顺序是基于我们传递给数字列表的顺序确定的。这意味着，如果100000000是我们的第一个数字，我们就会被卡住等待该调用完成，然后才能打印出早先完成的其他结果。这意味着不像 asyncio.as_completed那样反应灵敏。</p>
<p>PoolExecutor 也可以使用 submit 的方式提交获得一个 future，然后使用 as_as_completed 的方式获取结果。并且这样的方式当前面的任务太耗时时，后面的任务并不会被阻塞。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, as_completed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(count_to: int)</span> -&gt; int:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; count_to:</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'Finished counting to <span class="subst">&#123;count_to&#125;</span> in <span class="subst">&#123;end - start&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> process_pool:</span><br><span class="line">        todo_map = &#123;&#125;</span><br><span class="line">        todo_list = []</span><br><span class="line">        numbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">100000000</span>, <span class="number">5</span>, <span class="number">22</span>]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="comment"># 返回一个 Future 实例</span></span><br><span class="line">            future = process_pool.submit(count, x)</span><br><span class="line">            todo_list.append(future)</span><br><span class="line">            <span class="comment"># todo_map[future] = x</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># as_completed 返回一个迭代器，每个任务结束后产出 future 对象</span></span><br><span class="line">        result = as_completed(todo_list)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> result:</span><br><span class="line">            print(x.result())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Finished counting to 1 in 1.1920928955078125e-06</span></span><br><span class="line"><span class="string">Finished counting to 3 in 1.1920928955078125e-06</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">Finished counting to 5 in 0.0</span></span><br><span class="line"><span class="string">Finished counting to 22 in 1.9073486328125e-06         // 没有被阻塞</span></span><br><span class="line"><span class="string">5 </span></span><br><span class="line"><span class="string">22</span></span><br><span class="line"><span class="string">Finished counting to 100000000 in 4.001918077468872</span></span><br><span class="line"><span class="string">100000000</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h4 id="异步事件循环结合执行器"><a href="#异步事件循环结合执行器" class="headerlink" title="异步事件循环结合执行器"></a>异步事件循环结合执行器</h4><p>⚠️这种方法适用于进程池和线程池</p>
<p>我们可以使用 run_in_executor 方法，这个方法将接受一个可调用对象和一个执行器（可以是线程池或进程池），并将在池内运行这个可调用对象。它然后返回一个可等待对象，我们可以在await语句中使用它，或将其传递给API函数，如gather。</p>
<p>run_in_executor 函数只接受一个可调用函数，不接受参数，所以我们可能会用到偏函数 functools.partial。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> AbstractEventLoop</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(count_to: int)</span> -&gt; int:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; count_to:</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'Finished counting to <span class="subst">&#123;count_to&#125;</span> in <span class="subst">&#123;end - start&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> process_pool:</span><br><span class="line">        loop: AbstractEventLoop = asyncio.get_running_loop()</span><br><span class="line">        nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">100000000</span>]</span><br><span class="line">        calls: List[partial[int]] = [partial(count, num) <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        call_coros = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> call <span class="keyword">in</span> calls:</span><br><span class="line">            call_coros.append(loop.run_in_executor(process_pool, call))</span><br><span class="line">				</span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*call_coros)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述代码我们也可以使用 asyncio.as_completed 从子进程中获取结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> AbstractEventLoop</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(count_to: int)</span> -&gt; int:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; count_to:</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'Finished counting to <span class="subst">&#123;count_to&#125;</span> in <span class="subst">&#123;end - start&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> process_pool:</span><br><span class="line">        loop: AbstractEventLoop = asyncio.get_running_loop()</span><br><span class="line">        nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">100000000</span>]</span><br><span class="line">        calls: List[partial[int]] = [partial(count, num) <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        call_coros = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> call <span class="keyword">in</span> calls:</span><br><span class="line">            call_coros.append(loop.run_in_executor(process_pool, call))</span><br><span class="line">				</span><br><span class="line">        <span class="comment"># 不用等待所有任务完成，完成了则输出结果</span></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> asyncio.as_completed(call_coros):</span><br><span class="line">            print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="多进程锁"><a href="#多进程锁" class="headerlink" title="多进程锁"></a>多进程锁</h4><p>加锁，我们可以调用get_lock().acquire()方法， 释放锁，我们调用get_lock().release()方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_value</span><span class="params">(shared_int: Value)</span>:</span></span><br><span class="line">    <span class="comment"># 获取锁</span></span><br><span class="line">    shared_int.get_lock().acquire()</span><br><span class="line">    shared_int.value = shared_int.value + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 释放锁</span></span><br><span class="line">    shared_int.get_lock().release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># 需要注意这里的待加锁对象需要使用 multiprocessing 模块中的 Value 进行包装</span></span><br><span class="line">        integer = Value(<span class="string">'i'</span>, <span class="number">0</span>)</span><br><span class="line">        procs = [</span><br><span class="line">            Process(target=increment_value, args=(integer,)),</span><br><span class="line">            Process(target=increment_value, args=(integer,))</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        [p.start() <span class="keyword">for</span> p <span class="keyword">in</span> procs]</span><br><span class="line">        [p.join() <span class="keyword">for</span> p <span class="keyword">in</span> procs]</span><br><span class="line">        print(integer.value)</span><br><span class="line">        <span class="keyword">assert</span> (integer.value == <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>我们也可以使用 with 上下文管理器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_value</span><span class="params">(shared_int: Value)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> shared_int.get_lock():</span><br><span class="line">        shared_int.value = shared_int.value + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>共享数据在定义上是在工作进程之间共享的。因此，如果我们像以前一样尝试将共享数据作为函数的参数传递，则会出现“无法对Value对象进行封装”的错误。</p>
<p>为了处理这个问题，我们需要把我们的共享计数器放在全局变量中，并且以某种方式让我们的工作进程知道它。我们可以使用进程池 initializer 来实现这一点。</p>
<p><strong>初始化进程池来实现共享数据</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Value</span><br><span class="line"></span><br><span class="line">shared_counter: Value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(counter: Value)</span>:</span></span><br><span class="line">    <span class="comment"># 声明为全局变量，并且将值设置为 multiprocessing 中的 Value 类型</span></span><br><span class="line">    <span class="keyword">global</span> shared_counter</span><br><span class="line">    shared_counter = counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 从全局变量去获取锁</span></span><br><span class="line">    <span class="keyword">with</span> shared_counter.get_lock():</span><br><span class="line">        shared_counter.value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    counter = Value(<span class="string">'d'</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 进程池执行器支持传入初始化函数和初始化函数的参数</span></span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(initializer=init, initargs=(counter,)) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">await</span> asyncio.get_running_loop().run_in_executor(pool, increment)</span><br><span class="line">        print(counter.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述代码会让进程池针对每个进程，都使用参数 counter 来执行函数 init 函数。</p>
<h4 id="运行既包含CPU密集和IO密集的任务"><a href="#运行既包含CPU密集和IO密集的任务" class="headerlink" title="运行既包含CPU密集和IO密集的任务"></a>运行既包含CPU密集和IO密集的任务</h4><blockquote>
<p>使用多进程，每个进程都有自己的线程和Python解释器。虽然多进程主要用于 CPU 密集型任务，但对于 I/O 密集型工作负载也可以有益。</p>
</blockquote>
<p>上面代码中，我们现在知道如何在异步编程中使用多进程来提高 CPU 密集型任务的性能。如果我们有一项既包含CPU 密集型工作又包含 I/O 密集型操作的工作负载会怎样呢？</p>
<p>答案是为每个进程创建一个事件循环来使用多进程来扩展 asyncio 的功能。这有潜力改善既有 CPU 密集型又有 I/O 密集型工作负载的性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> asyncpg</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Dict</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.process <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询 SQL</span></span><br><span class="line">product_query = \</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">SELECT *</span></span><br><span class="line"><span class="string">FROM product as p</span></span><br><span class="line"><span class="string">JOIN sku as s on s.product_id = p.product_id</span></span><br><span class="line"><span class="string">JOIN product_color as pc on pc.product_color_id = s.product_color_id</span></span><br><span class="line"><span class="string">JOIN product_size as ps on ps.product_size_id = s.product_size_id</span></span><br><span class="line"><span class="string">WHERE p.product_id = 100</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询方法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">query_product</span><span class="params">(pool)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> pool.acquire() <span class="keyword">as</span> connection:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> connection.fetchrow(product_query)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">query_products_concurrently</span><span class="params">(pool, queries)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    并发查询</span></span><br><span class="line"><span class="string">    :param pool: 连接池</span></span><br><span class="line"><span class="string">    :param queries: 并发次数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queries = [query_product(pool) <span class="keyword">for</span> _ <span class="keyword">in</span> range(queries)]</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*queries)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_in_new_loop</span><span class="params">(num_queries: int)</span> -&gt; List[Dict]:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    新的事件循环</span></span><br><span class="line"><span class="string">    :param num_queries: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_queries</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> asyncpg.create_pool(</span><br><span class="line">                host=<span class="string">'127.0.0.1'</span>,</span><br><span class="line">                port=<span class="number">5432</span>,</span><br><span class="line">                user=<span class="string">'postgres'</span>,</span><br><span class="line">                password=<span class="string">'password'</span>,</span><br><span class="line">                database=<span class="string">'products'</span>,</span><br><span class="line">                min_size=<span class="number">6</span>,</span><br><span class="line">                max_size=<span class="number">6</span>) <span class="keyword">as</span> pool:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> query_products_concurrently(pool, num_queries)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在一个新的事件循环中运行查询</span></span><br><span class="line">    results = [dict(result) <span class="keyword">for</span> result <span class="keyword">in</span> asyncio.run(run_queries())]</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    pool = ProcessPoolExecutor()</span><br><span class="line">    <span class="comment"># 创造五个各自拥有事件循环的进程。</span></span><br><span class="line">    tasks = [loop.run_in_executor(pool, run_in_new_loop, <span class="number">10000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">    <span class="comment"># 等待所有查询结果查询完成</span></span><br><span class="line">    all_results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    total_queries = sum([len(result) <span class="keyword">for</span> result <span class="keyword">in</span> all_results])</span><br><span class="line">    print(<span class="string">f'Retrieved <span class="subst">&#123;total_queries&#125;</span> products the product database.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述代码，将同时启动50,000个查询，每个进程10,000个查询。这大大的提高了查询的效率。</p>
<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><blockquote>
<p>内部默认线程数的公式为 min（32，os.cpu_count（）+ 4）。这将导致工作线程的最大（上限）边界为 32，最小（下限）边界为 5。这是默认分配的，如果不手工指定的话。</p>
</blockquote>
<h4 id="使用线程池执行-Request"><a href="#使用线程池执行-Request" class="headerlink" title="使用线程池执行 Request"></a>使用线程池执行 Request</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_status_code</span><span class="params">(url: str)</span> -&gt; int:</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> response.status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    urls = [<span class="string">'https://www.baidu.com'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">    results = pool.map(get_status_code, urls)</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'finished requests in <span class="subst">&#123;end - start:<span class="number">.4</span>f&#125;</span> second(s)'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">finished requests in 68.5113 second(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，哪怕使用 <code>with ThreadPoolExecutor(max_workers=1000) as pool</code> 来增加线程的数量，效果还是不能和协程相对比，因为线程的创建需要一定的开销。</p>
<h4 id="使用线程池执行器与asyncio"><a href="#使用线程池执行器与asyncio" class="headerlink" title="使用线程池执行器与asyncio"></a>使用线程池执行器与asyncio</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_status_code</span><span class="params">(url: str)</span> -&gt; int:</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> response.status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        urls = [<span class="string">'https://www.baidu.com'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">        tasks = [loop.run_in_executor(pool, functools.partial(get_status_code, url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        print(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>与不使用 asyncio 的线程池相比，此方法不会产生任何性能优势，但是在等待 await asyncio.gather 完成时，其他代码有机会可以运行。</p>
<h4 id="默认执行器"><a href="#默认执行器" class="headerlink" title="默认执行器"></a>默认执行器</h4><p> run_in_executor 方法的 executor 参数可以为 None。在这种情况下，run_in_executor 将使用事件循环的默认执行程序。除非我们使用 loop.set_default_executor 方法设置自定义执行程序，否则默认执行程序将始终默认为ThreadPoolExecutor。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_status_code</span><span class="params">(url: str)</span> -&gt; int:</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> response.status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    urls = [<span class="string">'https://www.baidu.com'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">    <span class="comment"># 使用默认值执行器 ThreadPoolExecutor</span></span><br><span class="line">    tasks = [loop.run_in_executor(<span class="literal">None</span>, functools.partial(get_status_code, url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>上述代码还可以更近一步的简写，使用 to_thread 协程可以消除使用 functools.partial 和 asyncio.get_running_loop 的调用，从而减少我们的总代码行数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_status_code</span><span class="params">(url: str)</span> -&gt; int:</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> response.status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    urls = [<span class="string">'https://www.baidu.com'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">    <span class="comment"># 使用 to_thread 协程可以消除使用 functools.partial 和 asyncio.get_running_loop 的调用</span></span><br><span class="line">    tasks = [asyncio.to_thread(get_status_code, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>在使用多进程时，创建的进程默认不共享内存。这意味着我们需要创建特殊的共享内存对象，并正确初始化它们，以便每个进程都可以从该对象读取并向其写入。由于线程可以访问其父进程的相同内存，因此我们不再需要这样做，线程可以直接访问共享变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line">counter_lock = Lock()</span><br><span class="line">counter: int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_status_code</span><span class="params">(url: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="comment"># 上锁</span></span><br><span class="line">    <span class="keyword">with</span> counter_lock:</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> response.status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">reporter</span><span class="params">(request_count: int)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; request_count:</span><br><span class="line">        print(<span class="string">f'Finished <span class="subst">&#123;counter&#125;</span>/<span class="subst">&#123;request_count&#125;</span> requests'</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        request_count = <span class="number">50</span></span><br><span class="line">        urls = [<span class="string">'https://www.baidu.com'</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(request_count)]</span><br><span class="line">        <span class="comment"># 专门输出调用进度的 task</span></span><br><span class="line">        reporter_task = asyncio.create_task(reporter(request_count))</span><br><span class="line">        <span class="comment"># 执行请求调用的 task</span></span><br><span class="line">        tasks = [loop.run_in_executor(pool, functools.partial(get_status_code, url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">        <span class="keyword">await</span> reporter_task</span><br><span class="line">        print(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">开始执行函数 main 参数: () &#123;&#125;</span></span><br><span class="line"><span class="string">Finished 0/50 requests</span></span><br><span class="line"><span class="string">Finished 0/50 requests</span></span><br><span class="line"><span class="string">Finished 16/50 requests</span></span><br><span class="line"><span class="string">Finished 32/50 requests</span></span><br><span class="line"><span class="string">Finished 49/50 requests</span></span><br><span class="line"><span class="string">[200, 200, 200, 200, 200, ... , 200]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h4 id="可重入线程锁"><a href="#可重入线程锁" class="headerlink" title="可重入线程锁"></a>可重入线程锁</h4><p>可重入锁是一种特殊的锁，它可以被同一线程多次获取，允许该线程“重新进入”临界区。线程模块提供了RLock类中的可重入锁。可重入锁通过保持递归计数来工作。每当我们从首次获取锁的线程那里获取锁时，计数增加，每当我们释放锁时，计数减少。当计数为0时，锁最终释放以供其他线程获取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Rlock</span><br><span class="line"> </span><br><span class="line">list_lock = RLock()</span><br></pre></td></tr></table></figure>
<h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>call_soon_threadsafe。该函数接受一个 Python 函数（而不是协程）并在下一次 asyncio 事件循环的迭代中以线程安全的方式将其安排为可执行。第二个函数是 asyncio.run_coroutine_threadsafe。该函数接受一个协程并以线程安全的方式提交它，立即返回一个 future，我们可以使用它来访问协程的结果。重要的是，并令人困惑的是，这个未来不是 asyncio 未来，而是来自 concurrent.futures模块。背后的逻辑是，asyncio future不是线程安全的，但是 concurrent.futures future 是线程安全的。但是，这个未来类具有与 asyncio 模块的未来相同的功能。</p>
<h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><p>ASGI 有一些实现可供选择，但我们将使用一种流行的实现，称为 <a href="https://www.uvicorn.org/" target="_blank" rel="noopener">Uvicorn</a>。Uvicorn 建立在 uvloop 和 httptools 之上，它们是 asyncio 事件循环的快速 C 实现。</p>
<p>但最好的做法是与<a href="https://www.uvicorn.org/deployment/#gunicorn" target="_blank" rel="noopener">Gunicorn一起使用Uvicorn</a>，因为Gunicorn会有逻辑，在崩溃时重启工作程序。</p>
<p>Starlette是由Encode创建的小型ASGI兼容框架，也是Uvicorn和Django REST framework等其他流行库的创造者。它提供相当不错的性能。</p>
<h4 id="使用-Gunicorn-部署-ASGI-应用"><a href="#使用-Gunicorn-部署-ASGI-应用" class="headerlink" title="使用 Gunicorn 部署 ASGI 应用"></a>使用 Gunicorn 部署 ASGI 应用</h4><p>使用 Gunicorn 部署 ASGI 应用会发生什么？当我们使用 Gunicorn 部署 ASGI 应用时，应用能正常运行，但每次都会创建一个新的事件循环。</p>
<h3 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h3><h4 id="asyncio-锁"><a href="#asyncio-锁" class="headerlink" title="asyncio 锁"></a>asyncio 锁</h4><p>在使用 await 的时候，会等待执行，这时如果有其他协程将数据修改了，那么会发生意想不到的情况。</p>
<p>asyncio锁的操作类似于 multiprocessing 和 multithreading模块中的锁。我们获取一个锁，在关键部分内执行工作，执行完后释放锁，让其他 task 获取它。主要的区别在于，asyncio 锁是可等待的对象，在被阻塞时挂起协程执行。这意味着当一个协程被阻塞等待获取锁时，其他代码可以运行。此外，asyncio锁也是异步上下文管理器，推荐使用async with语法来使用它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(lock: Lock)</span>:</span></span><br><span class="line">    print(<span class="string">'等待 a 获取锁'</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> lock:</span><br><span class="line">        print(<span class="string">'a 获取到了锁'</span>)</span><br><span class="line">        <span class="keyword">await</span> delay(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'a 释放了锁'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(lock: Lock)</span>:</span></span><br><span class="line">    print(<span class="string">'等待 b 获取锁'</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> lock:</span><br><span class="line">        print(<span class="string">'b 获取到了锁'</span>)</span><br><span class="line">        <span class="keyword">await</span> delay(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'b 释放了锁'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(a(lock), b(lock))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">等待 a 获取锁</span></span><br><span class="line"><span class="string">a 获取到了锁</span></span><br><span class="line"><span class="string">sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">等待 b 获取锁</span></span><br><span class="line"><span class="string">finished sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">a 释放了锁</span></span><br><span class="line"><span class="string">b 获取到了锁</span></span><br><span class="line"><span class="string">sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">finished sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">b 释放了锁</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>由于 asyncio 的单线程特性，您很可能不经常需要在 asyncio 代码中使用锁，因为它可以避免许多并发问题。即使出现竞争条件，有时您也可以重构代码，使状态在协程被挂起时不被修改（例如使用不可变对象）。当您无法以这种方式进行重构时，这时候就考虑使用 asyncio 锁。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Semaphore</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(semaphore: Semaphore)</span>:</span></span><br><span class="line">    print(<span class="string">'等待获取信号量...'</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        print(<span class="string">'获取到信号量!'</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'释放信号量!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    semaphore = Semaphore(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*[operation(semaphore) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">等待获取信号量...</span></span><br><span class="line"><span class="string">获取到信号量!</span></span><br><span class="line"><span class="string">等待获取信号量...</span></span><br><span class="line"><span class="string">获取到信号量!</span></span><br><span class="line"><span class="string">等待获取信号量...</span></span><br><span class="line"><span class="string">等待获取信号量...</span></span><br><span class="line"><span class="string">释放信号量!</span></span><br><span class="line"><span class="string">释放信号量!</span></span><br><span class="line"><span class="string">获取到信号量!</span></span><br><span class="line"><span class="string">获取到信号量!</span></span><br><span class="line"><span class="string">释放信号量!</span></span><br><span class="line"><span class="string">释放信号量!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>在我们的主协程中，我们创建了一个信号量，并将其数量限制为2，表示我们可以在阻塞之前进行两次获取，获取之后直到释放之前，其余的两个协程都处于等待获取状态。</p>
<p>例如我们可以使用信号量，来限制 API 请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Semaphore</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url: str, session: ClientSession, semaphore: Semaphore)</span>:</span></span><br><span class="line">    print(<span class="string">'等待获取信号量...'</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        print(<span class="string">'获取到信号量，请求中...'</span>)</span><br><span class="line">        response = <span class="keyword">await</span> session.get(url)</span><br><span class="line">        print(<span class="string">'请求完成'</span>)</span><br><span class="line">        <span class="keyword">return</span> response.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    semaphore = Semaphore(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = [get_url(<span class="string">'https://www.baidu.com'</span>, session, semaphore) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p><strong>有界信号量</strong></p>
<p>asyncio 提供了 BoundedSemaphore。该信号量的行为与我们一直使用的信号量完全相同，其关键区别在于，如果我们调用 release 释放超过了信号量的数量，则会抛出 ValueError: BoundedSemaphore released too many times 异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> BoundedSemaphore</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    semaphore = BoundedSemaphore(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> semaphore.acquire()</span><br><span class="line">    semaphore.release()</span><br><span class="line">    semaphore.release()  <span class="comment"># 信号量个数和 release 不一致</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>Event类会跟踪一个标志，指示事件是否已经发生。我们可以使用set和clear两种方法来控制此标志。set方法将此内部标志设置为True，并通知任何正在等待的人事件已经发生。clear方法将此内部标志设置为False，并导致任何等待事件的人现在被阻止。</p>
<p>Event 类有一个协程方法叫做 wait。当我们await这个协程时，它会阻塞直到有人在事件对象上调用 set。一旦发生这种情况，任何调用 wait 的额外调用都不会阻塞，并且会立即返回。如果我们在调用 set 后调用 clear，那么再次调用 wait 将开始阻塞，直到再次调用 set。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trigger_event</span><span class="params">(event: Event)</span>:</span></span><br><span class="line">    event.set()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_work_on_event</span><span class="params">(event: Event)</span>:</span></span><br><span class="line">    print(<span class="string">'等待 event...'</span>)</span><br><span class="line">    <span class="keyword">await</span> event.wait()</span><br><span class="line">    print(<span class="string">'开始工作!'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'完成工作!'</span>)</span><br><span class="line">    event.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    event = asyncio.Event()</span><br><span class="line">    <span class="comment"># 5s 后触发 trigger_event，调用 event set</span></span><br><span class="line">    asyncio.get_running_loop().call_later(<span class="number">5.0</span>, functools.partial(trigger_event, event))</span><br><span class="line">    <span class="comment"># 使用 event 来控制执行</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(do_work_on_event(event), do_work_on_event(event))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">等待 event...</span></span><br><span class="line"><span class="string">等待 event...</span></span><br><span class="line"><span class="string">开始工作!</span></span><br><span class="line"><span class="string">开始工作!</span></span><br><span class="line"><span class="string">完成工作!</span></span><br><span class="line"><span class="string">完成工作!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码中 <code>await event.wait()</code> 将等待 <code>event.set()</code> 的执行，一旦执行后，所有阻塞在这里的协程都会继续执行。</p>
<h4 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Condition</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_work</span><span class="params">(condition: Condition, name: str)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> condition:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;name&#125;</span> 等待 notify_all ...'</span>)</span><br><span class="line">            <span class="keyword">await</span> condition.wait()</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;name&#125;</span> 监听到 notify_all 事件...'</span>)</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;name&#125;</span> 工作结束，释放锁.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fire_event</span><span class="params">(condition: Condition)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> condition:</span><br><span class="line">            print(<span class="string">'fire_event，即将通知所有开始工作.'</span>)</span><br><span class="line">            condition.notify_all()</span><br><span class="line">        print(<span class="string">'fire_event 通知工作结束.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    condition = Condition()</span><br><span class="line"></span><br><span class="line">    asyncio.create_task(fire_event(condition))</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(do_work(condition, <span class="string">"work1"</span>), do_work(condition, <span class="string">"work2"</span>))</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">work1 等待 notify_all ...</span></span><br><span class="line"><span class="string">work2 等待 notify_all ...</span></span><br><span class="line"><span class="string">fire_event，即将通知所有开始工作.</span></span><br><span class="line"><span class="string">fire_event 通知工作结束.</span></span><br><span class="line"><span class="string">work1 监听到 notify_all 事件...</span></span><br><span class="line"><span class="string">work1 工作结束，释放锁.</span></span><br><span class="line"><span class="string">work2 监听到 notify_all 事件...</span></span><br><span class="line"><span class="string">work2 工作结束，释放锁.</span></span><br><span class="line"><span class="string">work1 等待 notify_all ...</span></span><br><span class="line"><span class="string">work2 等待 notify_all ...</span></span><br><span class="line"><span class="string">fire_event，即将通知所有开始工作.</span></span><br><span class="line"><span class="string">fire_event 通知工作结束.</span></span><br><span class="line"><span class="string">work1 监听到 notify_all 事件...</span></span><br><span class="line"><span class="string">work1 工作结束，释放锁.</span></span><br><span class="line"><span class="string">work2 监听到 notify_all 事件...</span></span><br><span class="line"><span class="string">work2 工作结束，释放锁.</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，我们创建了两个协程方法：do_work 和 fire_event。do_work 方法获取 condition，类似于获取锁，并调用 condition 的 wait 协程方法。wait 协程方法将一直阻塞，直到有人调用该条件的 notify_all方法。</p>
<p>fire_event 协程方法会睡眠 5s，然后获取 condition 并调用 notify_all 方法，唤醒当前正在等待 condition 的任何任务。</p>
<p>主协程中，创建一个 fire_event 任务和两个 do_work 任务并同时运行。</p>
<h3 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, checkout_time: float)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.checkout_time = checkout_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer_id: int, products: List[Product])</span>:</span></span><br><span class="line">        self.customer_id = customer_id</span><br><span class="line">        self.products = products</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">checkout_customer</span><span class="params">(queue: Queue, cashier_number: int)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        <span class="comment"># 队列中有顾客</span></span><br><span class="line">        customer: Customer = queue.get_nowait()</span><br><span class="line">        print(<span class="string">f'收营员 <span class="subst">&#123;cashier_number&#125;</span> '</span> <span class="string">f'结账客户 '</span> <span class="string">f'<span class="subst">&#123;customer.customer_id&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> product <span class="keyword">in</span> customer.products:</span><br><span class="line">            <span class="comment"># 检查每位顾客的商品</span></span><br><span class="line">            print(<span class="string">f"收营员 <span class="subst">&#123;cashier_number&#125;</span> "</span> <span class="string">f"正在给"</span> <span class="string">f"<span class="subst">&#123;customer.customer_id&#125;</span>'s 结算 <span class="subst">&#123;product.name&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(product.checkout_time)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f'收营员 <span class="subst">&#123;cashier_number&#125;</span> '</span> <span class="string">f'完成对'</span> <span class="string">f'<span class="subst">&#123;customer.customer_id&#125;</span> 的结算'</span>)</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    customer_queue = Queue()</span><br><span class="line"></span><br><span class="line">    all_products = [</span><br><span class="line">        Product(<span class="string">'beer'</span>, <span class="number">2</span>),</span><br><span class="line">        Product(<span class="string">'bananas'</span>, <span class="number">.5</span>),</span><br><span class="line">        Product(<span class="string">'sausage'</span>, <span class="number">.2</span>),</span><br><span class="line">        Product(<span class="string">'diapers'</span>, <span class="number">.2</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机创建10位顾客及产品</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        products = [all_products[randrange(len(all_products))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(randrange(<span class="number">10</span>))]</span><br><span class="line">        customer_queue.put_nowait(Customer(i, products))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建三个收银员来结账</span></span><br><span class="line">    cashiers = [asyncio.create_task(checkout_customer(customer_queue, i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">    <span class="comment"># join 协程将阻塞，直到队列为空并且所有顾客都已结账。</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(customer_queue.join(), *cashiers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>从队列中获取和设置元素有两种方式，阻塞[put(), get()]和非阻塞[get_nowait(), put_nowait()]。</p>
<p>上述代码中，队列不为空，所以使用 get_nowait 方法不会发生异常，但是顾客并不是一直存在的。所以当队列中顾客为空时，使用 get_nowait 就会发生错误。解决这个问题的方法就是使用阻塞的 put 和 get 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, checkout_time: float)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.checkout_time = checkout_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer_id, products)</span>:</span></span><br><span class="line">        self.customer_id = customer_id</span><br><span class="line">        self.products = products</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">checkout_customer</span><span class="params">(queue: Queue, cashier_number: int)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        customer: Customer = <span class="keyword">await</span> queue.get()</span><br><span class="line">        print(<span class="string">f'收营员 <span class="subst">&#123;cashier_number&#125;</span> '</span> <span class="string">f'结账客户 '</span> <span class="string">f'<span class="subst">&#123;customer.customer_id&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> product <span class="keyword">in</span> customer.products:</span><br><span class="line">            print(<span class="string">f"收营员 <span class="subst">&#123;cashier_number&#125;</span> "</span> <span class="string">f"正在给"</span> <span class="string">f"<span class="subst">&#123;customer.customer_id&#125;</span>'s 结算 <span class="subst">&#123;product.name&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(product.checkout_time)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f'收营员 <span class="subst">&#123;cashier_number&#125;</span> '</span> <span class="string">f'完成对'</span> <span class="string">f'<span class="subst">&#123;customer.customer_id&#125;</span> 的结算'</span>)</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个随机的客户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_customer</span><span class="params">(customer_id: int)</span> -&gt; Customer:</span></span><br><span class="line">    all_products = [</span><br><span class="line">        Product(<span class="string">'beer'</span>, <span class="number">2</span>),</span><br><span class="line">        Product(<span class="string">'bananas'</span>, <span class="number">.5</span>),</span><br><span class="line">        Product(<span class="string">'sausage'</span>, <span class="number">.2</span>),</span><br><span class="line">        Product(<span class="string">'diapers'</span>, <span class="number">.2</span>)</span><br><span class="line">    ]</span><br><span class="line">    products = [all_products[randrange(len(all_products))] <span class="keyword">for</span> _ <span class="keyword">in</span> range(randrange(<span class="number">10</span>))]</span><br><span class="line">    <span class="keyword">return</span> Customer(customer_id, products)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没秒随机生成几个顾客</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">customer_generator</span><span class="params">(queue: Queue)</span>:</span></span><br><span class="line">    customer_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        customers = [generate_customer(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(customer_count, customer_count + randrange(<span class="number">5</span>))]</span><br><span class="line">        <span class="keyword">for</span> customer <span class="keyword">in</span> customers:</span><br><span class="line">            print(<span class="string">'客户正在等待排队...'</span>)</span><br><span class="line">            <span class="keyword">await</span> queue.put(customer)</span><br><span class="line">            print(<span class="string">'客户已加入排队!'</span>)</span><br><span class="line">        customer_count = customer_count + len(customers)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 限制每个队列的大小</span></span><br><span class="line">    customer_queue = Queue(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    customer_producer = asyncio.create_task(customer_generator(customer_queue))</span><br><span class="line"></span><br><span class="line">    cashiers = [asyncio.create_task(checkout_customer(customer_queue, i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(customer_producer, *cashiers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue, PriorityQueue</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Tuple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(queue: Queue)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        work_item: Tuple[int, str] = <span class="keyword">await</span> queue.get()</span><br><span class="line">        print(<span class="string">f'Processing work item <span class="subst">&#123;work_item&#125;</span>'</span>)</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    priority_queue = PriorityQueue()</span><br><span class="line">    work_items = [</span><br><span class="line">        (<span class="number">3</span>, <span class="string">'Lowest priority'</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">'Medium priority'</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">'High priority'</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    worker_task = asyncio.create_task(worker(priority_queue))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> work <span class="keyword">in</span> work_items:</span><br><span class="line">        priority_queue.put_nowait(work)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(priority_queue.join(), worker_task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Processing work item (1, 'High priority')</span></span><br><span class="line"><span class="string">Processing work item (2, 'Medium priority')</span></span><br><span class="line"><span class="string">Processing work item (3, 'Lowest priority')</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，work_items 第一个元素是表示优先级的整数，第二个元素是任何任务数据。默认队列实现查看元组的第一个值以确定优先级，最小的数字优先级最高。</p>
<p><strong>自定义数据类使用优先级队列</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue, PriorityQueue</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># order=True：默认将生成__gt__、__ge__、__lt__、__le__方法</span></span><br><span class="line"><span class="meta">@dataclass(order=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkItem</span>:</span></span><br><span class="line">    priority: int</span><br><span class="line">    <span class="comment"># compare=False 字段不参与比较</span></span><br><span class="line">    data: str = field(compare=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(queue: Queue)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        work_item: WorkItem = <span class="keyword">await</span> queue.get()</span><br><span class="line">        print(<span class="string">f'Processing work item <span class="subst">&#123;work_item&#125;</span>'</span>)</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    priority_queue = PriorityQueue()</span><br><span class="line"></span><br><span class="line">    work_items = [</span><br><span class="line">        WorkItem(<span class="number">3</span>, <span class="string">'Lowest priority'</span>),</span><br><span class="line">        WorkItem(<span class="number">2</span>, <span class="string">'Medium priority'</span>),</span><br><span class="line">        WorkItem(<span class="number">1</span>, <span class="string">'High priority'</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    worker_task = asyncio.create_task(worker(priority_queue))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> work <span class="keyword">in</span> work_items:</span><br><span class="line">        priority_queue.put_nowait(work)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(priority_queue.join(), worker_task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Processing work item WorkItem(priority=1, data='High priority')</span></span><br><span class="line"><span class="string">Processing work item WorkItem(priority=2, data='Medium priority')</span></span><br><span class="line"><span class="string">Processing work item WorkItem(priority=3, data='Lowest priority')</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h4 id="栈-LIFO"><a href="#栈-LIFO" class="headerlink" title="栈 LIFO"></a>栈 LIFO</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue, LifoQueue</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(order=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkItem</span>:</span></span><br><span class="line">    priority: int</span><br><span class="line">    order: int</span><br><span class="line">    data: str = field(compare=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(queue: Queue)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        work_item: WorkItem = <span class="keyword">await</span> queue.get()</span><br><span class="line">        print(<span class="string">f'出栈： <span class="subst">&#123;work_item&#125;</span>'</span>)</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    lifo_queue = LifoQueue()</span><br><span class="line"></span><br><span class="line">    work_items = [</span><br><span class="line">        WorkItem(<span class="number">3</span>, <span class="number">1</span>, <span class="string">'Lowest priority first'</span>),</span><br><span class="line">        WorkItem(<span class="number">3</span>, <span class="number">2</span>, <span class="string">'Lowest priority second'</span>),</span><br><span class="line">        WorkItem(<span class="number">3</span>, <span class="number">3</span>, <span class="string">'Lowest priority third'</span>),</span><br><span class="line">        WorkItem(<span class="number">2</span>, <span class="number">4</span>, <span class="string">'Medium priority'</span>),</span><br><span class="line">        WorkItem(<span class="number">1</span>, <span class="number">5</span>, <span class="string">'High priority'</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    worker_task = asyncio.create_task(worker(lifo_queue))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> work <span class="keyword">in</span> work_items:</span><br><span class="line">        print(<span class="string">f"入栈: <span class="subst">&#123;work&#125;</span>"</span>)</span><br><span class="line">        lifo_queue.put_nowait(work)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(lifo_queue.join(), worker_task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h3 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h3><h4 id="检测是否为协程"><a href="#检测是否为协程" class="headerlink" title="检测是否为协程"></a>检测是否为协程</h4><p>asyncio 提供了几个方便函数来帮助我们实现这一点：asyncio.iscoroutine和asyncio.iscoroutinefunction。这些函数可以让我们测试可调用对象是否为协程，从而让我们根据此应用不同的逻辑。</p>
<h4 id="强制运行事件循环"><a href="#强制运行事件循环" class="headerlink" title="强制运行事件循环"></a>强制运行事件循环</h4><p>通过将零传递给 asyncio.sleep 来暂停当前的协程并强制迭代事件循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_tasks_no_sleep</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(delay(<span class="number">1</span>))</span><br><span class="line">    task2 = asyncio.create_task(delay(<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># 没有使用 asyncio.sleep(0) 的时候，会先打印下面的 "获取到任务：" 然后 gather 在执行任务</span></span><br><span class="line">    print(<span class="string">"获取到任务："</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_tasks_sleep</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(delay(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0</span>)</span><br><span class="line">    task2 = asyncio.create_task(delay(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 使用 asyncio.sleep(0) 的时候，会先执行上面的任务，然后在打印 "获取到任务："</span></span><br><span class="line">    print(<span class="string">"获取到任务："</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'--- 没有使用 asyncio.sleep(0) ---'</span>)</span><br><span class="line">    <span class="keyword">await</span> create_tasks_no_sleep()</span><br><span class="line">    print(<span class="string">'--- 使用 asyncio.sleep(0) ---'</span>)</span><br><span class="line">    <span class="keyword">await</span> create_tasks_sleep()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">--- 没有使用 asyncio.sleep(0) ---</span></span><br><span class="line"><span class="string">获取到任务：</span></span><br><span class="line"><span class="string">sleeping for 1 second(s)</span></span><br><span class="line"><span class="string">sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">finished sleeping for 1 second(s)</span></span><br><span class="line"><span class="string">finished sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">--- 使用 asyncio.sleep(0) ---</span></span><br><span class="line"><span class="string">sleeping for 1 second(s)</span></span><br><span class="line"><span class="string">sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">获取到任务：</span></span><br><span class="line"><span class="string">finished sleeping for 1 second(s)</span></span><br><span class="line"><span class="string">finished sleeping for 2 second(s)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>使用 sleep(0) 会强制进行事件循环的迭代，从而导致我们的任务中的代码立即执行。</p>
<blockquote>
<p>asyncio.sleep(0) 强制执行事件循环吗? </p>
<p>ChatGPT:  <code>asyncio.sleep(0)</code>用于提醒事件循环 “我暂时不需要运行，请检查是否有其他任务需要执行”，而不是强制执行事件循环。强制执行事件循环的方式通常是使用<code>asyncio.get_event_loop().run_until_complete(...)</code>或<code>asyncio.get_event_loop().run_forever()</code>等方法，但这样的用法应该谨慎，以避免阻塞事件循环的正常执行。</p>
</blockquote>
<h4 id="使用uvloop作为事件循环"><a href="#使用uvloop作为事件循环" class="headerlink" title="使用uvloop作为事件循环"></a>使用uvloop作为事件循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> StreamReader, StreamWriter</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(reader: StreamReader, writer: StreamWriter)</span>:</span></span><br><span class="line">    line = <span class="keyword">await</span> reader.readline()</span><br><span class="line">    writer.write(line)</span><br><span class="line">    <span class="keyword">await</span> writer.drain()</span><br><span class="line">    writer.close()</span><br><span class="line">    <span class="keyword">await</span> writer.wait_closed()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    server = <span class="keyword">await</span> asyncio.start_server(connected, port=<span class="number">9000</span>)</span><br><span class="line">    <span class="keyword">await</span> server.serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换事件循环</span></span><br><span class="line">uvloop.install()</span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者采用这种方式切换</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">loop = uvloop.new_event_loop()</span></span><br><span class="line"><span class="string">asyncio.set_event_loop(loop)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>重要的部分是在调用 asyncio.run(main()) 之前调用它。在实现上，asyncio.run 会调用 get_event_loop 来创建一个事件循环（如果不存在的话）。所以如果要达到替换的效果，那么需要在 asyncio.run(main()) 之前调用它。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/27/Consul 服务发现和注册/" rel="prev" title="Consul 服务注册和发现">
      <i class="fa fa-chevron-left"></i> Consul 服务注册和发现
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/07/28/修改 Docker IP/" rel="next" title="修改 Docker 容器的 IP">
      修改 Docker 容器的 IP <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#摘要"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章"><span class="nav-number">2.</span> <span class="nav-text">第一章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并行和并发"><span class="nav-number">2.1.</span> <span class="nav-text">并行和并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GIL-锁"><span class="nav-number">2.2.</span> <span class="nav-text">GIL 锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多进程代码示例"><span class="nav-number">2.3.</span> <span class="nav-text">多进程代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程代码示例"><span class="nav-number">2.4.</span> <span class="nav-text">多线程代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统事件通知"><span class="nav-number">2.5.</span> <span class="nav-text">操作系统事件通知</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章"><span class="nav-number">3.</span> <span class="nav-text">第二章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单协程示例"><span class="nav-number">3.1.</span> <span class="nav-text">简单协程示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加-await-关键字"><span class="nav-number">3.2.</span> <span class="nav-text">添加 await 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#asyncio-sleep"><span class="nav-number">3.3.</span> <span class="nav-text">asyncio.sleep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#任务"><span class="nav-number">3.4.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行多个任务"><span class="nav-number">3.5.</span> <span class="nav-text">运行多个任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取消任务"><span class="nav-number">3.6.</span> <span class="nav-text">取消任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置超时时间"><span class="nav-number">3.7.</span> <span class="nav-text">设置超时时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#超时后任务被取消"><span class="nav-number">3.7.1.</span> <span class="nav-text">超时后任务被取消</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#超时后任务不取消"><span class="nav-number">3.7.2.</span> <span class="nav-text">超时后任务不取消</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#future"><span class="nav-number">3.8.</span> <span class="nav-text">future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Awaitable"><span class="nav-number">3.9.</span> <span class="nav-text">Awaitable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协程装饰器"><span class="nav-number">3.10.</span> <span class="nav-text">协程装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两种错误的异步场景"><span class="nav-number">3.11.</span> <span class="nav-text">两种错误的异步场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#将CPU密集型任务运行在协程中"><span class="nav-number">3.11.1.</span> <span class="nav-text">将CPU密集型任务运行在协程中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用阻塞的-I-O-操作"><span class="nav-number">3.11.2.</span> <span class="nav-text">使用阻塞的 I/O 操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件循环"><span class="nav-number">3.12.</span> <span class="nav-text">事件循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试模式"><span class="nav-number">3.13.</span> <span class="nav-text">调试模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四章"><span class="nav-number">4.</span> <span class="nav-text">第四章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异步上下文"><span class="nav-number">4.1.</span> <span class="nav-text">异步上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aiohttp"><span class="nav-number">4.2.</span> <span class="nav-text">aiohttp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表推导式下的并发"><span class="nav-number">4.3.</span> <span class="nav-text">列表推导式下的并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gather"><span class="nav-number">4.4.</span> <span class="nav-text">gather</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#as-completed"><span class="nav-number">4.5.</span> <span class="nav-text">as_completed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait"><span class="nav-number">4.6.</span> <span class="nav-text">wait</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第六章"><span class="nav-number">5.</span> <span class="nav-text">第六章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多进程示例"><span class="nav-number">5.1.</span> <span class="nav-text">多进程示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程池"><span class="nav-number">5.2.</span> <span class="nav-text">进程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步运行"><span class="nav-number">5.3.</span> <span class="nav-text">异步运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程池执行器"><span class="nav-number">5.4.</span> <span class="nav-text">进程池执行器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步事件循环结合执行器"><span class="nav-number">5.5.</span> <span class="nav-text">异步事件循环结合执行器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多进程锁"><span class="nav-number">5.6.</span> <span class="nav-text">多进程锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行既包含CPU密集和IO密集的任务"><span class="nav-number">5.7.</span> <span class="nav-text">运行既包含CPU密集和IO密集的任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第七章"><span class="nav-number">6.</span> <span class="nav-text">第七章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用线程池执行-Request"><span class="nav-number">6.1.</span> <span class="nav-text">使用线程池执行 Request</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用线程池执行器与asyncio"><span class="nav-number">6.2.</span> <span class="nav-text">使用线程池执行器与asyncio</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认执行器"><span class="nav-number">6.3.</span> <span class="nav-text">默认执行器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程锁"><span class="nav-number">6.4.</span> <span class="nav-text">线程锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可重入线程锁"><span class="nav-number">6.5.</span> <span class="nav-text">可重入线程锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他函数"><span class="nav-number">6.6.</span> <span class="nav-text">其他函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第九章"><span class="nav-number">7.</span> <span class="nav-text">第九章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-Gunicorn-部署-ASGI-应用"><span class="nav-number">7.1.</span> <span class="nav-text">使用 Gunicorn 部署 ASGI 应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十一章"><span class="nav-number">8.</span> <span class="nav-text">第十一章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#asyncio-锁"><span class="nav-number">8.1.</span> <span class="nav-text">asyncio 锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">8.2.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Event"><span class="nav-number">8.3.</span> <span class="nav-text">Event</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Conditions"><span class="nav-number">8.4.</span> <span class="nav-text">Conditions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十二章"><span class="nav-number">9.</span> <span class="nav-text">第十二章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#队列"><span class="nav-number">9.1.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级队列"><span class="nav-number">9.2.</span> <span class="nav-text">优先级队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈-LIFO"><span class="nav-number">9.3.</span> <span class="nav-text">栈 LIFO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十四章"><span class="nav-number">10.</span> <span class="nav-text">第十四章</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检测是否为协程"><span class="nav-number">10.1.</span> <span class="nav-text">检测是否为协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制运行事件循环"><span class="nav-number">10.2.</span> <span class="nav-text">强制运行事件循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用uvloop作为事件循环"><span class="nav-number">10.3.</span> <span class="nav-text">使用uvloop作为事件循环</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rex"
      src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
  <p class="site-author-name" itemprop="name">Rex</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">446</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa-hand-o-right"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rex</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
