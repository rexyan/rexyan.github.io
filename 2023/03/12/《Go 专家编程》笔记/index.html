<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rexyan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"top","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go 专家编程是一本比较通熟易懂的 Go 进阶书籍，早豆瓣评分也很高，学习比较整理如下，源码: https://github.com/rexyan/go_zjbc Slice 切片创建12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &amp;#123;	// 变量声明, 值为 nil，长度为 0	va">
<meta property="og:type" content="article">
<meta property="og:title" content="《Go 专家编程》笔记">
<meta property="og:url" content="https://rexyan.github.io/2023/03/12/《Go 专家编程》笔记/index.html">
<meta property="og:site_name" content="星尘">
<meta property="og:description" content="Go 专家编程是一本比较通熟易懂的 Go 进阶书籍，早豆瓣评分也很高，学习比较整理如下，源码: https://github.com/rexyan/go_zjbc Slice 切片创建12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &amp;#123;	// 变量声明, 值为 nil，长度为 0	va">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2025-10-31T03:20:39.404Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Go 专家编程》笔记">
<meta name="twitter:description" content="Go 专家编程是一本比较通熟易懂的 Go 进阶书籍，早豆瓣评分也很高，学习比较整理如下，源码: https://github.com/rexyan/go_zjbc Slice 切片创建12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &amp;#123;	// 变量声明, 值为 nil，长度为 0	va">

<link rel="canonical" href="https://rexyan.github.io/2023/03/12/《Go 专家编程》笔记/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Go 专家编程》笔记 | 星尘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css" />
  <!-- 自定义为霞鹜文楷字体 -->
  <style>
	  body,div.post-body,h1,h2,h3,h4 {
		font-family: "LXGW WenKai Screen", sans-serif;
		font-size: 104%;
	  }
  </style>
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">星尘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-读书">

    <a href="/books/" rel="section"><i class="address-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-瞎扯">

    <a href="/crap/" rel="section"><i class="crap fa-fw"></i>瞎扯</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



<script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script>

<meta name="referrer" content="never">




  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rexyan.github.io/2023/03/12/《Go 专家编程》笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
      <meta itemprop="name" content="Rex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星尘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Go 专家编程》笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-12 17:35:57" itemprop="dateCreated datePublished" datetime="2023-03-12T17:35:57+00:00">2023-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-31 03:20:39" itemprop="dateModified" datetime="2025-10-31T03:20:39+00:00">2025-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Go 专家编程是一本比较通熟易懂的 Go 进阶书籍，早豆瓣评分也很高，学习比较整理如下，源码: <a href="https://github.com/rexyan/go_zjbc" target="_blank" rel="noopener">https://github.com/rexyan/go_zjbc</a></p>
<h3 id="Slice-切片"><a href="#Slice-切片" class="headerlink" title="Slice 切片"></a>Slice 切片</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 变量声明, 值为 nil，长度为 0</span></span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字面量</span></span><br><span class="line">	s1 := []<span class="keyword">int</span>&#123;&#125;          <span class="comment">// 空切片，长度为0，值不是 nil，如果需要创建长度为 0 的切片，推荐变量声明的方式</span></span><br><span class="line">	s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;   <span class="comment">//长度为 3 的切片</span></span><br><span class="line">	fmt.Println(s, s1, s2) <span class="comment">// [] [] [1 2 3]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内置函数</span></span><br><span class="line">	s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)      <span class="comment">//指定长度</span></span><br><span class="line">	s4 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">100</span>) <span class="comment">// 指定长度和空间</span></span><br><span class="line">	fmt.Println(s3, s4)        <span class="comment">// [0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 切取</span></span><br><span class="line">	array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 创建数组</span></span><br><span class="line">	s5 := array[<span class="number">0</span>:<span class="number">2</span>]               <span class="comment">// 从数组中切取</span></span><br><span class="line">	s6 := s5[<span class="number">0</span>:<span class="number">1</span>]                  <span class="comment">// 从切片中切取</span></span><br><span class="line">	fmt.Println(s5, s6)            <span class="comment">// [1 2] [1]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="追加操作"><a href="#追加操作" class="headerlink" title="追加操作"></a>追加操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s7 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	s7 = <span class="built_in">append</span>(s7, <span class="number">1</span>)                 <span class="comment">// 追加一个元素</span></span><br><span class="line">	s7 = <span class="built_in">append</span>(s7, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)     <span class="comment">// 追加多个</span></span><br><span class="line">	s7 = <span class="built_in">append</span>(s7, []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;...) <span class="comment">// 追加一个切片</span></span><br><span class="line">	fmt.Println(s7)                    <span class="comment">//[1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		当空间不足时，append会先创建新的大容量切片，添加元素后再返回新的切片</span></span><br><span class="line"><span class="comment">		切片本身是结构体，结构体中直接存储了切片的长度和容量，所以获取这两个操作的时间复杂度都是 O(1)</span></span><br><span class="line"><span class="comment">		因为切片本身是结构体，所以通过函数传递时，不会拷贝整个切片</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		slice 数据结构如下:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		type slice struct &#123;</span></span><br><span class="line"><span class="comment">			array unsafe.Pointer</span></span><br><span class="line"><span class="comment">			len   int</span></span><br><span class="line"><span class="comment">			cap   int</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		array 指向底层数组</span></span><br><span class="line"><span class="comment">		len表示切片长度</span></span><br><span class="line"><span class="comment">		cap表示数组容量</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	array := [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	slice := array[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice)) <span class="comment">// 2 5</span></span><br><span class="line">	<span class="comment">// 切片从数组 array[5] 开始，到 array[7]（不包含） 结束，长度为2，数组后面的内容都作为预留内存，即 cap 为 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice)) <span class="comment">// 5 5</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 追加一个元素后空间不够，触发扩容</span></span><br><span class="line">	slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice)) <span class="comment">// 6 10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		扩容规则：</span></span><br><span class="line"><span class="comment">		1.如果原 slice 容量小于 1024，则新的 slice 扩大为原来的 2 倍</span></span><br><span class="line"><span class="comment">		2.如果原 slice 容量大于或等于 1024，则新的 slice 扩大为原来的 1.25 倍</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		append 添加元素实现步骤：</span></span><br><span class="line"><span class="comment">		1. 假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice</span></span><br><span class="line"><span class="comment">		2. 原Slice容量不够，则将Slice先扩容，扩容后得到新Slice</span></span><br><span class="line"><span class="comment">		3. 将新元素追加进新Slice，Slice.len++，返回新的Slice。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 切片的简单表达式为 a[low: high]</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		如果简单表达式切取的对象为字符串或数组，那么 low 和 high 应该满足一下关系： 0 &lt;= low &lt;= high &lt;= len(a)</span></span><br><span class="line"><span class="comment">		而，如果简单表达式切取的对象为切片，那么 low 和 high 的最大值可取 a 的容量，而不是 a 的长度：0 &lt;= low &lt;= high &lt;= cap(a)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		注意：作用于字符串的切片，得到的还是字符串。而不是切片。</span></span><br><span class="line"><span class="comment">		a[:high] 等同于 a[0:high]</span></span><br><span class="line"><span class="comment">		a[0:]    等同于 a[0:len(a)]</span></span><br><span class="line"><span class="comment">		a[:]     等同于 a[0:len(a)]</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	baseArray := [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	newSlice1 := baseArray[<span class="number">0</span>:<span class="number">10</span>]                           <span class="comment">// 这里最多只能切到 10</span></span><br><span class="line">	fmt.Println(newSlice1, <span class="built_in">len</span>(newSlice1), <span class="built_in">cap</span>(newSlice1)) <span class="comment">// [0 0 0 0 0 0 0 0 0 0] 10 10</span></span><br><span class="line"></span><br><span class="line">	baseSlice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)                        <span class="comment">// 长度为0，容量为 10 的 slice</span></span><br><span class="line">	newSlice2 := baseSlice[<span class="number">2</span>:<span class="number">5</span>]                            <span class="comment">// 这里切片的 low 和 high 可以超过 len(a)</span></span><br><span class="line">	fmt.Println(newSlice2, <span class="built_in">len</span>(newSlice2), <span class="built_in">cap</span>(newSlice2)) <span class="comment">// [0 0 0] 3 8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 切片的拓展表达式为 a[low: high: max], 使用 max 限制新生成切片的容量，新切片的容量为 max-low。它们需要满足以下关系：</span></span><br><span class="line">	<span class="comment">// 0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		对于切片的简单表达式会带来一些问题，例如：</span></span><br><span class="line"><span class="comment">		a := [5]int&#123;1,2,3,4,5&#125;</span></span><br><span class="line"><span class="comment">		b := a[1:4]</span></span><br><span class="line"><span class="comment">		b = append(b, 0) // 此时元素a[4]将由5变为0</span></span><br><span class="line"><span class="comment">		发生这种情况是 append 操作可能会覆盖 a[high] 及后面的元素。这是很危险的。所以推出了切片的拓展表达式为 a[low: high: max]</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	array := [<span class="number">10</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	slice := array[<span class="number">5</span>:<span class="number">7</span>:<span class="number">7</span>]</span><br><span class="line">	fmt.Println(slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice)) <span class="comment">// [0 0] 2 2</span></span><br><span class="line">	<span class="comment">// 如果使用简单表但是，那么上述代码中切片的容量将是5，而使用拓展表达式时，容量则是2。这时如果再次使用 append 进行追加， 如果空间不足则会产</span></span><br><span class="line">	<span class="comment">// 生一个全新的切片，而不会覆盖原始的数组或切片。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1. string 可以为空（长度为0），但是不会是 nil</span></span><br><span class="line"><span class="comment">		2. string 对象不可以修改。</span></span><br><span class="line"><span class="comment">		3. string 和 []byte 的转换会发生一次内存拷贝，会有一定的开销</span></span><br><span class="line"><span class="comment">		4. 使用的 + 进行字符串的拼接会触发内存的分配和拷贝。在拼接时会先计算最终字符串的长度后再次分配内存。</span></span><br><span class="line"><span class="comment">		5. 字符串长度是指 Unicode 编码所占的字节数。</span></span><br><span class="line"><span class="comment">		6. 使用 for-range 遍历字符串时，每次迭代将返回字符 UTF-8 编码的首个字节的下标及字节值。这意味着，下标可能不连续。</span></span><br><span class="line"><span class="comment">		7. 字符串也可以使用反单引号表示。反单引号和双引号的区别是，反单引号是带有格式的。和 Python 中的 """""" 一致。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s := <span class="string">"中国"</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Println(index, value)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			0 20013</span></span><br><span class="line"><span class="comment">			3 22269</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 未初始化的 map 默认值为 nil，向其中添加元素会触发 panic。</span></span><br><span class="line">	<span class="comment">// 查询元素时，如果元素不存在，则会返回值类型的零值。</span></span><br><span class="line">	<span class="keyword">var</span> exampleMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">	<span class="comment">// exampleMap["1"] = 1 // 会触发 panic</span></span><br><span class="line">	<span class="comment">// fmt.Println(exampleMap)</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(exampleMap[<span class="string">"key"</span>])    <span class="comment">// 0,返回值类型的零值</span></span><br><span class="line">	value, exist := exampleMap[<span class="string">"key"</span>] <span class="comment">// 第二个参数返回 bool，表示 key 是否存在</span></span><br><span class="line">	<span class="keyword">if</span> exist &#123;</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(exampleMap, <span class="string">"key1"</span>) <span class="comment">// 不管 key 是否存在，或 map 是否已经初始化，进行 delete 操作时都不会报错。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// map 不能进行并发操作，如果需要并发读写，那么可以使用 sync 包中的 sync.Map。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		map 的数据结构如下所示：</span></span><br><span class="line"><span class="comment">		type hmap struct &#123;</span></span><br><span class="line"><span class="comment">			count int // 当前保存的元素个数</span></span><br><span class="line"><span class="comment">			B uint8   // 指示bucket数组的大小</span></span><br><span class="line"><span class="comment">			buckets unsafe.Pointer    // bucket数组指针，数组的大小为2^B</span></span><br><span class="line"><span class="comment">			oldbuckets unsafe.Pointer // 老旧bucket数组指针，在扩容时会用到</span></span><br><span class="line"><span class="comment">			...</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// map 的增删改查，在hash表中的操作：</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		查找过程：</span></span><br><span class="line"><span class="comment">			1. 跟据key值算出哈希值</span></span><br><span class="line"><span class="comment">			2. 取哈希值低位与hmpa.B取模确定bucket位置</span></span><br><span class="line"><span class="comment">			3. 取哈希值高位在tophash数组中查询</span></span><br><span class="line"><span class="comment">			4. 如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</span></span><br><span class="line"><span class="comment">			5. 当前bucket没有找到，则继续从下个overflow的bucket中查找。</span></span><br><span class="line"><span class="comment">			6. 如果当前处于搬迁过程，则优先从oldbuckets查找</span></span><br><span class="line"><span class="comment">		添加过程：</span></span><br><span class="line"><span class="comment">			1. 跟据key值算出哈希值</span></span><br><span class="line"><span class="comment">			2. 取哈希值低位与hmap.B取模确定bucket位置</span></span><br><span class="line"><span class="comment">			3. 查找该key是否已经存在，如果存在则直接更新值</span></span><br><span class="line"><span class="comment">			4. 如果没找到将key，将key插入</span></span><br><span class="line"><span class="comment">		删除过程：</span></span><br><span class="line"><span class="comment">			先在bucket中查找元素，存在则清除，否则什么也不做。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><h4 id="取值规则"><a href="#取值规则" class="headerlink" title="取值规则"></a>取值规则</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(LOG_EMERG)   <span class="comment">// 0</span></span><br><span class="line">	fmt.Println(LOG_ALERT)   <span class="comment">// 1</span></span><br><span class="line">	fmt.Println(LOG_CRIT)    <span class="comment">// 2</span></span><br><span class="line">	fmt.Println(LOG_ERR)     <span class="comment">// 3</span></span><br><span class="line">	fmt.Println(LOG_WARNING) <span class="comment">// 4</span></span><br><span class="line">	fmt.Println(LOG_NOTICE)  <span class="comment">// 5</span></span><br><span class="line">	fmt.Println(LOG_INFO)    <span class="comment">// 6</span></span><br><span class="line">	fmt.Println(LOG_DEBUG)   <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(bit0, mask0)</span><br><span class="line">	fmt.Println(bit1, mask1)</span><br><span class="line">	fmt.Println(bit3, mask3)</span><br><span class="line"></span><br><span class="line">	fmt.Println(mutexLocked)</span><br><span class="line">	fmt.Println(mutexWoken)</span><br><span class="line">	fmt.Println(mutexStarving)</span><br><span class="line">	fmt.Println(mutexWaiterShift)</span><br><span class="line">	fmt.Println(starvationThresholdNs)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Priority <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. const 代表了 const 声明块的行索引（索引从 0 开始）</span></span><br><span class="line"><span class="comment">2. const 声明还有一个特点，如果为常量指定了一个表达式，但后续常量没有表达式，则继承上面的表达式</span></span><br><span class="line"><span class="comment">3. 单行 const 声明块中，没增加一行声明，iota 的值递增1，即便声明中没有使用 iota 也是如此</span></span><br><span class="line"><span class="comment">4. 单行声明语句中，即便多出现多个 iota，iota 的取值也保持不变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	LOG_EMERG Priority = <span class="literal">iota</span></span><br><span class="line">	LOG_ALERT</span><br><span class="line">	LOG_CRIT</span><br><span class="line">	LOG_ERR</span><br><span class="line">	LOG_WARNING</span><br><span class="line">	LOG_NOTICE</span><br><span class="line">	LOG_INFO</span><br><span class="line">	LOG_DEBUG</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 左移：x&lt;&lt;y等于x乘以2^y，右移：则是除。</span></span><br><span class="line"></span><br><span class="line">	bit0, mask0 = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>, <span class="number">1</span>&lt;&lt;<span class="literal">iota</span> - <span class="number">1</span> <span class="comment">// const 声明第0行，iota 为0，所以 bit0=1，mask0=0</span></span><br><span class="line">	bit1, mask1                          <span class="comment">// const 声明第1行，iota 为1，且没有表达式，继承上面的表达式，所以 bit0=2，mask0=1</span></span><br><span class="line">	_, _                                 <span class="comment">// const 声明第2行，iota 为2</span></span><br><span class="line">	bit3, mask3                          <span class="comment">// const 声明第3行，iota 为3，且没有表达式，继承上面的表达式，所以 bit0=8，mask0=7</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	mutexLocked           = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// const 声明第0行，iota 为0，所以值为 1</span></span><br><span class="line">	mutexWoken                        <span class="comment">// const 声明第1行，iota 为1，且没有表达式，继承上面的表达式，所以值为 2</span></span><br><span class="line">	mutexStarving                     <span class="comment">// const 声明第2行，iota 为2，且没有表达式，继承上面的表达式，所以值为 4</span></span><br><span class="line">	mutexWaiterShift      = <span class="literal">iota</span>      <span class="comment">// const 声明第3行，iota 为3</span></span><br><span class="line">	starvationThresholdNs = <span class="number">1e6</span>       <span class="comment">// 科学计数法 1000000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="Struct-结构体"><a href="#Struct-结构体" class="headerlink" title="Struct 结构体"></a>Struct 结构体</h3><h4 id="获取-tag-信息"><a href="#获取-tag-信息" class="headerlink" title="获取 tag 信息"></a>获取 tag 信息</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TypeMeta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Kind       <span class="keyword">string</span> <span class="string">`json:"kind,omitempty"`</span></span><br><span class="line">	ApiVersion <span class="keyword">string</span> <span class="string">`json:"apiVersion,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := TypeMeta&#123;</span><br><span class="line">		Kind: <span class="string">"kind"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	ty := reflect.TypeOf(t)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ty.NumField(); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"字段名称:%s, Json Tag:%s\n"</span>, ty.Field(i).Name, ty.Field(i).Tag.Get(<span class="string">"json"</span>))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			字段名称:Kind, Json Tag:kind,omitempty</span></span><br><span class="line"><span class="comment">			字段名称:ApiVersion, Json Tag:apiVersion,omitempty</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	marshal, err := json.Marshal(t)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(marshal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel 通道"></a>Channel 通道</h3><h4 id="创建，以及触发nil情况"><a href="#创建，以及触发nil情况" class="headerlink" title="创建，以及触发nil情况"></a>创建，以及触发nil情况</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 变量方式声明管道，值为 nil，每个管道只能存储一种类型的数据 (对于 nil 的管道，无论读写都会阻塞，而且为永久阻塞)</span></span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 变量方式声明管道, 需要结合 make 才能进一步使用</span></span><br><span class="line">	ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内置函数 make 声明</span></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)    <span class="comment">// 不带缓存区</span></span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">5</span>) <span class="comment">// 带缓存区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&lt;nil&gt;</span></span><br><span class="line">	<span class="comment">//0xc000102060</span></span><br><span class="line">	<span class="comment">//0xc000126120</span></span><br><span class="line">	fmt.Println(ch)</span><br><span class="line">	fmt.Println(ch1)</span><br><span class="line">	fmt.Println(ch2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		协程读取管道，会发生阻塞的情况：</span></span><br><span class="line"><span class="comment">			1.管道无缓冲区</span></span><br><span class="line"><span class="comment">			2.管道的缓冲区中无数据</span></span><br><span class="line"><span class="comment">			3.管道的值为nil</span></span><br><span class="line"><span class="comment">		协程写入管道，会发生阻塞的情况：</span></span><br><span class="line"><span class="comment">			1.管道无缓冲区</span></span><br><span class="line"><span class="comment">			2.管道的缓冲区已满</span></span><br><span class="line"><span class="comment">			3.管道的值为nil</span></span><br><span class="line"><span class="comment">		关闭管道，会发生阻塞的操作：</span></span><br><span class="line"><span class="comment">			1.关闭值为nil的管道</span></span><br><span class="line"><span class="comment">			2.关闭已经关闭的管道</span></span><br><span class="line"><span class="comment">			3.向已经关闭的管道写入数据</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单向管道"><a href="#单向管道" class="headerlink" title="单向管道"></a>单向管道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从管道的定义来看，并没有单向管道，所谓的单向管道，只是对管道的使用的一种限制来达到的目的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过形参限制函数内部只能从管道中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readChan</span><span class="params">(chanName &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	&lt;-chanName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过形参限制函数内部只能从管道中写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeChan</span><span class="params">(chanName <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	chanName &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	writeChan(myChan)</span><br><span class="line">	readChan(myChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select-和管道"><a href="#select-和管道" class="headerlink" title="select 和管道"></a>select 和管道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNumberToChan</span><span class="params">(chanName <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		chanName &lt;- <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">var</span> chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> addNumberToChan(chan1)</span><br><span class="line">	<span class="keyword">go</span> addNumberToChan(chan2)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-chan1:</span><br><span class="line">			fmt.Printf(<span class="string">"从 chan1 接受到数据%d\n"</span>, e)</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-chan2:</span><br><span class="line">			fmt.Printf(<span class="string">"从 chan2 接受到数据%d\n"</span>, e)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">"未接收到数据\n"</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		从 chan2 接受到数据1</span></span><br><span class="line"><span class="comment">		从 chan1 接受到数据1</span></span><br><span class="line"><span class="comment">		从 chan2 接受到数据1</span></span><br><span class="line"><span class="comment">		从 chan1 接受到数据1</span></span><br><span class="line"><span class="comment">		未接收到数据</span></span><br><span class="line"><span class="comment">		未接收到数据</span></span><br><span class="line"><span class="comment">		从 chan2 接受到数据1</span></span><br><span class="line"><span class="comment">		从 chan1 接受到数据1</span></span><br><span class="line"><span class="comment">		从 chan1 接受到数据1</span></span><br><span class="line"><span class="comment">		从 chan2 接受到数据1</span></span><br><span class="line"><span class="comment">		未接收到数据</span></span><br><span class="line"><span class="comment">		未接收到数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		以上结果可以看出，select 从管道中读取数据是随机的 （这是 select case 的特性，执行顺序就是随机的）</span></span><br><span class="line"><span class="comment">		select 的 case 语句在读取管道时，尽管管道没有中没有数据也不会被阻塞。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-range-和管道"><a href="#for-range-和管道" class="headerlink" title="for-range 和管道"></a>for-range 和管道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addDataToChan</span><span class="params">(chanName <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		chanName &lt;- <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> chan1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> addDataToChan(chan1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 持续的从管道中读取数据，当管道中没有数据时，当前协程会被阻塞</span></span><br><span class="line">	<span class="keyword">for</span> e := <span class="keyword">range</span> chan1 &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"从 chan2 接受到数据%d\n"</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		select 只能作用于管道，包括数据的读取和写入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		第一种情况：</span></span><br><span class="line"><span class="comment">		c := make(chan string)</span></span><br><span class="line"><span class="comment">		SelectForChan(c)</span></span><br><span class="line"><span class="comment">		此时管道无缓冲区，既不能写入，也不能读取，两个case均不执行，所以select陷入阻塞。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		第二种情况：</span></span><br><span class="line"><span class="comment">		c := make(chan string, 1)</span></span><br><span class="line"><span class="comment">		SelectForChan(c)</span></span><br><span class="line"><span class="comment">		此时管道有缓冲区，但是里面无数据，只能写入，写操作的 case得到执行，且执行后退出函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		第三种情况：</span></span><br><span class="line"><span class="comment">		c := make(chan string, 1)</span></span><br><span class="line"><span class="comment">		SelectForChan(c)</span></span><br><span class="line"><span class="comment">		此时管道有缓冲区，但是里面已满，只能读取数据，读操作的 case得到执行，且执行后退出函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		第四种情况：</span></span><br><span class="line"><span class="comment">		c := make(chan string, 2)</span></span><br><span class="line"><span class="comment">		SelectForChan(c)</span></span><br><span class="line"><span class="comment">		此时管道有缓冲区，但是缓存区没有满，此时既可以写入数据，也可以读取数据。select 将随机挑选一个 case 执行，且执行后退出函数</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectForChan</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> recv <span class="keyword">string</span></span><br><span class="line">	send := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> recv = &lt;-c:</span><br><span class="line">		fmt.Printf(<span class="string">"从管道接收到了数据%s\n"</span>, recv)</span><br><span class="line">	<span class="keyword">case</span> c &lt;- send:</span><br><span class="line">		fmt.Printf(<span class="string">"将数据%s送入了管道\n"</span>, send)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管道返回值"><a href="#管道返回值" class="headerlink" title="管道返回值"></a>管道返回值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	SelectAssign(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectAssign</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-c:</span><br><span class="line">		fmt.Println(<span class="string">"不接收返回值"</span>)</span><br><span class="line">	<span class="keyword">case</span> d := &lt;-c:</span><br><span class="line">		fmt.Printf(<span class="string">"接收一个返回值 %s"</span>, d)</span><br><span class="line">	<span class="keyword">case</span> d, ok := &lt;-c:</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">"管道已经关闭"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"接收两个返回值 %s"</span>, d)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如上所示，创建了一个无缓冲区的 chan，但是将这个 chan 关闭之后，三个 case 均可能执行。</span></span><br><span class="line"><span class="comment">第二个和第三个 case 接收到的数据都为空，但是第三个 case 可以感知管道被关闭。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		创建一个没有缓冲区的管道，读操作肯定是阻塞的，然后 select 含有 default 分支，select 将执行</span></span><br><span class="line"><span class="comment">		default 分支然后退出。另外，default 能出现在任意位置，且每个 select 只能含有一个 default。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-c:</span><br><span class="line">		fmt.Println(<span class="string">"读取数据"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 永久阻塞</span></span><br><span class="line">	<span class="comment">// select &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 限时等待</span></span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 需要控制超时时间的业务逻辑</span></span><br><span class="line">		doSomething()</span><br><span class="line">		<span class="comment">// 业务逻辑正常执行完，通知管道stopCh，执行完成</span></span><br><span class="line">		stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 启用超时控制</span></span><br><span class="line">	stopWithTimeOut := waitForStopOrTimeOut(stopCh, <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 若为超时，正常结束，isTimeOut=false, 否则为true</span></span><br><span class="line">	<span class="keyword">case</span> isTimeOut := &lt;-stopWithTimeOut:</span><br><span class="line">		<span class="keyword">if</span> isTimeOut &#123;</span><br><span class="line">			fmt.Println(<span class="string">"end timeout"</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"end ok"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitForStopOrTimeOut</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, timeout time.Duration)</span> &lt;-<span class="title">chan</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	stopWithTimeOut := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">			<span class="comment">// 若接收到业务逻辑正常结束的消息，则为自然结束</span></span><br><span class="line">			fmt.Println(<span class="string">"自然结束"</span>)</span><br><span class="line">			stopWithTimeOut &lt;- <span class="literal">false</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">			<span class="comment">// 若timeout时间内，未接收到业务逻辑正常结束的消息，则为超时</span></span><br><span class="line">			<span class="comment">// timeout时间后，time.After(timeout)可读取到管道信息</span></span><br><span class="line">			fmt.Println(<span class="string">"超时"</span>)</span><br><span class="line">			stopWithTimeOut &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(stopWithTimeOut)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> stopWithTimeOut</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 写入管道，代表协程结束</span></span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个包含十个元素的切片，元素类型为 channel</span></span><br><span class="line">	channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 切片中放入一个 channel</span></span><br><span class="line">		<span class="keyword">go</span> Process(channels[i])      <span class="comment">// 启动协程，传入一个管道用于通信</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父协程等待所有子协程结束</span></span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> channels &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		fmt.Printf(<span class="string">"channel %d end!\n"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用channel控制子协程的优点是实现简单，缺点是需要创建大量的协程时，就创建相同数量的channel。</span></span><br><span class="line"><span class="comment">	而且对子协程继续派生出来的协程不方便控制。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">2</span>) <span class="comment">// 设置计数器，即 goroutine 的数量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		fmt.Println(<span class="string">"goroutine 1 end!"</span>)</span><br><span class="line">		wg.Done() <span class="comment">// 执行结束后 goroutine -1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		fmt.Println(<span class="string">"goroutine 2 end!"</span>)</span><br><span class="line">		wg.Done() <span class="comment">// 执行结束后 goroutine -1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait() <span class="comment">// 主 goroutine 阻塞，等待计数器变为 0</span></span><br><span class="line">	fmt.Println(<span class="string">"all goroutine finished!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// context 和 WaitGroup 最大的区别就是 context 对于派生的 goroutine 有更强的控制力。可以控制多级的 goroutine。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1. context 只定义了接口，凡是实现该接口的类都可以称为是一种 context。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		type Context interface &#123;</span></span><br><span class="line"><span class="comment">				此方法返回一个是否设置 deadline 的 bool 值</span></span><br><span class="line"><span class="comment">				Deadline() (deadline time.Time, ok bool)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">				当 context 关闭后 Done 返回一个关闭的通道。当 context 未关闭时，Done 返回 nil。</span></span><br><span class="line"><span class="comment">				Done() &lt;-chan struct&#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">				返回 context 关闭的原因。</span></span><br><span class="line"><span class="comment">				Err() error</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">				根据 key 查询 map 中的 value</span></span><br><span class="line"><span class="comment">				Value(key any) any</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		2. context 包中定义了一个公用的 emptyCtx 全局变量，名为 background。可以使用 context.BackGround() 获取。</span></span><br><span class="line"><span class="comment">		3. context 包中提供了四个方法创建不同类型的 context，使用这四个方法时，如果没有 context，则都需要传入 background。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">									emptyCtx</span></span><br><span class="line"><span class="comment">			context interface		cancelCtx      timerCtx</span></span><br><span class="line"><span class="comment">									valueCtx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			emptyCtx,cancelCtx,valueCtx 都继承 context 接口</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> WriteRedis(ctx)</span><br><span class="line">	<span class="keyword">go</span> WriteDB(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"HandelRequest Done!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"HandelRequest Running!"</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDB</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"WriteDB Done!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"WriteDB Running!"</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteRedis</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"WriteRedis Done!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"WriteRedis Running!"</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 cancelCtx，返回第一个参数是上下文，第二个参数是 cancel 方法。</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启协程，此协程里面又回派生两个协程。并将 ctx 传入</span></span><br><span class="line">	<span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待协程执行</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cancel 掉所有子协程</span></span><br><span class="line">	cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待所有协程结束</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> WriteRedis(ctx)</span><br><span class="line">	<span class="keyword">go</span> WriteDB(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"HandelRequest Done!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"HandelRequest Running!"</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteDB</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"WriteDB Done!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"WriteDB Running!"</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteRedis</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"WriteRedis Done!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"WriteRedis Running!"</span>)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		timerCtx 在 cancelCtx 的基础上添加了 deadline，标示自动 cancel 的最终时间。</span></span><br><span class="line"><span class="comment">		而 timer 就是一个自动触发的定时器。由此衍生出 WithDeadline() 和 WithTimeout() 两个方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		WithDeadline: 指定最后期限，比如 context 将于某时间点自动结束</span></span><br><span class="line"><span class="comment">		WithTimeout: 指定最长成活时间，比如 context 将于 30s 后结束</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个定时 cancel 的 context。到期时间为当前时间后的 20s。也会返回 cancel 方法。可以在到期前手动 cancel context</span></span><br><span class="line">	ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(time.Second*<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个定时 cancel 的 context。到期时间为当前时间后的 10s。也会返回 cancel 方法。可以在到期前手动 cancel context</span></span><br><span class="line">	<span class="comment">// ctx, _ := context.WithTimeout(context.Background(), time.Second*10)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启协程，此协程里面又回派生两个协程。并将 ctx 传入</span></span><br><span class="line">	<span class="keyword">go</span> HandelRequest(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待协程执行</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	timeoutCtx, _ := context.WithTimeout(context.Background(), time.Second*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// WithValue 获取到一个 ctx。WithValue 的父 ctx 是 WithTimeout 获取的。这样整个协程能在指定时间内结束。否则不会结束，需要手工控制。</span></span><br><span class="line">	valueCtx := context.WithValue(timeoutCtx, <span class="string">"param"</span>, <span class="string">"rex"</span>)</span><br><span class="line">	<span class="keyword">go</span> HandelRequest(valueCtx)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandelRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">"HandelRequest Done!"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(<span class="string">"HandelRequest Running! Get Context Param value: "</span>, ctx.Value(<span class="string">"param"</span>))</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	context 总结：</span></span><br><span class="line"><span class="comment">	1. Context 仅仅是一个接口，根据不同的实现，可以衍生出不同类型的 context。</span></span><br><span class="line"><span class="comment">	2. cancelCtx 实现了 context 接口，通过 WithChancel() 创建 cancelCtx 实例。</span></span><br><span class="line"><span class="comment">	3. timerCtx 实现了 context 接口，通过 WithDeadline()，WithTimeout() 创建 timerCtx 实例。</span></span><br><span class="line"><span class="comment">	4. valueCtx 实现了 context 接口，通过 WithValue() 创建 valueCtx 实例。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="比较两个结构体变量"><a href="#比较两个结构体变量" class="headerlink" title="比较两个结构体变量"></a>比较两个结构体变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="keyword">int</span></span><br><span class="line">	B <span class="keyword">string</span></span><br><span class="line">	C <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		使用 "==" 可以比较两个结构体变量，但仅限于结构体成员为简单类型。</span></span><br><span class="line"><span class="comment">		使用 "==" 可以比较两个空接口类型变量，但仅限于底层类型一致，且不包含诸如 slice，map 等不可比较的类型。</span></span><br><span class="line"><span class="comment">		常常使用 reflect.DeepEqual 来比较两个结构体成员变量和两个空接口类型变量。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	f1 := Foo&#123;</span><br><span class="line">		A: <span class="number">1</span>,</span><br><span class="line">		B: <span class="string">"1"</span>,</span><br><span class="line">		C: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f2 := Foo&#123;</span><br><span class="line">		A: <span class="number">1</span>,</span><br><span class="line">		B: <span class="string">"1"</span>,</span><br><span class="line">		C: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fmt.Println(f1.C == f2.C)  报错，不能进行比较。</span></span><br><span class="line">	fmt.Println(IsEqual(f1.C, f2.C))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsEqual</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> reflect.DeepEqual(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反射定律"><a href="#反射定律" class="headerlink" title="反射定律"></a>反射定律</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		interface 有一个(value，type)对，而反射就是操纵这个 (value，type) 对的机制。</span></span><br><span class="line"><span class="comment">		reflect 中提供了 reflect.Type 和 reflect.Value 两个类型，分别代表 interface 中的 type 和 value。</span></span><br><span class="line"><span class="comment">		通过提供了两个方法来获取 interface 的 type 和 value。TypeOf() 和 ValueOf()。</span></span><br><span class="line"><span class="comment">		我们称 reflect.Type 和 reflect.Value 两个类型为 interface 的反射对象。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一定律：反射可以将 interface 类型变量转换成为反射对象</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	fmt.Println(<span class="string">"type: "</span>, t) <span class="comment">// float64</span></span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	fmt.Println(<span class="string">"value: "</span>, v) <span class="comment">// 3.4</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二定律：反射可以将反射对象还原成 interface 对象</span></span><br><span class="line">	<span class="keyword">var</span> A <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	A = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	z := reflect.ValueOf(A)</span><br><span class="line">	B := z.Interface()  <span class="comment">// 将反射对象还原为 interface 对象</span></span><br><span class="line">	fmt.Println(A == B) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三定律：反射对象可修改，value 值必须是可设置的。</span></span><br><span class="line">	<span class="keyword">var</span> k <span class="keyword">float64</span> = <span class="number">54</span></span><br><span class="line">	i := reflect.ValueOf(&amp;k)</span><br><span class="line">	i.Elem().SetFloat(<span class="number">89.1</span>)</span><br><span class="line">	fmt.Println(k)                    <span class="comment">// 89.1</span></span><br><span class="line">	fmt.Println(i.Elem().Interface()) <span class="comment">// 89.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		逃逸分析是指由编译器决定内存分配的位置：</span></span><br><span class="line"><span class="comment">		1. 如果分配在栈中，则函数执行完成后可自动将内存回收。</span></span><br><span class="line"><span class="comment">		2. 如果分配在堆中，则函数执行完成后需要交给 GC（垃圾回收）处理。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		逃逸策略：</span></span><br><span class="line"><span class="comment">		1. 如果函数外部没有引用，则优先放到栈中。（也可能放到堆中，比如栈空间不足的时候）</span></span><br><span class="line"><span class="comment">		1. 如果函数外部有引用，则一定放到堆中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		总结：</span></span><br><span class="line"><span class="comment">		1. 栈上分配内存比在堆中分配内存有更高的效率</span></span><br><span class="line"><span class="comment">		2. 栈上分配内存不需要处理GC</span></span><br><span class="line"><span class="comment">		3. 堆上分配的内存使用完毕会交给GC处理</span></span><br><span class="line"><span class="comment">		4. 逃逸分析的目的是决定分配地址是栈还是堆</span></span><br><span class="line"><span class="comment">		5. 逃逸分析在编译阶段完成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		注意：</span></span><br><span class="line"><span class="comment">		函数传递指针真的比传值效率更高吗？</span></span><br><span class="line"><span class="comment">		答案是否定的，传递指针的确可以减少底层的复制，但是如果复制的数据很小，由于传递指针会产生逃逸，则可能会使用堆，可能会增加GC的负担</span></span><br><span class="line"><span class="comment">		所以函数传递指针不一定比传值效率更高。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 逃逸场景1，指针逃逸</span></span><br><span class="line">	RegisterStudent(<span class="string">"rex"</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 逃逸场景2，栈空间不足发生逃逸</span></span><br><span class="line">	Slice()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 逃逸场景3，动态类型逃逸</span></span><br><span class="line">	Demo()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 闭包饮用对象逃逸</span></span><br><span class="line">	f := Fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d\n"</span>, f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">new</span>(Student)</span><br><span class="line">	s.Age = age</span><br><span class="line">	s.Name = name</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		s为局部变量，其通过函数返回值返回，s本身是一个指针，指向的内存地址是堆。</span></span><br><span class="line"><span class="comment">		go build -gcflags=-m</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		# go_zhuanjia/escape</span></span><br><span class="line"><span class="comment">		./main.go:23:6: can inline RegisterStudent</span></span><br><span class="line"><span class="comment">		./main.go:3:6: can inline main</span></span><br><span class="line"><span class="comment">		./main.go:14:17: inlining call to RegisterStudent</span></span><br><span class="line"><span class="comment">		./main.go:14:17: new(Student) does not escape</span></span><br><span class="line"><span class="comment">		./main.go:23:22: leaking param: name</span></span><br><span class="line"><span class="comment">		./main.go:24:10: new(Student) escapes to heap</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		切片空间太大发生逃逸</span></span><br><span class="line"><span class="comment">		go build -gcflags=-m</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		# go_zhuanjia/escape</span></span><br><span class="line"><span class="comment">		./main.go:45:6: can inline Slice</span></span><br><span class="line"><span class="comment">		./main.go:3:6: can inline main</span></span><br><span class="line"><span class="comment">		./main.go:17:7: inlining call to Slice</span></span><br><span class="line"><span class="comment">		./main.go:26:6: can inline RegisterStudent</span></span><br><span class="line"><span class="comment">		./main.go:17:7: make([]int, 10000, 10000) escapes to heap</span></span><br><span class="line"><span class="comment">		./main.go:26:22: leaking param: name</span></span><br><span class="line"><span class="comment">		./main.go:27:10: new(Student) escapes to heap</span></span><br><span class="line"><span class="comment">		./main.go:47:11: make([]int, 10000, 10000) escapes to heap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">	<span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[index] = index</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"demo"</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		很多函数的参数类型都是 interface，编译期间很难确定其具体的类型，也会发生逃逸</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		a b 本来是局部变量，但因为闭包的饮用，所以不得不将其二者放到堆中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		a, b = b, a+b</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="timer-amp-ticker"><a href="#timer-amp-ticker" class="headerlink" title="timer &amp; ticker"></a>timer &amp; ticker</h3><h4 id="一次性定时器-Timer"><a href="#一次性定时器-Timer" class="headerlink" title="一次性定时器 Timer"></a>一次性定时器 Timer</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// time.NewTimer(d) 创建一个 Timer，Timer 定义的数据结构如下：</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		type Timer struct &#123;</span></span><br><span class="line"><span class="comment">			C &lt;-chan Time</span></span><br><span class="line"><span class="comment">			r runtimeTimer</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		Timer 对外只暴露了一个 channel，指定时间到了就会往该 channel 中写入系统时间。</span></span><br><span class="line"><span class="comment">		根据此特性，有以下执行场景：1. 设置超时时间，2. 或者延迟执行某个方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 1. 设置超时时间</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	WaitChannel(ch)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 延迟执行某个方法</span></span><br><span class="line">	DelayFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitChannel</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	timer := time.NewTimer(time.Second * <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch: <span class="comment">// 等待业务channel 的数据，如果超过1s还没有收到，则执行下面的 case</span></span><br><span class="line">		timer.Stop()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-timer.C: <span class="comment">// 业务 channel 超过1s还没有收到，则执行</span></span><br><span class="line">		fmt.Println(<span class="string">"WaitChannel timeout!"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DelayFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	timer := time.NewTimer(time.Second * <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">		fmt.Println(<span class="string">"延迟执行方法"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Timer-对外暴露的接口"><a href="#Timer-对外暴露的接口" class="headerlink" title="Timer 对外暴露的接口"></a>Timer 对外暴露的接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建定时器</span></span><br><span class="line">	timer := time.NewTimer(time.Second * <span class="number">5</span>) <span class="comment">// NewTimer 会创建一个新的 Timer 交给系统协程监控。</span></span><br><span class="line">	fmt.Println(timer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 停止计时器</span></span><br><span class="line">	timer.Stop() <span class="comment">// 返回 true 则表示定时器超前停止，后续不会在发送事件。返回 false 则代表定时器超时。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 重置定时器</span></span><br><span class="line">	timer.Reset(time.Second * <span class="number">5</span>) <span class="comment">// 重置计时器。其原理是先停止以前的，然后在新注册。使用时要注意，一般只有过期的定时器才能重置（没过期的也能，但肯能出现正在执行的问题）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单接口创建-Timer"><a href="#简单接口创建-Timer" class="headerlink" title="简单接口创建 Timer"></a>简单接口创建 Timer</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面的是标准的创建 Timer 的方式。还可以通过 time 中提供的简单的方法来创建 Timer。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// After</span></span><br><span class="line">	log.Println(time.Now())</span><br><span class="line">	time.After(time.Second * <span class="number">2</span>)</span><br><span class="line">	log.Println(time.Now())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AfterFunc</span></span><br><span class="line">	log.Println(time.Now())</span><br><span class="line">	time.AfterFunc(time.Second*<span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		log.Println(<span class="string">"AfterFunc End!"</span>, time.Now())</span><br><span class="line">	&#125;)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// 等待协程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Timer-实现原理"><a href="#Timer-实现原理" class="headerlink" title="Timer 实现原理"></a>Timer 实现原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Timer 数据结构如下所示：</span></span><br><span class="line"><span class="comment">			type Timer struct &#123;</span></span><br><span class="line"><span class="comment">				C &lt;-chan Time</span></span><br><span class="line"><span class="comment">				r runtimeTimer</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		C 是面向 Timer 用户的。r 是面向底层定时器实现的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		runtimeTimer 数据结构如下所示：</span></span><br><span class="line"><span class="comment">			type runtimeTimer struct &#123;</span></span><br><span class="line"><span class="comment">			pp       uintptr  // 系统底层存储 runtimeTimer 数组的地址</span></span><br><span class="line"><span class="comment">			when     int64    // 当前定时器触发时间</span></span><br><span class="line"><span class="comment">			period   int64    // 当前定时器触发间隔。对于 Timer 来说是 0</span></span><br><span class="line"><span class="comment">			f        func(any, uintptr) // 定时器执行时触发的回调函数</span></span><br><span class="line"><span class="comment">			arg      any      // 回调函数第一个参数</span></span><br><span class="line"><span class="comment">			seq      uintptr  // 回调函数第二个参数，Timer 没有。</span></span><br><span class="line"><span class="comment">			nextwhen int64</span></span><br><span class="line"><span class="comment">			status   uint32</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		创建 Timer 源码如下：</span></span><br><span class="line"><span class="comment">			func NewTimer(d Duration) *Timer &#123;</span></span><br><span class="line"><span class="comment">				c := make(chan Time, 1)   // 创建 channel，空间为1</span></span><br><span class="line"><span class="comment">				t := &amp;Timer&#123;</span></span><br><span class="line"><span class="comment">					C: c,                 // 用户可见的 C，就是一个 channel</span></span><br><span class="line"><span class="comment">					r: runtimeTimer&#123;      // 用户不可见的r</span></span><br><span class="line"><span class="comment">						when: when(d),    // Timer 的执行时间</span></span><br><span class="line"><span class="comment">						f:    sendTime,   // Timer 执行的回调函数</span></span><br><span class="line"><span class="comment">						arg:  c,          // Timer 执行的回调函数的参数</span></span><br><span class="line"><span class="comment">					&#125;,</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				startTimer(&amp;t.r)          // 启动 Timer</span></span><br><span class="line"><span class="comment">				return t</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		停止 Timer 源码如下：</span></span><br><span class="line"><span class="comment">			func (t *Timer) Stop() bool &#123;</span></span><br><span class="line"><span class="comment">				if t.r.f == nil &#123;</span></span><br><span class="line"><span class="comment">					panic("time: Stop called on uninitialized Timer")</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				return stopTimer(&amp;t.r)</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		重置 Timer 源码如下：</span></span><br><span class="line"><span class="comment">			func (t *Timer) Reset(d Duration) bool &#123;</span></span><br><span class="line"><span class="comment">				if t.r.f == nil &#123;</span></span><br><span class="line"><span class="comment">					panic("time: Reset called on uninitialized Timer")</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				w := when(d)</span></span><br><span class="line"><span class="comment">				return resetTimer(&amp;t.r, w)</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="周期性定时器-Ticker"><a href="#周期性定时器-Ticker" class="headerlink" title="周期性定时器 Ticker"></a>周期性定时器 Ticker</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建定时器</span></span><br><span class="line">	ticker := time.NewTicker(time.Second * <span class="number">2</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 停止定时器</span></span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop() <span class="comment">// Ticker 在使用完成之后必须要释放，否则会产生资源泄露。进而消耗 CPU 的资源。</span></span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">		fmt.Println(<span class="string">"2s 一次"</span>)</span><br><span class="line">		count += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Ticker-实现原理"><a href="#Ticker-实现原理" class="headerlink" title="Ticker 实现原理"></a>Ticker 实现原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Ticker 数据结构如下所示：</span></span><br><span class="line"><span class="comment">			type Ticker struct &#123;</span></span><br><span class="line"><span class="comment">				C &lt;-chan Time</span></span><br><span class="line"><span class="comment">				r runtimeTimer</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		C 是面向 Timer 用户的。r 是面向底层定时器实现的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		runtimeTimer 数据结构如下所示：</span></span><br><span class="line"><span class="comment">			type runtimeTimer struct &#123;</span></span><br><span class="line"><span class="comment">			pp       uintptr  // 系统底层存储 runtimeTimer 数组的地址</span></span><br><span class="line"><span class="comment">			when     int64    // 当前定时器触发时间</span></span><br><span class="line"><span class="comment">			period   int64    // 当前定时器触发间隔</span></span><br><span class="line"><span class="comment">			f        func(any, uintptr) // 定时器执行时触发的回调函数</span></span><br><span class="line"><span class="comment">			arg      any      // 回调函数第一个参数</span></span><br><span class="line"><span class="comment">			seq      uintptr  // 回调函数第二个参数</span></span><br><span class="line"><span class="comment">			nextwhen int64</span></span><br><span class="line"><span class="comment">			status   uint32</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		创建 Ticker 源码如下：</span></span><br><span class="line"><span class="comment">			func NewTicker(d Duration) *Ticker &#123;</span></span><br><span class="line"><span class="comment">				c := make(chan Time, 1)   // 创建 channel，空间为1</span></span><br><span class="line"><span class="comment">				t := &amp;Ticker&#123;</span></span><br><span class="line"><span class="comment">					C: c,                 // 用户可见的 C，就是一个 channel</span></span><br><span class="line"><span class="comment">					r: runtimeTimer&#123;      // 用户不可见的r</span></span><br><span class="line"><span class="comment">						when: when(d),    // Ticker 的执行时间</span></span><br><span class="line"><span class="comment">						period: int64(d), // 和 Timer 的区别就在这里，Ticker 有间隔。</span></span><br><span class="line"><span class="comment">						f:    sendTime,   // Ticker 执行的回调函数</span></span><br><span class="line"><span class="comment">						arg:  c,          // Ticker 执行的回调函数的参数</span></span><br><span class="line"><span class="comment">					&#125;,</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				startTicker(&amp;t.r)          // 启动 Ticker</span></span><br><span class="line"><span class="comment">				return t</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		停止 Ticker 源码如下：</span></span><br><span class="line"><span class="comment">			func (t *Ticker) Stop() &#123;</span></span><br><span class="line"><span class="comment">				stopTimer(&amp;t.r)</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		重置 Ticker 源码如下：</span></span><br><span class="line"><span class="comment">			func (t *Ticker) Reset(d Duration) &#123;</span></span><br><span class="line"><span class="comment">				if d &lt;= 0 &#123;</span></span><br><span class="line"><span class="comment">					panic("non-positive interval for Ticker.Reset")</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				if t.r.f == nil &#123;</span></span><br><span class="line"><span class="comment">					panic("time: Reset called on uninitialized Ticker")</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">				modTimer(&amp;t.r, when(d), int64(d), t.r.f, t.r.arg, t.r.seq)</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">defer 关键字只能作用域函数或者函数调用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	1. 后接一个匿名函数</span></span><br><span class="line"><span class="comment">	defer func() &#123;</span></span><br><span class="line"><span class="comment">		fmt.Println("hello!")</span></span><br><span class="line"><span class="comment">	&#125;()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	2. 后接一个函数调用</span></span><br><span class="line"><span class="comment">	file, err := os.Open("name")</span></span><br><span class="line"><span class="comment">	if err != nil &#123;</span></span><br><span class="line"><span class="comment">		return nil, err</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	defer file.Close()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	3. 释放资源</span></span><br><span class="line"><span class="comment">	m.mutex.Lock()</span></span><br><span class="line"><span class="comment">	defer m.mutex.Unlock()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	4. 流程控制</span></span><br><span class="line"><span class="comment">	var wg sync.WaitGroup</span></span><br><span class="line"><span class="comment">	defer wg.Wait()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	5. 异常处理</span></span><br><span class="line"><span class="comment">	defer func() &#123;</span></span><br><span class="line"><span class="comment">		recover() // recover 只能用于 defer 函数中</span></span><br><span class="line"><span class="comment">	&#125;()</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="行为规则"><a href="#行为规则" class="headerlink" title="行为规则"></a>行为规则</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1。defer 定义的延迟函数参数在 defer 语句出现时就已经确定了</span></span><br><span class="line"><span class="comment">2。defer 定义的顺序与实际的执行顺序相反</span></span><br><span class="line"><span class="comment">3。return 操作不是原子操作，执行过程是：保存返回值(若有) -&gt; 执行defer(若有) -&gt; 执行 ret 跳转。</span></span><br><span class="line"><span class="comment">4。申请资源后立即使用 defer 关闭资源是一个好习惯。</span></span><br><span class="line"><span class="comment">5。编译器会把每个延迟函数编译为一个 _defer 实例暂存到 goroutine 数据结构中，待函数结束后再逐个取出执行。每个 defer 语句对应一个 _defer 实例，多个实例形成一个链表，保存到 goroutine 数据结构中。每次插入 _defer 实例均插入链表头部，函数执行结束再依次从头部取出，从而实现后进先出的效果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里的打印结果还是0，原因是 defer 定义的延迟函数参数在 defer 语句出现时就已经确定了。</span></span><br><span class="line"><span class="comment">	func a() &#123;</span></span><br><span class="line"><span class="comment">		i := 0</span></span><br><span class="line"><span class="comment">		defer fmt.Println(i)</span></span><br><span class="line"><span class="comment">		i++</span></span><br><span class="line"><span class="comment">		return</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	==============================</span></span><br><span class="line"><span class="comment">	定义 defer 的函数(主函数) 可能有返回值，返回值可能有名称(具名返回值)，也可能没有返回值(匿名返回值)，延迟函数可能会影响返回值。</span></span><br><span class="line"><span class="comment">	关键字 return 并不是一个原子操作，比如 return i，实际上分为两步执行。</span></span><br><span class="line"><span class="comment">		1. 先将 i 值存入栈中作为返回值</span></span><br><span class="line"><span class="comment">		2. 然后执行跳转。而 defer 的执行正是在跳转之前。</span></span><br><span class="line"><span class="comment">	所以，defer 执行时还是有机会操作返回值的。例如：</span></span><br><span class="line"><span class="comment">	func deferFuncReturn() (result int) &#123;</span></span><br><span class="line"><span class="comment">		i := 1</span></span><br><span class="line"><span class="comment">		defer func() &#123;</span></span><br><span class="line"><span class="comment">			result++</span></span><br><span class="line"><span class="comment">		&#125;()</span></span><br><span class="line"><span class="comment">		return i</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	该函数的 return 语句可以拆分为下面两行：</span></span><br><span class="line"><span class="comment">	result = i</span></span><br><span class="line"><span class="comment">	return</span></span><br><span class="line"><span class="comment">	而延迟函数正是在执行 return 之前运行的。即加入 defer 之后执行过程如下：</span></span><br><span class="line"><span class="comment">	result = i</span></span><br><span class="line"><span class="comment">	result++</span></span><br><span class="line"><span class="comment">	return</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	============ 主函数拥有匿名返回值，返回字面值 ============</span></span><br><span class="line"><span class="comment">	func foo() int &#123;</span></span><br><span class="line"><span class="comment">		var i int</span></span><br><span class="line"><span class="comment">		defer func() &#123;</span></span><br><span class="line"><span class="comment">			i++</span></span><br><span class="line"><span class="comment">		&#125;()</span></span><br><span class="line"><span class="comment">		return 10</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	上面的函数 return 函数直接把 10 写入栈作为返回值。延迟函数无法操作返回值，所以就无法影响返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	============ 主函数拥有匿名返回值，返回变量 ============</span></span><br><span class="line"><span class="comment">	一个函数拥有一个匿名返回值，返回本地或者全局变量，这种情况下 defer 语句可以引用返回值，但是不会改变返回值。</span></span><br><span class="line"><span class="comment">	例如，一个返回本地变量的函数如下：</span></span><br><span class="line"><span class="comment">	func foo() int &#123;</span></span><br><span class="line"><span class="comment">		var i int</span></span><br><span class="line"><span class="comment">		defer func() &#123;</span></span><br><span class="line"><span class="comment">			i++</span></span><br><span class="line"><span class="comment">		&#125;()</span></span><br><span class="line"><span class="comment">		return i</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	对于匿名函数的返回值，可以假设有一个变量存储返回值，假设返回值变量为 anony，则上面的返回语句可以拆分为：</span></span><br><span class="line"><span class="comment">	anony = i</span></span><br><span class="line"><span class="comment">	i++</span></span><br><span class="line"><span class="comment">	return</span></span><br><span class="line"><span class="comment">	由于 i 是整型值，会将值赋给 anony，所以在 defer 语句中修改 i值，不会对函数返回值造成影响。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	============ 主函数拥有具名返回值 ============</span></span><br><span class="line"><span class="comment">	func foo() (ret int) &#123;</span></span><br><span class="line"><span class="comment">		defer func() &#123;</span></span><br><span class="line"><span class="comment">			ret++</span></span><br><span class="line"><span class="comment">		&#125;()</span></span><br><span class="line"><span class="comment">		return 0</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	上面的函数拆解出来如下所示：</span></span><br><span class="line"><span class="comment">	ret = 0</span></span><br><span class="line"><span class="comment">	ret++</span></span><br><span class="line"><span class="comment">	return</span></span><br><span class="line"><span class="comment">	函数真正返回前，在 defer 中对返回值做了 +1 操作，所以函数最终返回 1</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	1. 如果产生了 panic，那么程序会转向执行 defer 函数，当前函数的 defer 函数执行完毕后继续处理上层函数的 defer。当所有 defer 处理完后，程序退出。</span></span><br><span class="line"><span class="comment">	2. panic 不会处理其他协程中的 defer。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	每个协程中都维护了一个 defer 链表，执行过程中每遇到一个 defer 语句都会创建一个 defer 实例并插入链表。函数退出时取出本函数创建的实例并执行。panic 发生时，实际上是把流程转向了这个 defer 链表，程序专注于消费链表中的 defer 函数，当链表中的 defer 函数被消费完，程序在退出。</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// PanicDemo1() // 输出 C，B，A。panic 会触发所有 defer函数，然后panic会被PanicDemo1函数捕获。</span></span><br><span class="line">	<span class="comment">// PanicDemo2() // 输出 C，B，A, 1。panic 会触发所有 defer函数，然后将异常抛给上层调用函数，然后触发上层调用函数的 defer 函数。</span></span><br><span class="line">	<span class="comment">// PanicDemo3() // 输出 C，B，A 后触发 panic。panic 只能触发当前协程的 defer 函数，当前协程的 defer 处理结束后，如果没有 recover，则会引发退出。</span></span><br><span class="line">	<span class="comment">// PanicDemo4() // 输出 B，A。panic 支持嵌套，defer 中可以支持再次触发 panic。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PanicDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">recover</span>()</span><br><span class="line">	&#125;()</span><br><span class="line">	foo1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"demo"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"D"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PanicDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">recover</span>()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"1"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	foo2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"demo"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"D"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PanicDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"demo"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> foo3()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"demo"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"D"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PanicDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">recover</span>()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"panic in defer"</span>)</span><br><span class="line">		fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"D"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	1. recover() 函数调用必须要位于 defer 函数中，且不能出现在另一个嵌套的函数中。</span></span><br><span class="line"><span class="comment">	2. recover() 函数成功处理异常后，无法再次回到本函数发生 panic 的位置继续执行。</span></span><br><span class="line"><span class="comment">	3. recover() 函数可以消除本函数产生或收到的 panic，上游函数感知不到 panic 的发生。</span></span><br><span class="line"><span class="comment">	4. 当发生 panic 并用 recover() 恢复后。对于匿名返回值，函数将返回相应类型的零值。对于具名返回值，函数将返回当前已经存在的值。</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// RecoverDemo1() // A。panic 在 defer中被捕获并消除，panic 之后语句并不会执行。</span></span><br><span class="line">	<span class="comment">// RecoverDemo2() // 发生 panic，打印错误堆栈。函数中的 recover() 并不能捕获 panic，所以函数最终发生 panic。</span></span><br><span class="line">	<span class="comment">// RecoverDemo3() // A, C。函数panic之后依次执行 defer 函数，所以输出 A，C</span></span><br><span class="line">	<span class="comment">// RecoverDemo4() // B。函数中的panic被 recover() 消除后，无法继续使用 recover() 捕获。所以最后输出 B。</span></span><br><span class="line">	<span class="comment">// RecoverDemo5() // 0。匿名返回值，返回函数将返回相应类型的零值。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecoverDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"demo"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecoverDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"demo"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecoverDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"demo"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecoverDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"demo"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecoverDemo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">	foo := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">recover</span>()</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"demo"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret := foo()</span><br><span class="line">	fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="error-的创建"><a href="#error-的创建" class="headerlink" title="error 的创建"></a>error 的创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. error 是一种内建的接口类型，不需要 import 即可使用。</span></span><br><span class="line"><span class="comment">2. error 接口只声明了一个 Error() 方法，所以只要任何实现了该方法的结构体，都可以当作 error 来使用。</span></span><br><span class="line"><span class="comment">   error 的实例代表了一种异常的状态。Error() 方法用于描述该异常状态。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 3. 创建 error</span></span><br><span class="line">	<span class="comment">// 方法1</span></span><br><span class="line">	errors.New(<span class="string">"new error"</span>)</span><br><span class="line">	<span class="comment">// 方法2</span></span><br><span class="line">	fmt.Errorf(<span class="string">"file not found, file name: %s"</span>, <span class="string">"1.txt"</span>)</span><br><span class="line">	<span class="comment">// 如果不需要格式化字符串，那么使用 errors.New 效率更高。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检查-error"><a href="#检查-error" class="headerlink" title="检查 error"></a>检查 error</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := errors.New(<span class="string">"test error"</span>)</span><br><span class="line">	<span class="comment">// 1. 最简单的检查，是与 nil 比较</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 与预定义的 err 进行比较</span></span><br><span class="line">	ErrPermission := errors.New(<span class="string">"permission denied"</span>)</span><br><span class="line">	<span class="keyword">if</span> err == ErrPermission &#123;</span><br><span class="line">		fmt.Println(<span class="string">"permission error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 断言</span></span><br><span class="line">	<span class="keyword">if</span> e, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"PathError, operation: %s, path: %s. msg :%v"</span>, e.Op, e.Path, e.Err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="传递-error"><a href="#传递-error" class="headerlink" title="传递 error"></a>传递 error</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">传递 error：</span></span><br><span class="line"><span class="comment">	1. 在 go 1.13 以前，使用 fmt.Errorf("permission error %v", err) 来传递 error。这种做法的弊端是会丢失以前的 error 信息。</span></span><br><span class="line"><span class="comment">	2. 在 go 1.13 以后，新增了一个 error 类型，wrapError。wrapError 和 errorString 相比，还额外实现了 Unwrap() 接口。用于返回原始的 error 信息。</span></span><br><span class="line"><span class="comment">	3. 在 go 1.13 以后，增强了 fmt.Errorf()，可以通过 %w 来创建 wrapError 类型的 error。</span></span><br><span class="line"><span class="comment">	4. 在 go 1.13 以后，引入了 errors.Unwrap() 来拆解 wrapError</span></span><br><span class="line"><span class="comment">	5. 在 go 1.13 以后，引入了 errors.ls() 来检测 error传递链中是否包含指定的错误值。</span></span><br><span class="line"><span class="comment">	6. 在 go 1.13 以后，引入了 errors.As() 来检测 error传递链中是否包含指定的错误类型。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. Errorf 源码</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	func Errorf(format string, a ...any) error &#123;</span></span><br><span class="line"><span class="comment">		p := newPrinter()</span></span><br><span class="line"><span class="comment">		p.wrapErrs = true</span></span><br><span class="line"><span class="comment">		p.doPrintf(format, a)  解析格式，如果发现 %w 动词，且提供了合法的 error 参数，那么就将 error 放入到 p.wrappedErr 中</span></span><br><span class="line"><span class="comment">		s := string(p.buf)</span></span><br><span class="line"><span class="comment">		var err error</span></span><br><span class="line"><span class="comment">		if p.wrappedErr == nil &#123;   没有动词 %w，生成基础的 error</span></span><br><span class="line"><span class="comment">			err = errors.New(s)</span></span><br><span class="line"><span class="comment">		&#125; else &#123;				   有动词 %w，生成 wrapError</span></span><br><span class="line"><span class="comment">			err = &amp;wrapError&#123;s, p.wrappedErr&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		p.free()</span></span><br><span class="line"><span class="comment">		return err</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 示例, 判断是否实现了 Unwrap() 接口</span></span><br><span class="line">	err := errors.New(<span class="string">"this is demo error"</span>)</span><br><span class="line">	err2 := fmt.Errorf(<span class="string">"same context: %v"</span>, err)</span><br><span class="line">	<span class="keyword">if</span> _, ok := err2.(<span class="keyword">interface</span>&#123; Unwrap() error &#125;); !ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">"未实现 Unwrap() 接口"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err3 := fmt.Errorf(<span class="string">"same context: %w"</span>, err)</span><br><span class="line">	<span class="keyword">if</span> _, ok := err3.(<span class="keyword">interface</span>&#123; Unwrap() error &#125;); ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">"实现了 Unwrap() 接口"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链式-error-使用注意事项"><a href="#链式-error-使用注意事项" class="headerlink" title="链式 error 使用注意事项"></a>链式 error 使用注意事项</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在使用 fmt.Errorf("permission error %w", err) 来创建一个链式 error 时，需要注意以下问题：</span></span><br><span class="line"><span class="comment">	1. 每次只能接收一个 %w</span></span><br><span class="line"><span class="comment">	2. %w 只匹配 error 参数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := errors.New(<span class="string">"demo error"</span>)</span><br><span class="line">	<span class="comment">// 这样不行，每次只能接收一个 %w</span></span><br><span class="line">	fmt.Errorf(<span class="string">"permission error %w, %w"</span>, err, err)</span><br><span class="line">	<span class="comment">// 这样也不行，%w 只匹配 error 参数</span></span><br><span class="line">	fmt.Errorf(<span class="string">"permission error %w"</span>, <span class="string">"this is text content"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Unwrap-Is-As-的用法"><a href="#Unwrap-Is-As-的用法" class="headerlink" title="Unwrap Is As 的用法"></a>Unwrap Is As 的用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果把 error 比作一件衣服，fmt.Errorf("xxx", %w) 就好比给 error 增加了一件外套。而 Unwrap() 函数则是脱下外套。</span></span><br><span class="line">	<span class="comment">// errors.Unwrap() 源码如下：</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	func Unwrap(err error) error &#123;</span></span><br><span class="line"><span class="comment">		u, ok := err.(interface &#123;   判断 err 是否实现了 Unwrap 方法</span></span><br><span class="line"><span class="comment">			Unwrap() error</span></span><br><span class="line"><span class="comment">		&#125;)</span></span><br><span class="line"><span class="comment">		if !ok &#123;</span></span><br><span class="line"><span class="comment">			return nil</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		return u.Unwrap()</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// errors.Unwrap 使用示例</span></span><br><span class="line">	err := fmt.Errorf(<span class="string">"write file error: %w"</span>, os.ErrPermission)</span><br><span class="line">	<span class="keyword">if</span> errors.Unwrap(err) == os.ErrPermission &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Permission denied"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// errors.ls 使用示例。</span></span><br><span class="line">	<span class="comment">// errors.Is 用户判断 error 链中是否包含指定的 error 值。</span></span><br><span class="line">	err2 := fmt.Errorf(<span class="string">"write file error: %w"</span>, os.ErrPermission)</span><br><span class="line">	err3 := fmt.Errorf(<span class="string">"write file error: %w"</span>, err2)</span><br><span class="line">	<span class="keyword">if</span> errors.Is(err3, os.ErrPermission) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Permission denied"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// errors.As 使用示例。</span></span><br><span class="line">	<span class="comment">// errors.As 用户判断 error 链中是否有指定类型出现，如果有，则把 error 转换成该类型。</span></span><br><span class="line"></span><br><span class="line">	err4 := &amp;os.PathError&#123;</span><br><span class="line">		Op:   <span class="string">"write"</span>,</span><br><span class="line">		Path: <span class="string">"/root/xxx"</span>,</span><br><span class="line">		Err:  os.ErrPermission,</span><br><span class="line">	&#125;</span><br><span class="line">	err5 := fmt.Errorf(<span class="string">"some context: %w"</span>, err4)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> target *os.PathError</span><br><span class="line">	<span class="comment">// 逐层剥离 err5，并检测 err5 是否是 PathError 类型。</span></span><br><span class="line">	<span class="keyword">if</span> errors.As(err5, &amp;target) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"PathError"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写单元测试时，应该遵守的规则：</span></span><br><span class="line"><span class="comment">1.测试文件名必须以 _test.go 结尾</span></span><br><span class="line"><span class="comment">2.测试函数名必须以 TestXxx 开始</span></span><br><span class="line"><span class="comment">3.在命令行下使用 go test 即可开启测试</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	r := Add(a, b)</span><br><span class="line">	<span class="keyword">if</span> c != r &#123;</span><br><span class="line">		t.Error(<span class="string">"test Add fail"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写性能测试时，应该遵守的规则：</span></span><br><span class="line"><span class="comment">1.测试文件名必须以 _test.go 结尾</span></span><br><span class="line"><span class="comment">2.测试函数名必须以 BenchmarkXxx 开始</span></span><br><span class="line"><span class="comment">3.在命令行下使用 go test -bench=. 即可开启测试</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeSliceWithoutAlloc</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newSlice []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">		newSlice = <span class="built_in">append</span>(newSlice, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newSlice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeSliceWithAlloc</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newSlice []<span class="keyword">int</span></span><br><span class="line">	newSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">		newSlice = <span class="built_in">append</span>(newSlice, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMakeSliceWithoutAlloc</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		MakeSliceWithoutAlloc()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMakeSliceWithAlloc</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		MakeSliceWithAlloc()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例测试"><a href="#示例测试" class="headerlink" title="示例测试"></a>示例测试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1.示例测试函数名需要以 Example 开头</span></span><br><span class="line"><span class="comment">2.检测单行输出格式为 // Output: 期望字符串</span></span><br><span class="line"><span class="comment">3.检测多行输出格式为 // Output: 期望字符串 \n 期望字符串 \n 期望字符串，每个期望字符串占一行</span></span><br><span class="line"><span class="comment">4.检测无序输出格式为 // Unordered output: 期望字符串 \n 期望字符串 \n 期望字符串，每个期望字符串占一行</span></span><br><span class="line"><span class="comment">5.测试字符串时会自动忽略前后的空格</span></span><br><span class="line"><span class="comment">6.如果测试函数中没有 Output 标识，则该测试函数不会被执行</span></span><br><span class="line"><span class="comment">7.执行测试函数时可以使用 go test，此时该目录下的其他测试文件也会一起执行，如果要单独执行，可以使用 go test 文件名。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayGoodBye</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Hello!"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"GoodBye!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintNames</span><span class="params">()</span></span> &#123;</span><br><span class="line">	names := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">4</span>)</span><br><span class="line">	names[<span class="number">1</span>] = <span class="string">"Jim"</span></span><br><span class="line">	names[<span class="number">2</span>] = <span class="string">"Bob"</span></span><br><span class="line">	names[<span class="number">3</span>] = <span class="string">"Tom"</span></span><br><span class="line">	names[<span class="number">4</span>] = <span class="string">"Sue"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">		fmt.Println(name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleSayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	SayHello()</span><br><span class="line">	<span class="comment">// Output: Hello!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleSayGoodBye</span><span class="params">()</span></span> &#123;</span><br><span class="line">	SayGoodBye()</span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// Hello!</span></span><br><span class="line">	<span class="comment">// GoodBye!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExamplePrintNames</span><span class="params">()</span></span> &#123;</span><br><span class="line">	PrintNames()</span><br><span class="line">	<span class="comment">// Unordered output:</span></span><br><span class="line">	<span class="comment">// Jim</span></span><br><span class="line">	<span class="comment">// Bob</span></span><br><span class="line">	<span class="comment">// Sue</span></span><br><span class="line">	<span class="comment">// Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a>子测试</h4><p>普通子测试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	r := Add(a, b)</span><br><span class="line">	<span class="keyword">if</span> c != r &#123;</span><br><span class="line">		t.Error(<span class="string">"test Add fail"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	r := Add(a, b)</span><br><span class="line">	<span class="keyword">if</span> c != r &#123;</span><br><span class="line">		t.Error(<span class="string">"test Add fail"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub3</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	r := Add(a, b)</span><br><span class="line">	<span class="keyword">if</span> c != r &#123;</span><br><span class="line">		t.Error(<span class="string">"test Add fail"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSub</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Run(<span class="string">"sub1"</span>, sub1)</span><br><span class="line">	t.Run(<span class="string">"sub2"</span>, sub2)</span><br><span class="line">	t.Run(<span class="string">"sub3"</span>, sub3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">=== RUN   TestSub</span></span><br><span class="line"><span class="comment">=== RUN   TestSub/sub1</span></span><br><span class="line"><span class="comment">=== RUN   TestSub/sub2</span></span><br><span class="line"><span class="comment">=== RUN   TestSub/sub3</span></span><br><span class="line"><span class="comment">--- PASS: TestSub (0.00s)</span></span><br><span class="line"><span class="comment">    --- PASS: TestSub/sub1 (0.00s)</span></span><br><span class="line"><span class="comment">    --- PASS: TestSub/sub2 (0.00s)</span></span><br><span class="line"><span class="comment">    --- PASS: TestSub/sub3 (0.00s)</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>并发子测试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parallelTest1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Parallel()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parallelTest2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Parallel()</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parallelTest3</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Parallel()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSubParallel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Run(<span class="string">"group"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		t.Run(<span class="string">"Test1"</span>, parallelTest1)</span><br><span class="line">		t.Run(<span class="string">"Test2"</span>, parallelTest2)</span><br><span class="line">		t.Run(<span class="string">"Test3"</span>, parallelTest3)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/02/Python文件变成so文件/" rel="prev" title="Python文件变成so文件">
      <i class="fa fa-chevron-left"></i> Python文件变成so文件
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/13/Go 并发编程-1.Mutex/" rel="next" title="Go 并发编程-1.Mutex">
      Go 并发编程-1.Mutex <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Slice-切片"><span class="nav-number">1.</span> <span class="nav-text">Slice 切片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建"><span class="nav-number">1.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#追加操作"><span class="nav-number">1.2.</span> <span class="nav-text">追加操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现原理"><span class="nav-number">1.3.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容"><span class="nav-number">1.4.</span> <span class="nav-text">扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#切片表达式"><span class="nav-number">1.5.</span> <span class="nav-text">切片表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-字符串"><span class="nav-number">2.</span> <span class="nav-text">String 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项"><span class="nav-number">2.1.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">3.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-1"><span class="nav-number">3.1.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现原理-1"><span class="nav-number">3.2.</span> <span class="nav-text">实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iota"><span class="nav-number">4.</span> <span class="nav-text">iota</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#取值规则"><span class="nav-number">4.1.</span> <span class="nav-text">取值规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Struct-结构体"><span class="nav-number">5.</span> <span class="nav-text">Struct 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取-tag-信息"><span class="nav-number">5.1.</span> <span class="nav-text">获取 tag 信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-通道"><span class="nav-number">6.</span> <span class="nav-text">Channel 通道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建，以及触发nil情况"><span class="nav-number">6.1.</span> <span class="nav-text">创建，以及触发nil情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单向管道"><span class="nav-number">6.2.</span> <span class="nav-text">单向管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select-和管道"><span class="nav-number">6.3.</span> <span class="nav-text">select 和管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-range-和管道"><span class="nav-number">6.4.</span> <span class="nav-text">for-range 和管道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Select"><span class="nav-number">7.</span> <span class="nav-text">Select</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特性"><span class="nav-number">7.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道返回值"><span class="nav-number">7.2.</span> <span class="nav-text">管道返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#default"><span class="nav-number">7.3.</span> <span class="nav-text">default</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用示例"><span class="nav-number">7.4.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">8.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#channel"><span class="nav-number">8.1.</span> <span class="nav-text">channel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WaitGroup"><span class="nav-number">8.2.</span> <span class="nav-text">WaitGroup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#context"><span class="nav-number">8.3.</span> <span class="nav-text">context</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cancelCtx"><span class="nav-number">8.4.</span> <span class="nav-text">cancelCtx</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timerCtx"><span class="nav-number">8.5.</span> <span class="nav-text">timerCtx</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#valueCtx"><span class="nav-number">8.6.</span> <span class="nav-text">valueCtx</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射"><span class="nav-number">9.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#比较两个结构体变量"><span class="nav-number">9.1.</span> <span class="nav-text">比较两个结构体变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反射定律"><span class="nav-number">9.2.</span> <span class="nav-text">反射定律</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逃逸分析"><span class="nav-number">10.</span> <span class="nav-text">逃逸分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timer-amp-ticker"><span class="nav-number">11.</span> <span class="nav-text">timer &amp; ticker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一次性定时器-Timer"><span class="nav-number">11.1.</span> <span class="nav-text">一次性定时器 Timer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timer-对外暴露的接口"><span class="nav-number">11.2.</span> <span class="nav-text">Timer 对外暴露的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单接口创建-Timer"><span class="nav-number">11.3.</span> <span class="nav-text">简单接口创建 Timer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timer-实现原理"><span class="nav-number">11.4.</span> <span class="nav-text">Timer 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#周期性定时器-Ticker"><span class="nav-number">11.5.</span> <span class="nav-text">周期性定时器 Ticker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ticker-实现原理"><span class="nav-number">11.6.</span> <span class="nav-text">Ticker 实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer"><span class="nav-number">12.</span> <span class="nav-text">defer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">12.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行为规则"><span class="nav-number">12.2.</span> <span class="nav-text">行为规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#panic"><span class="nav-number">13.</span> <span class="nav-text">panic</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-2"><span class="nav-number">13.1.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用示例-1"><span class="nav-number">13.2.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recover"><span class="nav-number">14.</span> <span class="nav-text">recover</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项-3"><span class="nav-number">14.1.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用示例-2"><span class="nav-number">14.2.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理"><span class="nav-number">15.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#error-的创建"><span class="nav-number">15.1.</span> <span class="nav-text">error 的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检查-error"><span class="nav-number">15.2.</span> <span class="nav-text">检查 error</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递-error"><span class="nav-number">15.3.</span> <span class="nav-text">传递 error</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链式-error-使用注意事项"><span class="nav-number">15.4.</span> <span class="nav-text">链式 error 使用注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unwrap-Is-As-的用法"><span class="nav-number">15.5.</span> <span class="nav-text">Unwrap Is As 的用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试"><span class="nav-number">16.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单元测试"><span class="nav-number">16.1.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能测试"><span class="nav-number">16.2.</span> <span class="nav-text">性能测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例测试"><span class="nav-number">16.3.</span> <span class="nav-text">示例测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子测试"><span class="nav-number">16.4.</span> <span class="nav-text">子测试</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rex"
      src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
  <p class="site-author-name" itemprop="name">Rex</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">446</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa-hand-o-right"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rex</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
