<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rexyan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"top","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="摘要《100 Go Mistakes and How to Avoid Them》一本关于 Go 语言中常见错误的书籍，在于介绍和让我们不再陷入这些陷阱当中。书 2022 年 8月出版，国内目前还没有中文版本，花了几周的地铁时间，终于陆陆续续看完了。 涉及的代码仓库：https://github.com/rexyan/100-Go-Mistakes">
<meta property="og:type" content="article">
<meta property="og:title" content="100 Go Mistakes">
<meta property="og:url" content="https://rexyan.github.io/2023/08/02/100 Go Mistakes/index.html">
<meta property="og:site_name" content="星尘">
<meta property="og:description" content="摘要《100 Go Mistakes and How to Avoid Them》一本关于 Go 语言中常见错误的书籍，在于介绍和让我们不再陷入这些陷阱当中。书 2022 年 8月出版，国内目前还没有中文版本，花了几周的地铁时间，终于陆陆续续看完了。 涉及的代码仓库：https://github.com/rexyan/100-Go-Mistakes">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032150361.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032151555.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032202705.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032218861.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308061018957.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308061027915.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308082155084.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308142134038.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308152148145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308152147814.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308152153139.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308191015329.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308191252346.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308192143378.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308212055921.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308232117401.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308232138776.png">
<meta property="og:updated_time" content="2025-10-31T03:20:39.382Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="100 Go Mistakes">
<meta name="twitter:description" content="摘要《100 Go Mistakes and How to Avoid Them》一本关于 Go 语言中常见错误的书籍，在于介绍和让我们不再陷入这些陷阱当中。书 2022 年 8月出版，国内目前还没有中文版本，花了几周的地铁时间，终于陆陆续续看完了。 涉及的代码仓库：https://github.com/rexyan/100-Go-Mistakes">
<meta name="twitter:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032150361.png">

<link rel="canonical" href="https://rexyan.github.io/2023/08/02/100 Go Mistakes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>100 Go Mistakes | 星尘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css" />
  <!-- 自定义为霞鹜文楷字体 -->
  <style>
	  body,div.post-body,h1,h2,h3,h4 {
		font-family: "LXGW WenKai Screen", sans-serif;
		font-size: 104%;
	  }
  </style>
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">星尘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-读书">

    <a href="/books/" rel="section"><i class="address-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-瞎扯">

    <a href="/crap/" rel="section"><i class="crap fa-fw"></i>瞎扯</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



<script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script>

<meta name="referrer" content="never">




  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rexyan.github.io/2023/08/02/100 Go Mistakes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
      <meta itemprop="name" content="Rex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星尘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          100 Go Mistakes
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-02 23:04:57" itemprop="dateCreated datePublished" datetime="2023-08-02T23:04:57+00:00">2023-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-31 03:20:39" itemprop="dateModified" datetime="2025-10-31T03:20:39+00:00">2025-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/阅读/" itemprop="url" rel="index"><span itemprop="name">阅读</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><a href="https://www.manning.com/books/100-go-mistakes-and-how-to-avoid-them" target="_blank" rel="noopener">《100 Go Mistakes and How to Avoid Them》</a>一本关于 Go 语言中常见错误的书籍，在于介绍和让我们不再陷入这些陷阱当中。书 2022 年 8月出版，国内目前还没有中文版本，花了几周的地铁时间，终于陆陆续续看完了。</p>
<p>涉及的代码仓库：<a href="https://github.com/rexyan/100-Go-Mistakes" target="_blank" rel="noopener">https://github.com/rexyan/100-Go-Mistakes</a></p>
<a id="more"></a>
<h3 id="变量屏蔽"><a href="#变量屏蔽" class="headerlink" title="变量屏蔽"></a>变量屏蔽</h3><p>在 Go 语言中，块作用域内声明的变量名可以在内部块中重新声明。这个原则被称为变量屏蔽，容易出现常见的错误。</p>
<p><strong>❌错误代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client                          ❶ 声明一个 client 变量</span><br><span class="line"><span class="keyword">if</span> tracing &#123;</span><br><span class="line">    client, err := createClientWithTracing()     ❷ 变量被屏蔽</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(client)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    client, err := createDefaultClient()         ❸ 变量被屏蔽</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(client)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Use client</span></span><br><span class="line">fmt.Println(client)  <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>
<p>我们首先声明一个client变量。然后，我们在两个内部块中使用短变量声明运算符（:=）将函数调用的结果分配给内部client变量，而不是外部变量。因此，外部变量始终为nil。</p>
<p><strong>✅正确代码</strong></p>
<p>正确写法1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client</span><br><span class="line"><span class="keyword">if</span> tracing &#123;</span><br><span class="line">    c, err := createClientWithTracing()    ❶ 创建一个临时变量 c</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    client = c                             ❷ 将 c 分配给 client</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Same logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确写法2：我们可以直接将结果赋值给 client, 而不是先分配给一个临时变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client *http.Client</span><br><span class="line"><span class="keyword">var</span> err error                                  ❶ 声明 client 和 err</span><br><span class="line"><span class="keyword">if</span> tracing &#123;</span><br><span class="line">    client, err = createClientWithTracing()    ❷ 将返回值赋给 client 和 err</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Same logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>变量屏蔽是指在内部块中重新声明变量名，但我们已经发现这种做法容易出错。禁止屏蔽变量的做法取决于个人口味。例如，有时重用现有的变量名（如错误）可以更方便。</p>
<h3 id="不必要的嵌套"><a href="#不必要的嵌套" class="headerlink" title="不必要的嵌套"></a>不必要的嵌套</h3><p><strong>❌错误代码</strong></p>
<p>join 函数拼接两个字符串并在长度大于 max 时返回子串。同时，它还校验 s1 和 s2 参数，以及拼接调用是否返回错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">join</span><span class="params">(s1, s2 <span class="keyword">string</span>, max <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1 == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"s1 is empty"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s2 == <span class="string">""</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"s2 is empty"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            concat, err := concatenate(s1, s2)     ❶ 调用一个函数来进行连接操作，但可能返回错误。</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(concat) &gt; max &#123;</span><br><span class="line">                    <span class="keyword">return</span> concat[:max], <span class="literal">nil</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> concat, <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatenate</span><span class="params">(s1 <span class="keyword">string</span>, s2 <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现的角度来看，这个函数是正确的。但是嵌套的层级却很多。</p>
<p><strong>✅正确代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">join</span><span class="params">(s1, s2 <span class="keyword">string</span>, max <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1 == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"s1 is empty"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s2 == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"s2 is empty"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    concat, err := concatenate(s1, s2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(concat) &gt; max &#123;</span><br><span class="line">        <span class="keyword">return</span> concat[:max], <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> concat, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatenate</span><span class="params">(s1 <span class="keyword">string</span>, s2 <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>不应该这样写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> foo() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而应该这样写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> foo() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 省略 else</span></span><br></pre></td></tr></table></figure>
<p>同理不应该这样写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s != <span class="string">""</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"empty string"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而应该这么写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> s == <span class="string">""</span> &#123;                        </span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"empty string"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="滥用-init"><a href="#滥用-init" class="headerlink" title="滥用 init"></a>滥用 init</h3><p>一个init函数是用来初始化应用程序状态的函数。它不带任何参数，也不返回结果（一个 func() 函数）。当一个包被初始化时，包中的所有常量和变量声明都会被计算。然后，init函数会被执行。例如一下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"var"</span>)        ❶ 第一个打印</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"init"</span>)       ❷ 第二个打印</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"main"</span>)       ❸ 第三个打印</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如以下代码中，我们定义了 main 包，又在 main 包中引用了 redis 包，如果 redis 包中存在 init 函数，那么就会先执行 redis 包中的 init，然后再执行 main 包中的 init。最后在执行 main 函数本身。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line">    <span class="string">"redis"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := redis.Store(<span class="string">"foo"</span>, <span class="string">"bar"</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以为每个包定义多个 init 函数。当存在多个 init 函数时，包中每个 init 函数的执行顺序取决于源文件的字母顺序。例如，如果一个包包含 a.go 和 b.go 文件，并且两个文件都有 init 函数，则 a.go 文件的 init 函数首先被执行。</p>
<p>但问题就出在这里，我们有时会依赖同一个包内的多个 init 的执行顺序。这样做可能是危险的，因为源文件可能会被重命名，从而潜在地影响执行顺序。</p>
<p>我们也可以在同一源文件中定义多个init函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;               ❶ 第一个初始化函数</span><br><span class="line">    fmt.Println(<span class="string">"init 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;               ❷ 第二个初始化函数</span><br><span class="line">    fmt.Println(<span class="string">"init 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">init 1</span></span><br><span class="line"><span class="comment">init 2</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p>有时，我们并不依赖包的中的某个函数，但是需要进行初始化这个包，我们可以使用 _ 操作符来做到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line">    _ <span class="string">"foo"</span>    ❶ foo包在main函数之前初始化。因此，会执行foo的init函数</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，init 函数它不能够直接被调用，就如以下的例子一样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    init()       ❶ 无效调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一些场景下不适合使用 init 函数，例如：在示例的 init 函数中，我们使用 sql.Open 打开一个数据库。将此数据库作为全局变量使其他函数可以稍后使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dataSourceName := os.Getenv(<span class="string">"MYSQL_DATA_SOURCE_NAME"</span>)  </span><br><span class="line">    d, err := sql.Open(<span class="string">"mysql"</span>, dataSourceName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    err = d.Ping()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    db = d      ❶ 将 DB 连接分配给全局的 db 变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，在 init 函数中的错误管理是受限的。由于 init 函数不返回错误，要发出错误信号的唯一方法之一是使用 panic，使应用程序停止。其次，另一个重要的缺点与测试有关。如果我们向该文件添加测试，那么init函数将在运行测试用例之前执行，这可能不是我们想要的，因为我们可能就是要测试 init 中连接。最后一个缺点是示例将数据库连接池分配给全局变量，全局变量的坏处就是任何包内的函数都可以修改这个全局变量，并且可能会导致全局变量的测试变得复杂，因为全局变量没有了隔离性。</p>
<p>所以，数据库初始化，并不合适在 init 中进行。数据库的初始化在大多数情况下，我们应该使用一个变量将其封装起来，而不是让它成为全局变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createClient</span><span class="params">(dsn <span class="keyword">string</span>)</span> <span class="params">(*sql.DB, error)</span></span> &#123;    ❶ 接受一个数据源名称并返回 *sql.DB 和错误</span><br><span class="line">    db, err := sql.Open(<span class="string">"mysql"</span>, dsn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err                             ❷ 返回错误</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> db, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此封装，就解决了使用 init 带来的缺点了，错误处理的责任由调用者承担，还可以创建集成测试来检查这个函数是否正常工作，并且连接池被封装在函数内部。</p>
<p><strong>❌错误代码</strong></p>
<ol>
<li>同一个包中存在多个 init，我们很依赖 init 的执行顺序（这种情况下 init 的执行顺序和源文件的字母顺序有关）但是这种顺序不能被保证，很容易就会被修改了。</li>
<li>直接调用 init 函数</li>
</ol>
<p><strong>✅正确代码</strong></p>
<ol>
<li>不应该依赖同一个包内的多个 init 的执行顺序</li>
<li>如果只想初始化另一个包，可以使用 _ 操作符</li>
<li>不应该直接调用 init 函数</li>
<li>因为 init 不能很好的处理错误，里面可以使用 panic，但是除非是致命的错误，否则使用会造成程序运行中断</li>
<li>不建议在 init 中获取数据库的连接，并将连接对象设置一个全局变量</li>
</ol>
<h3 id="过度使用-getter-和-setter"><a href="#过度使用-getter-和-setter" class="headerlink" title="过度使用 getter 和 setter"></a>过度使用 getter 和 setter</h3><p>在编程中，数据封装往往是为了隐藏对象的内部状态。getters 和 setters 就是提供修改/获取内部对象字段的导出函数。在Go语言中，并没有明确的限制必须要通过 getters and setters 去获取数据。比如 time 标准库中有：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second)</span><br><span class="line">&lt;-timer.C</span><br></pre></td></tr></table></figure>
<p>你可以直接修改C变量。</p>
<p><strong>❌错误代码</strong></p>
<p>在 go 中强求使用 Getter 和 Setter。</p>
<p><strong>✅正确代码</strong></p>
<p>在 go 中不强求使用 getter 和 setter。但是当我们，要使用 getter 和 setter 的时候，假设是一个名为 balance 的字段，我们应该遵循这些命名惯例：</p>
<ol>
<li>Getter 方法的名称应该为 Balance（而不是 GetBalance）</li>
<li>Setter 方法应该被命名为 SetBalance</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">currentBalance := customer.Balance()     ❶ getter</span><br><span class="line"><span class="keyword">if</span> currentBalance &lt; <span class="number">0</span> &#123;</span><br><span class="line">    customer.SetBalance(<span class="number">0</span>)               ❷ setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口污染"><a href="#接口污染" class="headerlink" title="接口污染"></a>接口污染</h3><h4 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h4><p>Go 接口的不同之处在于它们是隐式满足的。没有像 implements 这样的关键字来标记一个对象X实现了接口Y。我们可以拿标准库中的例子：<code>io.Reader</code>和<code>io.Writer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们需要实现一个函数，其目的是将一个文件内容复制到另一个文件。我们可以创建一个特定的函数，该函数将以两个 <code>*os.Files</code> 作为输入。或者，我们可以选择使用 io.Reader 和 io.Writer 抽象来创建更通用的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copySourceToDest</span><span class="params">(source io.Reader, dest io.Writer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数可以使用<code>*os.File</code>参数（因为<code>*os.File</code>实现了io.Reader和io.Writer），以及任何实现这些接口的其他类型。例如，我们可以创建自己的io.Writer，将数据写入数据库，而代码也将保持不变。这增加了函数的通用性，因此提高了它的可重用性。</p>
<p>另外，我们还可以将细粒度的接口组合在一起，以创建更高级别的抽象。这就是io.ReadWriter的情况，它结合了读取器和写入器的行为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="什么时候使用接口"><a href="#什么时候使用接口" class="headerlink" title="什么时候使用接口"></a>什么时候使用接口</h4><p><strong>通用的行为</strong></p>
<p>在sort包中，我们可以找到数十种实现。例如，我们在某个时刻计算一组整数，想要将它们排序，那么我们一定对实现类型感兴趣吗？排序算法是归并排序还是快速排序很重要吗？在许多情况下，我们并不关心。因此，排序行为可以被抽象出来，我们可以依赖sort.Interface。例如 sort 包 中的 Interface 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="keyword">int</span>               ❶ 获取元素数量</span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span>     ❷ 检查两个元素</span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)          ❸ 交换两个元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查一个集合是否已经排序，就可以用上上面的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSorted</span><span class="params">(data Interface)</span> <span class="title">bool</span></span> &#123;  <span class="comment">// 传入 实现了接口的 data</span></span><br><span class="line">    n := data.Len()                   <span class="comment">// 获取元素数量</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> data.Less(i, i<span class="number">-1</span>) &#123;        <span class="comment">// 检查两个元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解耦</strong></p>
<p>解耦的一个好处可以与单元测试相关。假设我们想实现一个名为 CreateNewCustomer 的方法，用于创建并存储一个新客户，不解耦的情况下, 我们可能会这么实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomerService <span class="keyword">struct</span> &#123;</span><br><span class="line">    store mysql.Store          ❶ 具体的实现</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs CustomerService)</span> <span class="title">CreateNewCustomer</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    customer := Customer&#123;id: id&#125;</span><br><span class="line">    <span class="keyword">return</span> cs.store.StoreCustomer(customer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要测试这个方法怎么办？因为 CustomerService 依赖于实际的实现 mysql 来存储客户，我们被迫通过集成测试来进行测试，这需要启动一个 MySQL 实例。那如果我们解耦呢：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customerStorer <span class="keyword">interface</span> &#123;      ❶ 创建一个存储的抽象接口，里面有个 StoreCustomer 方法</span><br><span class="line">    StoreCustomer(Customer) error</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> CustomerService <span class="keyword">struct</span> &#123;</span><br><span class="line">    storer customerStorer            ❷ 将CustomerService与实际实现分离</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs CustomerService)</span> <span class="title">CreateNewCustomer</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    customer := Customer&#123;id: id&#125;</span><br><span class="line">    <span class="keyword">return</span> cs.storer.StoreCustomer(customer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在存储客户是通过接口完成的，这使得我们在测试该方法时具有更多的灵活性。可以通集成测试，或者通过单元测试使用模拟对象。</p>
<p><strong>限制行为</strong></p>
<p>假设我们现在已经有了一个 IntConfig 结构体，并且这个结构体有两个方法 Get 和 Set。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *IntConfig)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// Retrieve configuration</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *IntConfig)</span> <span class="title">Set</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Update configuration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有一个需求是不改动上面的代码，要阻止调用 Set 方法（屏蔽）对 IntConfig 进行更新。这时我们可以创建一个新的接口，里面只有一个 Get 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> intConfigGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就是 IntConfig 实现了 intConfigGetter 接口了。并且我们只提供了 Get 方法。在使用的时候，我们可以这样使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    threshold intConfigGetter   <span class="comment">// 只有 Get 方法的接口</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">(threshold intConfigGetter)</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;threshold: threshold&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span> <span class="title">Bar</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    threshold := f.threshold.Get()   <span class="comment">// 只能调用 Get 方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口污染-1"><a href="#接口污染-1" class="headerlink" title="接口污染"></a>接口污染</h4><p>Interface 污染则代表了代码中充斥着无用的抽象，难以理解。</p>
<p>接口的目的是创建抽象。当编程遇到抽象时，主要注意点是要记住抽象应该被发现，而不是被创造。这是什么意思？这意味着如果没有立即需要，我们不应该在我们的代码中开始创建抽象。我们不应该用接口进行设计，而应等待具体的需求。换句话说，我们应该在需要时创建接口，而不是在预见到可能需要时创建接口。</p>
<h3 id="接口应该在哪里"><a href="#接口应该在哪里" class="headerlink" title="接口应该在哪里"></a>接口应该在哪里</h3><p>情景1: 接口在生产者端 — 接口与具体实现一同被定义</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032150361.png" alt></p>
<p>情景2: 接口在消费者端 — 接口是在使用的地方进行定义的</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032151555.png" alt></p>
<p>在 C# 或者 Java 中，很常见的模式是情境1。但是在 Go 中，我们还可能或者更应该存在情境2，因为 Go 语言的接口是隐式满足的。</p>
<p>例如，我们想实现一个包来进行客户的存储和查询。但是呢，规定所有的操作都必须通过接口来进行，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> store</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> CustomerStorage <span class="keyword">interface</span> &#123;</span><br><span class="line">    StoreCustomer(customer Customer) error</span><br><span class="line">    GetCustomer(id <span class="keyword">string</span>) (Customer, error)</span><br><span class="line">    UpdateCustomer(customer Customer) error</span><br><span class="line">    GetAllCustomers() ([]Customer, error)</span><br><span class="line">    GetCustomersWithoutContract() ([]Customer, error)</span><br><span class="line">    GetCustomersWithNegativeBalance() ([]Customer, error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有客户的操作都经过接口来进行</span></span><br></pre></td></tr></table></figure>
<p>如果采用情景1，那么这么抽象和实现都被定义在了制造者端。但是如前所述，Go 语言中的接口是隐式满足的，在大多数情况下，我们应该发现抽象，而不是创建抽象。这意味着制造者并不需要强制为所有客户端提供特定的抽象。相反，客户端需要决定是否需要某种形式的抽象，并确定其需要的最佳抽象级别。</p>
<p>例如，我们只对 GetAllCustomers 方法感兴趣。在这种情况下，这个客户可以创建一个仅包含单个方法的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> client</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> customersGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetAllCustomers() ([]store.Customer, error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端包通过创建自己的接口来定义所需的抽象</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>customersGetter</code>只在内部使用，所以可以不导出</li>
<li>很多人会认为他有循环依赖，其实并没有，因为Go的interface是隐式的。<br><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032202705.png" alt></li>
</ul>
<p>因此，在这种情况下，最好的方法是在生产者侧公开具体实现，让客户端决定如何使用它以及是否需要抽象。</p>
<p>但是在 Go 中，虽然我们推荐情景2 的写法，但也存在情境1 的情况，例如在标准库中。<code>encoding</code>包定义了一些inteface，被子包<code>encoding/json</code>，<code>encoding/binary</code>实现。</p>
<h3 id="返回接口"><a href="#返回接口" class="headerlink" title="返回接口"></a>返回接口</h3><p>在许多情况下，在Go语言中返回接口被认为是一种不良实践。例如下面代码中，store 包返回 client 包中的 Store 的接口。这时，store 包就依赖于 client 包。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308032218861.png" alt></p>
<p>在 store 包中，我们定义了一个实现存储接口的 InMemoryStore 结构体。同时，我们创建了一个NewInMemoryStore 函数来返回一个 Store 接口。这时就存在一个问题，client 包不能再调用NewInMemoryStore 函数，否则会造成循环依赖。一个可能的解决方案是从另一个包中调用该函数，并向 client 包 注入一个Store实现。但这样的代码就会很难理解。所以，结论是：</p>
<ul>
<li>用返回具体实现来代替 interface</li>
<li>尽可能的接收 interface 参数</li>
</ul>
<blockquote>
<p>做事要保守，但接受别人的观点要开放。</p>
</blockquote>
<p>但是这并不是一直这样的，也会有返回接口的情况，例如：以下函数返回一个导出的结构体 io.LimitedReader。然而，函数签名是一个接口 io.Reader。这和上面我们的建议和结论相违背。io.Reader 是一个前置抽象。它不是由客户端定义的，而是由语言设计者预先了解到这个抽象级别将是有帮助的（例如，关于可重用性和组合性）。所以这种情况下也是对的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r Reader, n <span class="keyword">int64</span>)</span> <span class="title">Reader</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LimitedReader&#123;r, n&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，在大多数情况下，我们不应该返回接口而是具体的实现。否则，由于包依赖关系会使我们的设计更加复杂，并且会限制灵活性。</p>
<p>再次强调，结论与前面的部分类似：如果我们知道（而不是预见）抽象对客户有帮助，我们可以考虑返回接口。否则，我们不应该强迫抽象；它们应该由客户端发现。</p>
<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>Go 1.18 的推出后，预定义的 any 类型成为了空接口的别名；因此，所有 interface{} 的出现都可以用 any 来替代。</p>
<p><strong>❌错误代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> store</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">// Some fields</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Contract <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">// Some fields</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">Get</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(any, error)</span></span> &#123;     ❶ 返回 any</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">Set</span><span class="params">(id <span class="keyword">string</span>, v any)</span> <span class="title">error</span></span> &#123;     ❷ 接受 any</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用any，我们失去了Golang作为静态类型语言的一些好处。相反，我们应该避免使用任何类型，并尽可能使我们的函数签名明确。</p>
<p><strong>✅正确代码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">GetContract</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(Contract, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">SetContract</span><span class="params">(id <span class="keyword">string</span>, contract Contract)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">GetCustomer</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(Customer, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">SetCustomer</span><span class="params">(id <span class="keyword">string</span>, customer Customer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>任何情况下都不可以使用 any 吗？其实不是的，例如在 encoding/json 包中，因为我们可以将任何类型编组，所以 Marshal 函数接受一个任意参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v any)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个例子在 database/sql 包中。 如果查询是参数化的（例如，SELECT * FROM FOO WHERE id = ?），则参数可以是任何类型。 因此，它也使用任何参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span> <span class="title">QueryContext</span><span class="params">(ctx context.Context, query <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    args ...any)</span> <span class="params">(*Rows, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，该用的时候使用，不用能让代码的表达能力更清楚，更能表达代码的作用。</p>
<h3 id="什么时候用泛型"><a href="#什么时候用泛型" class="headerlink" title="什么时候用泛型"></a>什么时候用泛型</h3><h4 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h4><p>例如有以下代码，获取 map 中的所有key。但是呢 map 有不用类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKeys</span><span class="params">(m any)</span> <span class="params">([]any, error)</span></span> &#123;                      ❶ 接受并返回任何参数</span><br><span class="line">    <span class="keyword">switch</span> t := m.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unknown type: %T"</span>, t)     ❷ 未知 <span class="keyword">map</span> 类型</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>:</span><br><span class="line">        <span class="keyword">var</span> keys []any</span><br><span class="line">        <span class="keyword">for</span> k := <span class="keyword">range</span> t &#123;</span><br><span class="line">        	keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>:</span><br><span class="line">        <span class="comment">// Copy the extraction logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们想添加一个 case 时，需要重复 range 循环。与此同时，这个函数现在接受了 any 类型，这意味着我们失去了作为强类型语言Go的一些优势。</p>
<p>以下是泛型示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(t T)</span></span> &#123;     ❶ T 是一个类型参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>以下是使用泛型重写 getKeys 的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKeys</span>[<span class="title">K</span> <span class="title">comparable</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> []<span class="title">K</span></span> &#123;   ❶ 键是可比较的，而值可以是任何类型</span><br><span class="line">    <span class="keyword">var</span> keys []K                                     ❷ 创建一个 keys 切片</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">        keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Go中，Map 的键不能是任何类型。例如，我们不能使用切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[[]<span class="keyword">byte</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>这段代码会导致编译错误：无效的 map 键类型 []byte。在这里，要求是键类型必须是可比较的（我们可以使用==或!=）。因此，我们将 K 定义为可比较的类型，而不是任何类型。我们想将其限制为int或string类型。我们可以通过以下方式定义自定义约束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customConstraint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="keyword">int</span> | ~<span class="keyword">string</span>                   ❶ 定义了一个自定义类型，限制类型为 <span class="keyword">int</span> 和 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">❷ 将类型参数K更改为customConstraint类型</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKeys</span>[<span class="title">K</span> <span class="title">customConstraint</span>, <span class="title">V</span> <span class="title">any</span>]<span class="params">(m <span class="keyword">map</span>[K]V)</span> []<span class="title">K</span></span> &#123; </span><br><span class="line">    <span class="comment">// Same implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型参数的最后一项需要注意的是，它们不能用于方法参数，仅能用于函数参数或方法接收器，例如以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Foo)</span> <span class="title">bar</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(t T)</span></span> &#123;&#125;</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">29</span>:<span class="number">15</span>: methods cannot have <span class="keyword">type</span> parameters</span><br></pre></td></tr></table></figure>
<p>在以下场景中，泛型比较用得多：</p>
<ol>
<li><p>数据结构-例如实现二叉树、链表或堆时，我们可以使用泛型来分离元素类型。</p>
</li>
<li><p>与 slices（切片）、 maps（映射）和任何类型的 channels（通道）一起使用的函数——例如，合并两个 channels 的函数将适用于任何类型的 channel。因此，我们可以使用类型参数来分离 channel 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(ch1, ch2 &lt;-<span class="keyword">chan</span> T)</span> &lt;-<span class="title">chan</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将行为和类型分离</p>
<p>例如有一个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用泛型实现上面接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceFn[T any] <span class="keyword">struct</span> &#123;    ❶ 使用类型参数</span><br><span class="line">    S       []T</span><br><span class="line">    Compare <span class="function"><span class="keyword">func</span><span class="params">(T, T)</span> <span class="title">bool</span>     ❷ 比较两个<span class="title">T</span>元素</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SliceFn[T])</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s.S) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SliceFn[T])</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s.Compare(s.S[i], s.S[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s SliceFn[T])</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; s.S[i], s.S[j] = s.S[j], s.S[i] &#125;</span><br></pre></td></tr></table></figure>
<p>因为SliceFn 结构实现了 sort.Interface，所以我们可以使用 sort.Sort(sort.Interface) 函数对提供的切片进行排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s := SliceFn[<span class="keyword">int</span>]&#123;</span><br><span class="line">  S: []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    Compare: <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">sort.Sort(s)</span><br><span class="line">fmt.Println(s.S)</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="结构体内嵌"><a href="#结构体内嵌" class="headerlink" title="结构体内嵌"></a>结构体内嵌</h3><p>Go在结构体中提供了内嵌类型的方式，会出现一些不在预期内的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span> &#123;</span><br><span class="line">    Baz <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Foo.Bar就是一种内嵌类型，允许Foo直接调用Bar的方法。</p>
<p><strong>❌错误代码</strong></p>
<p>我们下面看一种错误的内嵌使用方式,我们想要在内存中并发操作map：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InMem <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">InMem</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;InMem&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *InMem)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    i.Lock()</span><br><span class="line">    v, contains := i.m[key]</span><br><span class="line">    i.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v, contains</span><br></pre></td></tr></table></figure>
<p>因为<code>sync.Mutex</code>是内嵌类型，我们可以使用<code>Lock</code>和<code>Unlock</code>方法，但是这两个方法也同样是导出方法，可以被外部调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := inmem.New()</span><br><span class="line">m.Lock() <span class="comment">// ??</span></span><br></pre></td></tr></table></figure>
<p>Mutex 在大多数情况下是我们想要封装在结构体中并对外部客户端隐藏的内容。因此，在这种情况下我们不应该将其作为嵌入字段。</p>
<p><strong>✅正确代码</strong></p>
<p>所以我们应该改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InMem <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>我们来看一个使用内嵌比较适合的场景，我们想编写一个自定义日志记录器，其中包含一个io.WriteCloser并公开两种方法：Write和Close。如果未嵌入io.WriteCloser，则需要编写如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">    writeCloser io.WriteCloser</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Logger)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l.writeCloser.Write(p)     ❶ 转发调用给 writeCloser</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Logger)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l.writeCloser.Close()      ❶ 转发调用给 writeCloser</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := Logger&#123;writeCloser: os.Stdout&#125;</span><br><span class="line">    _, _ = l.Write([]<span class="keyword">byte</span>(<span class="string">"foo"</span>))</span><br><span class="line">    _ = l.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，当我们使用内嵌的时候：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123; </span><br><span class="line">    io.WriteCloser       ❶ 内嵌 io.WriteCloser，这样就不用实现 Write 和 Close 方法</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := Logger&#123;WriteCloser: os.Stdout&#125;</span><br><span class="line">    _, _ = l.Write([]<span class="keyword">byte</span>(<span class="string">"foo"</span>))</span><br><span class="line">    _ = l.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例防止了仅仅为了转发调用而实现的这些附加方法。</p>
<p>那内嵌和集成有什么区别呢：</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308061018957.png" alt></p>
<p>通过嵌入，Foo 的接收者仍然是 X。然而，通过继承，Foo 的接收者变成了子类 Y。嵌入是关于组合，而非继承。</p>
<h3 id="函数的选项模式"><a href="#函数的选项模式" class="headerlink" title="函数的选项模式"></a>函数的选项模式</h3><p>当我们设计API的时候经常会遇到一个问题:怎么去处理一些可选的配置项？效率的解决这个问题就可以让我们的API使用起来更舒适。举个例子，当我们需要设计一个函数去创建一个HTTP服务时，起初需要两个入参：地址以及端口，我们提供了以下方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, port <span class="keyword">int</span>)</span> <span class="params">(*http.Server, error)</span></span> &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始都很方便，渐渐的，客户端开始抱怨说怎么无法设置超时时间。这时候我们就会发现：当我们想要增加一个参数时，客户端就无法兼容原来的调用<code>NewServer</code>方式了。那我们怎么去设计一个API友好型的函数呢？比较通用的方式就是把所有的配置项设置成一个struct，然后只接收一个struct参数。而我们这一章要讲的则是另一种方式<code>functional options pattern</code>：</p>
<ul>
<li>私有结构体涵盖配置参数：<code>options</code></li>
<li>每个可选项都会返回同类型：<code>type Option func(options *options) error</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308061027915.png" alt></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;                          ❶ 配置结构体</span><br><span class="line">    port *<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(options *options)</span> <span class="title">error</span>       ❷ 代表一个函数类型，它更新配置的结构体</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithPort</span><span class="params">(port <span class="keyword">int</span>)</span> <span class="title">Option</span></span> &#123;               ❸ 更新端口的函数</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(options *options)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> port &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">"port should be positive"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        options.port = &amp;port</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WithPort 返回一个闭包。闭包是一个匿名函数，它引用了外部变量，这里是引用了 port 参数。</p>
<p>闭包考虑了选项类型并实现了端口验证逻辑。每个配置字段都需要创建一个公共函数（按惯例以 With 前缀开头），其中包含类似的逻辑：必要时验证输入并更新配置结构。再来看看怎么应用这些配置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(addr <span class="keyword">string</span>, opts ...Option)</span> <span class="params">(     ❶ 接收不定数量的 Option 参数</span></span></span><br><span class="line"><span class="function"><span class="params">    *http.Server, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> options options                           ❷ 创建一个空的选项结构体</span><br><span class="line">    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;                    ❸ 循环所有使用的选项</span><br><span class="line">        err := opt(&amp;options)                      ❹ 调用每个选项，这将导致修改公共选项结构体。</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 参数逻辑</span></span><br><span class="line">    <span class="keyword">var</span> port <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> options.port == <span class="literal">nil</span> &#123;</span><br><span class="line">        port = defaultHTTPPort</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> *options.port == <span class="number">0</span> &#123;</span><br><span class="line">            port = randomPort()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            port = *options.port</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，可以这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server, err := httplib.NewServer(<span class="string">"localhost"</span>,</span><br><span class="line">        httplib.WithPort(<span class="number">8080</span>),</span><br><span class="line">        httplib.WithTimeout(time.Second))</span><br></pre></td></tr></table></figure>
<p>如果想使用默认参数，则可以不传递 Withxx 函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server, err := httplib.NewServer(<span class="string">"localhost"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>Go语言的维护者没有关于如何在Go中构建项目的强烈惯例。然而，多年来已经出现了一个布局：<a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">project-layout</a></p>
<p>在 Go 中，没有子包的概念。然而，我们可以选择在子目录中组织软件包。如果我们看一下标准库，net 目录就是这样组织的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/net</span><br><span class="line">    /http</span><br><span class="line">        client.go</span><br><span class="line">        ...</span><br><span class="line">    /smtp</span><br><span class="line">        auth.go</span><br><span class="line">        ...</span><br><span class="line">    addrselect.go</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>net 既是一个包又是一个包含其他包的目录。</p>
<p>粒度是另一个需要考虑的重要因素。我们应该避免拥有数十个仅包含一个或两个文件的纳米级包。相反地，我们也应该避免过大的包，这将淡化包名称的意义。</p>
<p>包名应该简短、简明、富有表现力，在约定中应该是一个小写单词。</p>
<h3 id="utility-包"><a href="#utility-包" class="headerlink" title="utility 包"></a>utility 包</h3><p>本节讨论一种常见的坏习惯：创建共享包，例如 utils、common 和 base等</p>
<p>例如：我们有以下代码，并将其放在 util 包中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStringSet</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">struct</span></span>&#123;&#125; &#123;    ❶ 创建一个字符串 set</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SortStringSet</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span> []<span class="title">string</span></span> &#123;    ❷ 返回按照 <span class="keyword">map</span> 的 key 排序的列表</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set := util.NewStringSet(<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>)</span><br><span class="line">fmt.Println(util.SortStringSet(set))</span><br></pre></td></tr></table></figure>
<p>这里的问题在于 util 没有意义。我们可以称之为 common、shared 或 base，但它仍然是一个毫无意义的名称，无法提供任何关于该软件包属性的指示。</p>
<p>我们应该创建一个更有表现力的包名，比如stringset，而不是一个实用程序包。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">struct</span></span>&#123;&#125; &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span> []<span class="title">string</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set := stringset.New(<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>)</span><br><span class="line">fmt.Println(stringset.Sort(set))</span><br></pre></td></tr></table></figure>
<p>我们甚至可以再进一步。不是暴露实用函数，而是创建一个特定类型，并以此方式作为方法公开:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringset</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(...<span class="keyword">string</span>)</span> <span class="title">Set</span></span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span> <span class="title">Sort</span><span class="params">()</span> []<span class="title">string</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set := stringset.New(<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>)</span><br><span class="line">fmt.Println(set.Sort())</span><br></pre></td></tr></table></figure>
<h3 id="变量名和包名冲突"><a href="#变量名和包名冲突" class="headerlink" title="变量名和包名冲突"></a>变量名和包名冲突</h3><p>当变量名称与现有包名称冲突时，会发生包冲突。让我们看一个具体的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> redis</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">()</span> *<span class="title">Client</span></span> &#123; ... &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>使用时，尽管包名称为 redis，但在 Go 中创建一个名为 redis 的变量也完全有效</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis := redis.NewClient()     ❶ 从 redis 包调用 NewClient</span><br><span class="line">v, err := redis.Get(<span class="string">"foo"</span>)     ❷ 使用 redis 变量</span><br></pre></td></tr></table></figure>
<p>这里 redis 变量名与 redis 包名发生了冲突。尽管这是被允许的，但应该避免发生这种情况。实际上，在 redis 变量的作用域范围内，redis 包将不可访问。</p>
<p>第一种解决方式：使用不同的变量名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisClient := redis.NewClient()</span><br><span class="line">v, err := redisClient.Get(<span class="string">"foo"</span>)</span><br></pre></td></tr></table></figure>
<p>第二种解决方式：使用别名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redisapi <span class="string">"mylib/redis"</span>    ❶ 创建 redis 包的别名</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">redis := redisapi.NewClient()    ❷ 通过 redisapi 别名访问 redis 包</span><br><span class="line">v, err := redis.Get(<span class="string">"foo"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="代码文档"><a href="#代码文档" class="headerlink" title="代码文档"></a>代码文档</h3><p>每个导出的元素必须进行文档化。无论是结构体、接口、函数还是其他的东西，只要它被导出，就必须进行文档化。约定俗成的做法是添加注释，以导出元素的名称开头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Customer is a customer representation.</span></span><br><span class="line"><span class="keyword">type</span> Customer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ID returns the customer identifier.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Customer)</span> <span class="title">ID</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">""</span> &#125;</span><br></pre></td></tr></table></figure>
<p>每个注释应该是一个以标点符号结尾的完整句子。并且注释的内容，应该强调函数的意图而不是它如何实现。</p>
<blockquote>
<p>可以使用 // Deprecated: 注释的方式标记导出的元素为过时元素。</p>
</blockquote>
<p>当为常量时，应该这么使用注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultPermission is the default permission used by the store engine.</span></span><br><span class="line"><span class="keyword">const</span> DefaultPermission = <span class="number">0</span>o644 <span class="comment">// Need read and write accesses.</span></span><br></pre></td></tr></table></figure>
<p>第一行注释文档说明了目的，第二行文档说明了实际的内容。</p>
<p>当为包的时候，应该对每个包进行文档编写。惯例是以 <code>// Package</code> 为开头，后跟包名称的注释</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package math provides basic constants and mathematical functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This package does not guarantee bit-identical results</span></span><br><span class="line"><span class="comment">// across architectures.</span></span><br><span class="line"><span class="keyword">package</span> math</span><br></pre></td></tr></table></figure>
<p>一个包的文档可以在任何 Go 文件中完成，这个没有规定。通常情况下，我们应该将包文档放在与包同名的相关文件中，或者放在一个特定的文件，比如doc.go中。</p>
<p>与声明不相邻的注释将会被省略。例如，以下版权注释将不会在生成的文档中显示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"><span class="comment">// Package math provides basic constants and mathematical functions.</span></span><br><span class="line"><span class="comment">//                                                       ❶ 空行，之前的注释不会包含在文档中</span></span><br><span class="line"><span class="comment">// This package does not guarantee bit-identical results</span></span><br><span class="line"><span class="comment">// across architectures.</span></span><br><span class="line"><span class="keyword">package</span> math</span><br></pre></td></tr></table></figure>
<h3 id="代码检查工具"><a href="#代码检查工具" class="headerlink" title="代码检查工具"></a>代码检查工具</h3><p>在 “变量屏蔽” 中，我们讨论了变量重名潜在的错误。我们可以使用 vet 和 shadow 来发现这种情况</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        i := <span class="number">1</span>          ❶ 变量屏蔽</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vet 已经内置了，shadow 需要先安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow     ❶ 安装 shadow</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> go vet -vettool=$(<span class="built_in">which</span> shadow)                             ❷ 使用</span></span><br><span class="line">./main.go:8:3:</span><br><span class="line">  declaration of "i" shadows declaration at line 6            ❸ 检测到变量屏蔽</span><br></pre></td></tr></table></figure></p>
<p>代码检查常用工具：</p>
<p><a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener">https://golang.org/cmd/vet/</a>  —A standard Go analyzer<br><a href="https://github.com/kisielk/errcheck" target="_blank" rel="noopener">https://github.com/kisielk/errcheck</a>  —An error checker<br><a href="https://github.com/fzipp/gocyclo" target="_blank" rel="noopener">https://github.com/fzipp/gocyclo</a>  —A cyclomatic complexity analyzer<br><a href="https://github.com/jgautheron/goconst" target="_blank" rel="noopener">https://github.com/jgautheron/goconst</a>  —A repeated string constants analyzer</p>
<p>代码格式化工具：</p>
<p><a href="https://golang.org/cmd/gofmt/" target="_blank" rel="noopener">https://golang.org/cmd/gofmt/</a>   —A standard Go code formatter<br><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">https://godoc.org/golang.org/x/tools/cmd/goimports</a>   —A standard Go imports formatter<br><a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">https://github.com/golangci/golangci-lint</a></p>
<h3 id="八进制字面量的误解"><a href="#八进制字面量的误解" class="headerlink" title="八进制字面量的误解"></a>八进制字面量的误解</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">100</span> + <span class="number">010</span></span><br><span class="line">fmt.Println(sum)</span><br></pre></td></tr></table></figure>
<p>我们可能期望这段代码会打印出 100 + 10 = 110 的结果。但实际上它打印出了 108。</p>
<p>在Go语言中，以0开头的整数字面值被认为是八进制整数，因此八进制数10 等于十进制数8。因此，前面例子中的总和等于100 + 8 = 108。</p>
<p>八进制整数在不同的场景中非常有用。例如，假设我们想要使用 os.OpenFile 打开一个文件。此函数需要传递一个uint32作为权限。如果我们想匹配 Linux 权限，我们可以传递一个八进制数，而不是一个十进制数，以提高可读性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">"foo"</span>, os.O_RDONLY, <span class="number">0644</span>)</span><br></pre></td></tr></table></figure>
<p>还可以在零后面添加一个o字符（小写字母o），使用 0o 而不仅仅是 0 作为前缀，二者表达意思是相同的，但它可以帮助使代码更清晰。为了提高可读性并避免未来代码读者的潜在错误，应明确使用0o前缀来表示八进制数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">"foo"</span>, os.O_RDONLY, <span class="number">0</span>o644)</span><br></pre></td></tr></table></figure>
<p>其他字面量的表达方式：</p>
<ul>
<li>二进制——使用 0b 或 0B 前缀（例如，0b100 等于 10 进制中的 4）</li>
<li>十六进制——使用0x或0X前缀（例如，0xF等于10进制中的15）</li>
<li>虚数 - 使用 i 后缀（例如，3i）</li>
</ul>
<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>Go语言提供了10种整型类型。其中包括4种有符号整型类型和4种无符号整型类型，如下表所示</p>
<table>
<thead>
<tr>
<th>有符号整数</th>
<th>无符号整数</th>
</tr>
</thead>
<tbody>
<tr>
<td>int8 (8 bits)</td>
<td>uint8 (8 bits)</td>
</tr>
<tr>
<td>int16 (16 bits)</td>
<td>uint16 (16 bits)</td>
</tr>
<tr>
<td>int32 (32 bits)</td>
<td>uint32 (32 bits)</td>
</tr>
<tr>
<td>int64 (64 bits)</td>
<td>uint64 (64 bits)</td>
</tr>
</tbody>
</table>
<p>另外两种整数类型是最常用的：int 和 uint。这两种类型的大小取决于系统：在 32 位系统上是 32 位，在 64 位系统上是 64 位。</p>
<p>溢出的例子：</p>
<p>假设我们想要将 int32 初始化为最大值，然后递增它。这段代码的行为应该是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter <span class="keyword">int32</span> = math.MaxInt32</span><br><span class="line">counter++</span><br><span class="line">fmt.Printf(<span class="string">"counter=%d\n"</span>, counter)</span><br></pre></td></tr></table></figure>
<p>该代码可以编译，并且在运行时不会发生 panic。但是，counter++ 语句会生成整数溢出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter=-2147483648</span><br></pre></td></tr></table></figure>
<p>整型溢出是指算术运算产生一个值，超出一个给定字节数量所能表示的范围。一个 int32 类型使用 32 个比特位表示。以下是最大 int32 值（math.MaxInt32）的二进制表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01111111111111111111111111111111</span><br><span class="line"> |------31 bits set to 1-------|</span><br></pre></td></tr></table></figure>
<p>由于 int32 是有符号整数，左侧的位表示整数的符号：0 表示正数，1 表示负数。如果我们将这个整数递增，就没有空间来表示新值。因此，这导致整数溢出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10000000000000000000000000000000</span><br><span class="line"> |------31 bits set to 0-------|</span><br></pre></td></tr></table></figure>
<p>正如我们所看到的，符号位现在等于1，表示为负数。这个值是用32位表示的有符号整数的最小可能值。</p>
<p><strong>在 Go 中，编译时能检测到的整数溢出会生成编译错误</strong>。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter <span class="keyword">int32</span> = math.MaxInt32 + <span class="number">1</span></span><br><span class="line">constant <span class="number">2147483648</span> overflows <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>
<p>然而，在运行时，整数溢出或下溢是静默的；这不会导致应用程序崩溃。必须记住这种行为，因为它可能会导致讨厌的错误（例如，整数的增量或正整数的加法导致负结果）</p>
<p><strong>递增时检测整数溢出</strong></p>
<p>如果我们想要在基于定义大小的类型（int8，int16，int32，int64，uint8，uint16，uint32或uint64）上进行增量操作时检测整数溢出，我们可以将该值与math常数进行比较。例如，对于int32：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Inc32</span><span class="params">(counter <span class="keyword">int32</span>)</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> counter == math.MaxInt32 &#123;    ❶ 与 math.MaxInt32 比较</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"int32 overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数检查输入值是否已等于 math.MaxInt32。如果是那样，我们就知道 Inc32 增量操作是否会导致溢出了。</p>
<p>对于int：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IncInt</span><span class="params">(counter <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> counter == math.MaxInt &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"int overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 uint：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IncUint</span><span class="params">(counter <span class="keyword">uint</span>)</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> counter == math.MaxUint &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"uint overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在加法中检测整数溢出</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; math.MaxInt-b &#123;       ❶ 检测是否溢出</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"int overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在乘法中检测整数溢出</strong></p>
<p>乘法运算处理起来稍微有点复杂。我们需要对最小整数math.MinInt进行检查：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MultiplyInt</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span> || b == <span class="number">0</span> &#123;                       ❶ 其中一个为<span class="number">0</span>，直接返回 <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    result := a * b</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">1</span> || b == <span class="number">1</span> &#123;                       ❷ 检查操作数之一是否等于<span class="number">1</span>，等于<span class="number">1</span>则直接返回 result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> a == math.MinInt || b == math.MinInt &#123;   ❸ 检查操作数之一是否等于 math.MinInt</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"integer overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result/b != a &#123;                          ❹ 检查乘法是否导致整数溢出</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"integer overflow"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们需要测试其中一个运算数是否等于0、1或math.MinInt。然后，我们将乘法结果除以b。如果结果与原因数（a）不相等，则表示发生了整数溢出。</p>
<p>简而言之，在Go语言中，整数溢出（和下溢）是不带提示的操作。如果我们想要检查溢出以避免不明错误，我们可以使用本节中描述的实用程序函数。此外，请记住，Go语言提供了一个用于处理大型数字的包：math/big。如果int类型不够用，这可能是一个选择。</p>
<h3 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h3><p>在Go语言中，除了虚数之外，有两种浮点数类型：float32和float64。浮点数的概念是为了解决整数的主要问题：无法表示分数值。为了避免出现意外情况，我们需要知道浮点数运算是实数运算的近似值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="keyword">float32</span> = <span class="number">1.0001</span></span><br><span class="line">fmt.Println(n * n)</span><br></pre></td></tr></table></figure>
<p>我们可能期望这段代码打印出 1.0001 * 1.0001 的结果为 1.00020001，是不是对的呢？然而，在大多数 x86 处理器上运行它会打印出 1.0002。那我们该如何解释呢？</p>
<p><code>math.SmallestNonzeroFloat64</code>（float64最小值）和 <code>math.MaxFloat64</code>（float64最大值）之间有无限数量的实数值。相反，float64类型具有有限数量的位数：64。因为将无限值装入有限空间是不可能的，所以我们必须使用近似值。因此，我们可能会失去精度。同样的逻辑也适用于float32类型。</p>
<p>在Go中，浮点数遵循IEEE-754标准，其中一些位表示余数，另一些位表示指数。余数是一个基础值，而指数是应用于余数的乘数。在单精度浮点类型（float32）中，8个位表示指数，23个位表示余数。在双精度浮点类型（float64）中，分别为11个位和52个位的指数和余数。剩余一个位用于表示符号。</p>
<ul>
<li><p>标记(sign)  —— 表示正负</p>
</li>
<li><p>指数(exponent) —— float32(8位) 、float64(11位)</p>
</li>
<li><p>尾数(mantissa) —— float32(23位) 、float64(52位)</p>
</li>
</ul>
<p>公式为：<code>sign * 2^exponent * mantissa</code>，例如：在float32中表示1.0001</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308082155084.png" alt></p>
<p>一旦我们意识到 float32 和 float64 是近似值。在使用 == 运算符比较两个浮点数可能会导致不准确。相反，我们应该比较它们的差异，以查看它是否小于某个小错误值。例如，<a href="https://github.com/stretchr/testify" target="_blank" rel="noopener">testify库</a> 具有InDelta函数，以断言两个值是否彼此之间差值在给定的delta内。</p>
<p>浮点运算的结果取决于实际处理器。大多数处理器都有浮点单元（FPU）来处理这种计算。不能保证在一台机器上执行的结果与具有不同FPU的另一台机器上执行的结果相同。</p>
<p>Go 还拥有三种特殊的浮点数：</p>
<ul>
<li>正无穷</li>
<li>负无穷</li>
<li>NaN</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">float64</span></span><br><span class="line">positiveInf := <span class="number">1</span> / a</span><br><span class="line">negativeInf := <span class="number">-1</span> / a</span><br><span class="line">nan := a / a</span><br><span class="line">fmt.Println(positiveInf, negativeInf, nan)</span><br><span class="line"><span class="comment">// +Inf -Inf NaN</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用math.IsInf 来检查一个浮点数是否为无穷大，使用math.IsNaN来检查它是否为NaN。</p>
<p>误差还可以在浮点数的计算中积累，有两个函数以不同的顺序执行相同的操作序列。在我们的例子中，f1首先将float64初始化为10,000，然后重复将1.0001加到结果中（n次）。相反，f2按相反的顺序执行相同的操作（在末尾加上10,000）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    result := <span class="number">10</span>_000.</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        result += <span class="number">1.0001</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    result := <span class="number">0.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        result += <span class="number">1.0001</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result + <span class="number">10</span>_000.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果误差如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">n</th>
<th style="text-align:left">Exact result</th>
<th style="text-align:left">f1</th>
<th style="text-align:left">f2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:left">10010.001</td>
<td style="text-align:left">10010.099999999993</td>
<td style="text-align:left">10010.001</td>
</tr>
<tr>
<td style="text-align:center">1k</td>
<td style="text-align:left">11000.1</td>
<td style="text-align:left">11000.099999999293</td>
<td style="text-align:left">11000.099999999982</td>
</tr>
<tr>
<td style="text-align:center">1m</td>
<td style="text-align:left">1.0101e+06</td>
<td style="text-align:left">1.0100999999761417e+06</td>
<td style="text-align:left">1.0100999999766762e+06</td>
</tr>
</tbody>
</table>
<p>n越大，误差越大。然而，我们也可以看到，f2的精度比f1更好。结论是，当进行一系列加减操作时，我们应该将具有相似数量级的值进行分组，然后再进行加减运算，以便先进行相同数量级的加减运算，最后再进行数量级不同的加减操作。因为f2加了一万，所以它最终会得到比f1更准确的结果。</p>
<p>另一个例子是乘法的分配律：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">100000.001</span></span><br><span class="line">b := <span class="number">1.0001</span></span><br><span class="line">c := <span class="number">1.0002</span></span><br><span class="line"> </span><br><span class="line">fmt.Println(a * (b + c))</span><br><span class="line">fmt.Println(a*b + a*c)</span><br><span class="line"><span class="comment">// 200030.00200030004</span></span><br><span class="line"><span class="comment">// 200030.0020003</span></span><br></pre></td></tr></table></figure>
<p>准确的结果是200,030.002。因此，第一次计算具有最差的准确性。实际上，当进行浮点数加法、减法、乘法或除法的计算时，我们必须先完成乘法和除法运算以获得更好的准确性。有时，这可能会影响执行时间（在前面的例子中，需要三个操作而不是两个）。在这种情况下，需要在准确性和执行时间之间做出选择。</p>
<p>总结：</p>
<ol>
<li>在比较两个浮点数时，检查它们的差异是否在可接受的范围内。</li>
<li>在进行加法或减法运算时，将具有相似数量级的运算进行分组，以提高精度。</li>
<li>为了保证准确性，如果一系列操作需要进行加减乘除，应先执行乘法和除法运算。</li>
</ol>
<h3 id="切片长度和容量"><a href="#切片长度和容量" class="headerlink" title="切片长度和容量"></a>切片长度和容量</h3><p><code>length</code>表示当前的长度，<code>capacity</code>表示容量。如果两者相等，再<code>append</code>就会触发扩容。如果切片的容量小于 1,024 个元素，那么切片会先按照两倍扩充，之后再按照 25% 的速度扩充。</p>
<h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h3><p>在使用make初始化一个切片时，我们必须提供长度和可选容量。忘记传递这两个参数中的任一个适当的值都是一个普遍的错误。</p>
<p>假设我们想要实现一个转换函数，将一个 Foo 切片映射为一个 Bar 切片，并且两个切片具有相同数量的元素。这是第一种实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(foos []Foo)</span> []<span class="title">Bar</span></span> &#123;</span><br><span class="line">    bars := <span class="built_in">make</span>([]Bar, <span class="number">0</span>)                   ❶ 创建保存的切片</span><br><span class="line">    <span class="keyword">for</span> _, foo := <span class="keyword">range</span> foos &#123;</span><br><span class="line">        bars = <span class="built_in">append</span>(bars, fooToBar(foo))   ❷ 将 Foo 转为 Bar 并将其添加到切片中</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始，bars 是空的，所以添加第一个元素会分配一个大小为1的数组。每次支持数组满了，Go会创建另一个数组，将容量加倍。当我们添加第三个元素、第五个元素、第九个元素时，因为当前数组已满，所以会再次创建另一个数组的逻辑会重复出现多次。</p>
<p>假设输入的 foos 超过 1,000个元素，这个算法将分配10个数组（每次按照两倍扩容），并在总共从一个数组复制超过1,000个元素。这导致 GC 需要额外的工作来清理所有这些临时数组。</p>
<p>我们来看看第二种写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(foos []Foo)</span> []<span class="title">Bar</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(foos)</span><br><span class="line">    bars := <span class="built_in">make</span>([]Bar, <span class="number">0</span>, n)                ❶ 长度设置为<span class="number">0</span>，容量为 foos 的长度</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, foo := <span class="keyword">range</span> foos &#123;</span><br><span class="line">        bars = <span class="built_in">append</span>(bars, fooToBar(foo))   ❷ 将 Foo 转为 Bar 并将其添加到切片中</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接分配长度，而不是容量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(foos []Foo)</span> []<span class="title">Bar</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(foos)</span><br><span class="line">    bars := <span class="built_in">make</span>([]Bar, n)         ❶ 根据给定的长度初始化</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i, foo := <span class="keyword">range</span> foos &#123;</span><br><span class="line">        bars[i] = fooToBar(foo)    ❷ 设置切片的第 i 个元素。注意这里不是 <span class="built_in">append</span> 了</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们使用长度初始化了切片，n个元素已经被分配并初始化为Bar的零值。因此，我们不是使用append，而是使用bars[i]。</p>
<p>比较三个方案，当我们不断分配数组和复制元素时，第一个基准测试比另外两个慢了近400%。比较第二个和第三个解决方案，第三个方案快了约4％，因为我们避免了对内置的append函数的重复调用，这与直接赋值相比有一些开销。使用切片的下标来操作切片虽然比 append 要快，但是在可读性上有所缺失，特别是代码逻辑比较复杂的时候，我们可以在其中进行取舍，找到合适自己的。</p>
<h3 id="nil-切片和-empty-切片"><a href="#nil-切片和-empty-切片" class="headerlink" title="nil 切片和 empty 切片"></a>nil 切片和 empty 切片</h3><p>定义：</p>
<ol>
<li>如果一个 slice 的长度为 0，它就是空的。</li>
<li>如果一个切片等于nil，那么它就是nil。</li>
</ol>
<p>猜猜以下代码的输出是什么：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">string</span>         ❶ empty=<span class="literal">true</span>   <span class="literal">nil</span>=<span class="literal">true</span></span><br><span class="line">    log(<span class="number">1</span>, s)</span><br><span class="line"> </span><br><span class="line">    s = []<span class="keyword">string</span>(<span class="literal">nil</span>)      ❷ empty=<span class="literal">true</span>   <span class="literal">nil</span>=<span class="literal">true</span></span><br><span class="line">    log(<span class="number">2</span>, s)</span><br><span class="line"> </span><br><span class="line">    s = []<span class="keyword">string</span>&#123;&#125;         ❸ empty=<span class="literal">true</span>   <span class="literal">nil</span>=<span class="literal">false</span></span><br><span class="line">    log(<span class="number">3</span>, s)</span><br><span class="line"> </span><br><span class="line">    s = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)  ❹ empty=<span class="literal">true</span>   <span class="literal">nil</span>=<span class="literal">false</span></span><br><span class="line">    log(<span class="number">4</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(i <span class="keyword">int</span>, s []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d: empty=%t\tnil=%t\n"</span>, i, <span class="built_in">len</span>(s) == <span class="number">0</span>, s == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">1: empty=true   nil=true</span></span><br><span class="line"><span class="string">2: empty=true   nil=true</span></span><br><span class="line"><span class="string">3: empty=true   nil=false</span></span><br><span class="line"><span class="string">4: empty=true   nil=false</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>以上四种创建切片的方式，分别适合在什么场景下使用呢:</p>
<ol>
<li><code>var s []string</code>不确定最终长度并且 slice 可以为空时</li>
<li><code>s = []string(nil)</code>作为语法糖创建一个 nil slice</li>
<li><code>s = []string{}</code>在有初始化元素的时候使用</li>
<li><code>s = make([]string, 0)</code>长度已知</li>
</ol>
<p>结论：</p>
<ol>
<li><p>一个 nil slice 和一个空的 slice 的主要区别之一在于分配。初始化一个 nil slice 不需要分配任何内存空间，而空的 slice 则不是这种情况。</p>
</li>
<li><p>无论切片是否为 nil，调用 append 内置函数都能正常工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">string</span></span><br><span class="line">fmt.Println(<span class="built_in">append</span>(s1, <span class="string">"foo"</span>)) <span class="comment">// [foo]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当方法返回切片的时候，如果可能，应该返回一个 nil slice，而不是一个空切片。例如以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">string</span>  				<span class="comment">// nil 切片</span></span><br><span class="line">    <span class="keyword">if</span> foo() &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, <span class="string">"foo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> bar() &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, <span class="string">"bar"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s  							<span class="comment">// 如果上述 if 都不成立，那么返回一个 nil 切片。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些包切分 nil 切片和 空切片，比如在 encoding/json 包中就是如此。一个空的切片会被序列化成一个 null 元素，而一个非空的空切片会被序列化成一个空数组。还有在使用 <code>reflect.DeepEqual</code> 比较一个 nil 和一个非 nil 的空切片时，将会返回 false。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">float32</span>                 ❶ <span class="literal">nil</span> 切片</span><br><span class="line">customer1 := customer&#123;</span><br><span class="line">    ID:         <span class="string">"foo"</span>,</span><br><span class="line">    Operations: s1,</span><br><span class="line">&#125;</span><br><span class="line">b, _ := json.Marshal(customer1)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line"> </span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">float32</span>, <span class="number">0</span>)         ❷ 空切片</span><br><span class="line">customer2 := customer&#123;</span><br><span class="line">    ID:         <span class="string">"bar"</span>,</span><br><span class="line">    Operations: s2,</span><br><span class="line">&#125;</span><br><span class="line">b, _ = json.Marshal(customer2)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">&#123;"</span>ID<span class="string">":"</span>foo<span class="string">","</span>Operations<span class="string">":null&#125;</span></span><br><span class="line"><span class="string">&#123;"</span>ID<span class="string">":"</span>bar<span class="string">","</span>Operations<span class="string">":[]&#125;</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="检查切片是否为空"><a href="#检查切片是否为空" class="headerlink" title="检查切片是否为空"></a>检查切片是否为空</h3><p>判断一个切片是否包含元素的惯用方法是什么？</p>
<p>以下代码是个错误示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleOperations</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    operations := getOperations(id)</span><br><span class="line">    <span class="keyword">if</span> operations != <span class="literal">nil</span> &#123;                  ❶ 检查切片是否为 <span class="literal">nil</span></span><br><span class="line">        handle(operations)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOperations</span><span class="params">(id <span class="keyword">string</span>)</span> []<span class="title">float32</span></span> &#123;</span><br><span class="line">    operations := <span class="built_in">make</span>([]<span class="keyword">float32</span>, <span class="number">0</span>)        ❷ 创建一个 空切片</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> id == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> operations                   ❸ 返回空切片</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Add elements to operations</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> operations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中， operations！= nil 将始终为 true。因为我们创建一个空切片。</p>
<p>我们有两种解决方案：</p>
<p>方案1: 当 <code>id == &quot;&quot;</code> 时，返回 nil 而不是创建的 空切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOperations</span><span class="params">(id <span class="keyword">string</span>)</span> []<span class="title">float32</span></span> &#123;</span><br><span class="line">    operations := <span class="built_in">make</span>([]<span class="keyword">float32</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> id == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>      ❶ 返回 <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Add elements to operations</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> operations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案2: 检查切片的长度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleOperations</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    operations := getOperations(id)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(operations) != <span class="number">0</span> &#123;          ❶ 检查长度而不是判断是否为 <span class="literal">nil</span></span><br><span class="line">        handle(operations)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，不管切片是 nil 还是空，长度总是为 0。所以检查长度是判断一个切片是否包含元素的惯用方法。这个规则同样适用于 map，要检查 map 是否为空，应该检查其长度，而不是判断它是否为 nil。</p>
<h3 id="copy-切片"><a href="#copy-切片" class="headerlink" title="copy 切片"></a>copy 切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> dst []<span class="keyword">int</span></span><br><span class="line"><span class="built_in">copy</span>(dst, src)</span><br><span class="line">fmt.Println(dst)</span><br></pre></td></tr></table></figure>
<p>上述代码中，打印的 dst 值为 []。src 是一个长度为 3 的切片，而 dst 是一个长度为 0 的切片，因为它被初始化为它的零值。因此，copy 函数只会复制最少数量的元素（在 0 和 3 之间）：在这种情况下是 0。最终得到一个空的切片。所以，复制到目标切片的元素数量取决于以下两者中的最小值</p>
<ul>
<li>源切片的长度</li>
<li>目标切片的长度</li>
</ul>
<p>正确代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(src))     ❶ 创建一个给定长度的 dst 切片</span><br><span class="line"><span class="built_in">copy</span>(dst, src)  <span class="comment">// 目标是前一个参数，而源是后一个参数</span></span><br><span class="line">fmt.Println(dst)</span><br></pre></td></tr></table></figure>
<p>还有一种方案是使用 append</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">dst := <span class="built_in">append</span>([]<span class="keyword">int</span>(<span class="literal">nil</span>), src...)</span><br></pre></td></tr></table></figure>
<h3 id="slice-共享底层数组带来的问题"><a href="#slice-共享底层数组带来的问题" class="headerlink" title="slice 共享底层数组带来的问题"></a>slice 共享底层数组带来的问题</h3><p>由于 slice 底层的 data 指向的同一块连续内存，所以当我们在切片然后再进行 append 的时候，可能会修改到底层的数组，从而影响整个 slice。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := s1[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">s3 := <span class="built_in">append</span>(s2, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 上述代码中，s1=[1 2 10], s2=[2], s3=[2 10]</span></span><br></pre></td></tr></table></figure>
<p>例如：下面的示例中，我们使用三个元素初始化一个切片，并仅将前两个元素传递给一个函数。然后在 f 中调用 append，它将会更新切片的第三个元素，即使我们只传递了两个元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"> </span><br><span class="line">    f(s[:<span class="number">2</span>])</span><br><span class="line">    fmt.Println(s) <span class="comment">// [1 2 10]</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    _ = <span class="built_in">append</span>(s, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种解决方法：复制切片，传递切片的副本</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    sCopy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">copy</span>(sCopy, s)                    ❶ 将s的前两个元素复制到 sCopy 中</span><br><span class="line"> </span><br><span class="line">    f(sCopy)</span><br><span class="line">    result := <span class="built_in">append</span>(sCopy, s[<span class="number">2</span>])     ❷ 将s[<span class="number">2</span>] 添加到 sCopy 中</span><br><span class="line">    <span class="comment">// Use result</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Update s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法：使用完整切片表达式 s [low:high:max]。 此语句创建一个类似于使用s [low：high]创建的切片，只是所得到的切片容量等于max-low。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    f(s[:<span class="number">2</span>:<span class="number">2</span>])            ❶ 完整的切片表达式传递子切片，子切片的容量为 <span class="number">2</span></span><br><span class="line">    <span class="comment">// Use s</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Update s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>如果从一个切片生成一个子切片，但是如果生成的子切片长度小于其容量，则 append 到子切片的数据可能会修改原始切片。为了限制可能副作用的范围，我们可以 copy 出一个切片副本，或使用完整的切片表达式来解决这种问题。</p>
<h3 id="切片内存泄漏"><a href="#切片内存泄漏" class="headerlink" title="切片内存泄漏"></a>切片内存泄漏</h3><p><strong>切片容量导致的内存泄漏</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumeMessages</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        msg := receiveMessage()      ❶ 假设一个消息包含一百万个字节，前五个字节表示消息的类型</span><br><span class="line">        <span class="comment">// Do something with msg</span></span><br><span class="line">        storeMessageType(getMessageType(msg))    ❷ 在内存中存储最新的<span class="number">1000</span>个消息类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMessageType</span><span class="params">(msg []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;         ❸ 通过切片获取消息类型</span><br><span class="line">    <span class="keyword">return</span> msg[:<span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行会非常消耗内存，因为使用 msg[:5] 进行切片操作可以创建一个长度为 5 的切片。然而，它的容量仍与初始切片相同。即使最终 msg 未被引用，其余元素仍会被分配在内存中。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308142134038.png" alt></p>
<p>新的循环之后，msg不再使用。然而，msg[:5]仍然会使用它的底层数组。切片的底层数组仍包含 100万字节。因此，如果我们将1,000条消息保存在内存中，我们将持有大约1 GB而不是大约5 KB的空间。</p>
<p>解决方法：</p>
<p>我们可以复制一个切片，而不是对 msg 进行切片操作来解决这个问题。因为我们执行 copy，所以无论接收到的消息大小如何，msgType 都是一个长度为5、容量为5的切片。因此，我们仅存储每个消息类型的5个字节。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMessageType</span><span class="params">(msg []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    msgType := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">copy</span>(msgType, msg)</span><br><span class="line">    <span class="keyword">return</span> msgType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果我们使用完整的切片表达式，则还是会存在内存泄漏的情况，即不会释放底层数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMessageType</span><span class="params">(msg []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msg[:<span class="number">5</span>:<span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>切片与指针导致的内存泄漏</strong></p>
<p>定一个结构体，其中包含一个字节切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    v []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foos := <span class="built_in">make</span>([]Foo, <span class="number">1</span>_000)              ❶ 分配一个 <span class="number">1000</span> 个元素的切片</span><br><span class="line">    printAlloc()  <span class="comment">// 打印内存使用</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(foos); i++ &#123;        ❷ 循环 <span class="number">1000</span> 个元素，将每个元素分配 <span class="number">1</span>M 的切片</span><br><span class="line">        foos[i] = Foo&#123;</span><br><span class="line">            v: <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printAlloc()  <span class="comment">// 打印内存使用</span></span><br><span class="line"> </span><br><span class="line">    two := keepFirstTwoElementsOnly(foos)   ❸ 保留前两个元素</span><br><span class="line">    runtime.GC()                            ❹ 垃圾回收</span><br><span class="line">    printAlloc()  <span class="comment">// 打印内存使用</span></span><br><span class="line">    runtime.KeepAlive(two)                  ❺ 保留对两个变量的引用</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepFirstTwoElementsOnly</span><span class="params">(foos []Foo)</span> []<span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foos[:<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">83 KB</span><br><span class="line">1024072 KB</span><br><span class="line">1024072 KB     ❶ 切片操作后内存仍没有缩小</span><br></pre></td></tr></table></figure>
<p>原因是，在使用切片时，如果元素是指针或带有指针字段的结构体，则元素不会被垃圾回收器回收。在我们的示例中，因为Foo包含一个切片（切片是基于一个底层数组的指针），所以即使这些 998 个元素无法访问，只要keepFirstTwoElementsOnly 返回的变量被引用，它们仍然会留在内存中。</p>
<p>第一种解决方法是，再次创建一个切片副本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepFirstTwoElementsOnly</span><span class="params">(foos []Foo)</span> []<span class="title">Foo</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]Foo, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, foos)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们复制了切片的前两个元素，垃圾回收器知道剩下的998个元素将不再被引用，因此现在可以进行回收。</p>
<p>第二种解决方法是，将剩余的切片元素明确的标记为 nil。因此，GC 可以回收底层 998个不使用的数组空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepFirstTwoElementsOnly</span><span class="params">(foos []Foo)</span> []<span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(foos); i++ &#123;</span><br><span class="line">        foos[i].v = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foos[:<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<ol>
<li>在对大的 slice 或者数组进行切片操作时，可能会导致高内存消耗。剩余的空间不会被垃圾回收机制回收，因此即使我们只使用了其中的几个元素，我们仍然可能会占用很大的底层数组。使用 copy slice 的方式是避免这种情况的解决方案。</li>
<li>当我们使用切片操作与指针或具有指针字段的结构体时，GC不会回收切片剩下的这些元素。在这种情况下，可以执行 copy 或明确标记剩余元素字段为空值来解决问题。</li>
</ol>
<h3 id="低效的-map-初始化"><a href="#低效的-map-初始化" class="headerlink" title="低效的 map 初始化"></a>低效的 map 初始化</h3><h4 id="map-原理"><a href="#map-原理" class="headerlink" title="map 原理"></a>map 原理</h4><p>map 是基于哈希表数据结构的。哈希表是一个桶的数组，每个桶是一个指向键值对数组的指针。每个桶的大小固定为8个元素。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308152148145.png" alt></p>
<p>每个操作（读取、更新、插入、删除）都是通过将键与数组索引关联来完成的。这一步依赖于哈希函数。由于我们希望该函数始终返回相同的桶，因此该函数是稳定的。例如，哈希函数作用在 two 上返回 0；因此，该元素存储在由数组索引 0 引用的桶中。</p>
<p>如果我们插入另一个元素，哈希函数返回相同的索引，则Go将另一个元素添加到同一个桶中。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308152147814.png" alt></p>
<p>如果插入已经满的桶（桶溢出），Go 会创建另一个8元素的桶并将前一个桶连接到它。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308152153139.png" alt></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>什么时候 map 会进行扩容呢？</p>
<ol>
<li>桶中的平均项数（称为负载因子）大于一个固定值。该常数等于6.5（但它可能会在将来的版本中改变，因为它是 Go 的内部常数）</li>
<li>太多的桶已经溢出（含有超过八个元素）</li>
</ol>
<p>当 map 扩容时，所有的键都会再次分配到所有的桶中。这就是为什么在最坏情况下，插入一个键可能是一个O(n)操作，其中n是 map 中元素的总数。</p>
<p>也可以像使用 slice 一样，在初始化的时候就指定 map 的大小，如下所示，该 map 是使用足够数量的桶创建的，以存储100万个元素。这样做可以节省大量的计算时间，因为 map 不必动态创建桶并重新平衡。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">1</span>_000_000)</span><br></pre></td></tr></table></figure>
<p>同时，指定大小 n 并不意味着创建最多有 n 个元素的映射。我们仍然可以添加超过 n 个元素。</p>
<p><strong>🎡总结</strong></p>
<p>就像切片一样，如果我们事先知道 map 包含的元素数量，我们应该通过提供初始大小来创建它。这样做可以避免潜在的 map 扩容，这对计算机而言是相当沉重的计算，因为它需要重新分配足够的空间并重新平衡所有元素。</p>
<h3 id="map-内存泄漏"><a href="#map-内存泄漏" class="headerlink" title="map 内存泄漏"></a>map 内存泄漏</h3><p>我们分配了一个空的map，添加了100万个元素，再删除100万个元素，然后运行了一次垃圾回收。我们还使用runtime.KeepAlive 确保保留对该 map 的引用，以防止其被回收。让我们运行此示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">1</span>_000_000</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][<span class="number">128</span>]<span class="keyword">byte</span>)</span><br><span class="line">printAlloc()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;      ❶ 增加一百万个元素</span><br><span class="line">    m[i] = randBytes()</span><br><span class="line">&#125;</span><br><span class="line">printAlloc()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;      ❷ 删除一百万个元素</span><br><span class="line">    <span class="built_in">delete</span>(m, i)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">runtime.GC()                  ❸ 手动触发 GC</span><br><span class="line">printAlloc()</span><br><span class="line">runtime.KeepAlive(m)          ❹ 保留对 m 的引用，防止 <span class="keyword">map</span> 被回收</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> MB       ❶ </span><br><span class="line"><span class="number">461</span> MB     ❷ 添加一百万元素之后</span><br><span class="line"><span class="number">293</span> MB     ❸ 删除一百万元素之后</span><br></pre></td></tr></table></figure>
<p>最终，尽管 GC 收集了所有元素，但堆大小仍为293 MB。因此，内存已经缩小，但与我们的预期不同（还存在内存占用）。这是为什么？</p>
<p>原因在于 map 中桶的数量不可收缩。因此，从 map 中删除元素不会影响现有桶的数量；它只会将桶中的插槽清零。 即 map 只能增长并拥有更多的桶，而不会缩小桶的数量。</p>
<p>有什么解决方法呢？</p>
<ol>
<li>使用复制的方法，定期重新创建当前 map 的副本。例如，每个小时我们可以建立一个新 map，复制所有元素并释放之前的 map，这种方法的主要缺点是在复制之后直到下一次垃圾回收之前，我们可能会在短时间内消耗两倍于当前内存。</li>
<li>将 map 类型更改为存储数组指针：map[int]*[128]byte。这并不能解决我们将拥有大量桶的事实; 但是，每个桶条目将保留值的指针大小（64位系统上为8字节，32位系统上为4字节），而不是128字节。</li>
</ol>
<h3 id="错误的值比较"><a href="#错误的值比较" class="headerlink" title="错误的值比较"></a>错误的值比较</h3><p>何时适合使用 ==，还有什么其他方案呢？看一个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customer <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cust1 := customer&#123;id: <span class="string">"x"</span>&#125;</span><br><span class="line">    cust2 := customer&#123;id: <span class="string">"x"</span>&#125;</span><br><span class="line">    fmt.Println(cust1 == cust2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较这两个结构体它会打印 true。那么，如果我们对结构体进行轻微修改以添加一个切片字段，会发生什么呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customer <span class="keyword">struct</span> &#123;</span><br><span class="line">    id         <span class="keyword">string</span></span><br><span class="line">    operations []<span class="keyword">float64</span>      ❶ 添加一个切片字段</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cust1 := customer&#123;id: <span class="string">"x"</span>, operations: []<span class="keyword">float64</span>&#123;<span class="number">1.</span>&#125;&#125;</span><br><span class="line">    cust2 := customer&#123;id: <span class="string">"x"</span>, operations: []<span class="keyword">float64</span>&#123;<span class="number">1.</span>&#125;&#125;</span><br><span class="line">    fmt.Println(cust1 == cust2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，会出现无法编译的情况。因为这涉及到 == 和 != 运算符的工作原理。这些运算符无法与切片或 map 一起使用。因此，由于上述结构包含一个切片，所以它无法编译。</p>
<p>slices &amp; maps 是无法通过<code>==</code>比较的。我们可以看下哪些是可比较的：</p>
<ol>
<li>Booleans 比较值是否相等</li>
<li>Numerics (int, float, and complex types) 比较值是否相等</li>
<li>Strings 比较内容</li>
<li>Channels 比较是否是同一个make创建的，或者是否都是nil</li>
<li>Interfaces 比较是否有相同的类型和值 或者是否都是nil</li>
<li>Pointers 指针比较是否都指向同一个值 或者是否都是nil</li>
<li>Structs and arrays 比较组成的简单类型</li>
</ol>
<p>我们更新一下上述的例子，但是将使用 any 来接收值，然后在用于比较，会有什么现象呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cust1 any = customer&#123;id: <span class="string">"x"</span>, operations: []<span class="keyword">float64</span>&#123;<span class="number">1.</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> cust2 any = customer&#123;id: <span class="string">"x"</span>, operations: []<span class="keyword">float64</span>&#123;<span class="number">1.</span>&#125;&#125;</span><br><span class="line">fmt.Println(cust1 == cust2)</span><br></pre></td></tr></table></figure>
<p>现象是可以编译通过，但是无法进行比较，会产生一个错误。</p>
<p>那么有什么解决方法呢？</p>
<p>答案是，我们可以使用 reflect.DeepEqual。该函数通过递归遍历两个值来检查两个元素是否深度相等。它接受的元素包括基本类型以及数组、结构体、切片、map、指针、接口和函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cust1 := customer&#123;id: <span class="string">"x"</span>, operations: []<span class="keyword">float64</span>&#123;<span class="number">1.</span>&#125;&#125;</span><br><span class="line">cust2 := customer&#123;id: <span class="string">"x"</span>, operations: []<span class="keyword">float64</span>&#123;<span class="number">1.</span>&#125;&#125;</span><br><span class="line">fmt.Println(reflect.DeepEqual(cust1, cust2))</span><br></pre></td></tr></table></figure>
<p>但是，平均而言，reflect.DeepEqual比==慢大约100倍。如果性能是至关重要的因素，另一个选择是我们自己实现比较的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a customer)</span> <span class="title">equal</span><span class="params">(b customer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a.id != b.id &#123;                             ❶ 比较 id 字段</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a.operations) != <span class="built_in">len</span>(b.operations) &#123;   ❷ 检查两个切片的长度</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a.operations); i++ &#123;      ❸ 比较两个切片中的每个元素</span><br><span class="line">        <span class="keyword">if</span> a.operations[i] != b.operations[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的自定义相等方法大约比 reflect.DeepEqual 快96倍</p>
<p><strong>🎡总结</strong></p>
<p>通常情况下，我们应该记住 “==” 运算符的局限性。例如，它不能用于切片和 map。在大多数情况下，使用reflect.DeepEqual 是一种解决方案，但主要问题是性能不好。</p>
<h3 id="range-循环是值拷贝"><a href="#range-循环是值拷贝" class="headerlink" title="range 循环是值拷贝"></a>range 循环是值拷贝</h3><p><code>range</code>是一个比较方便的控制循环的方式，可用于：</p>
<ol>
<li>字符串</li>
<li>数组</li>
<li>指针数组</li>
<li>切片</li>
<li>Map</li>
<li>接收的channel</li>
</ol>
<p>我们创建一个 account 结构体，包含一个单一的余额字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> account <span class="keyword">struct</span> &#123;</span><br><span class="line">    balance <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个账户结构的切片，并使用范围循环迭代每个元素。在每次迭代期间，我们会增加每个账户的余额：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">accounts := []account&#123;</span><br><span class="line">    &#123;balance: <span class="number">100.</span>&#125;,</span><br><span class="line">    &#123;balance: <span class="number">200.</span>&#125;,</span><br><span class="line">    &#123;balance: <span class="number">300.</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> accounts &#123;</span><br><span class="line">    a.balance += <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是：<code>[{100} {200} {300}]</code>。原因是，因为我们修改的是一份值拷贝，当循环迭代数据结构时，它将每个元素复制到值变量（第二项）中。</p>
<p>在 Go 语言中，都是值的复制。例如一个函数返回一个结构体，在使用一个变量接收，那么变量接收到的将是该结构体的复制。如果我们将返回指针的函数的结果分配给变量，它将执行内存地址的复制。</p>
<p>那么上面问题有什么解决方案呢？</p>
<p>第一种方案是使用索引下标来解决：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> accounts &#123;                ❶ 使用索引变量访问切片的元素</span><br><span class="line">    accounts[i].balance += <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(accounts); i++ &#123;     ❷ 使用传统的 <span class="keyword">for</span> 循环，使用下标来访问切片元素</span><br><span class="line">    accounts[i].balance += <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种选择是继续使用 range 循环访问值，但将切片类型修改为帐户指针的切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">accounts := []*account&#123;       ❶ 将切片类型更新为 []*account</span><br><span class="line">    &#123;balance: <span class="number">100.</span>&#125;,</span><br><span class="line">    &#123;balance: <span class="number">200.</span>&#125;,</span><br><span class="line">    &#123;balance: <span class="number">300.</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> accounts &#123;</span><br><span class="line">    a.balance += <span class="number">1000</span>         ❷ 直接更新切片的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量 a 是存储在切片中的 account 指针的副本。由于指针引用同一结构体，所以 a.balance += 1000 语句会更新切片元素。</p>
<p>然而，这种选择有两个主要缺点。首先，它需要更新切片类型（更改为指针）。其次，如果性能很重要，迭代指针切片可能对CPU来说效率较低。</p>
<p><strong>🎡总结</strong></p>
<p>较为推荐的方案是，通过使用 range 循环或经典的 for 循环，来通过索引访问该元素。</p>
<h3 id="range-对象何时被计算"><a href="#range-对象何时被计算" class="headerlink" title="range 对象何时被计算"></a>range 对象何时被计算</h3><p>下面代码会陷入死循环吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是不会，在使用 range 循环时，提供的表达式仅在循环开始之前被评估一次。在这个上下文中，“评估”意味着提供的表达式被复制到一个临时变量中，然后在遍历这个变量。也就是说，上述被遍历的 s 变量会被拷贝到一个临时变量中在进行遍历。</p>
<p>那如果变成下面这样的话， 代码就会陷入循环，永远不会结束。len(s) 表达式在每次迭代期间都会被评估，因为我们不断地添加元素，所以我们永远不会达到终止状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)     ❶ 创建一个通道，并在下面的协程中塞入元素 <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 &lt;- <span class="number">0</span></span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">    ch1 &lt;- <span class="number">2</span></span><br><span class="line">    <span class="built_in">close</span>(ch1)</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)     ❷ 创建另一个通道，并在下面的协程中塞入元素 <span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch2 &lt;- <span class="number">10</span></span><br><span class="line">    ch2 &lt;- <span class="number">11</span></span><br><span class="line">    ch2 &lt;- <span class="number">12</span></span><br><span class="line">    <span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line">ch := ch1                    ❸ 将第一个通道赋值给 ch</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;          ❹ 循环 ch</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">    ch = ch2                 ❺ 再将 ch2 赋值给 ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，还是会打印 0,1,2。原因在于 range 会评估 ch，将其复制到一个临时变量中。尽管有 ch = ch2 语句，range 仍会继续迭代 ch1 而非 ch2。</p>
<p>同理，在看另一个例子：我们循环数组 a，并将 a 的第三个元素修改为 10，然后我们打印第三个元素。此时输出结果还是2，而不是 10。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;      ❶ 创建包含三个元素的数组</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;     ❷ 遍历数组</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">10</span>             ❸ 更新最后一个元素的索引</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span> &#123;           ❹ 打印最后一个元素索引的内容</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因还是在于在 range 循环之前 a 变量被评估了一次（也就是复制到了临时变量中，所有后续不管在怎么通过下标更改，其迭代时候的值也不会发生变化）。</p>
<p>那如果我们就是想在迭代的时候进行值的修改，该怎么实现呢，有以下两种方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(a[<span class="number">2</span>])     ❶ 通过下标来访问值，而不是 <span class="keyword">range</span> 的变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> &amp;a &#123;     ❶ 使用数组指针</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="range-中使用指针"><a href="#range-中使用指针" class="headerlink" title="range 中使用指针"></a>range 中使用指针</h3><p>在使用 for 循环遍历数据时，我们必须记住所有的值都被分配给一个唯一的变量，该变量有一个单一的唯一地址。因此，如果我们在每次迭代中存储引用此变量的指针，那我们会得到指向同一元素的相同指针，即最新的指针。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Customer <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID      <span class="keyword">string</span></span><br><span class="line">    Balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line">    m <span class="keyword">map</span>[<span class="keyword">string</span>]*Customer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">storeCustomers</span><span class="params">(customers []Customer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, customer := <span class="keyword">range</span> customers &#123;</span><br><span class="line">        s.m[customer.ID] = &amp;customer         ❶ 在 <span class="keyword">map</span> 中存储指针</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.storeCustomers([]Customer&#123;</span><br><span class="line">    &#123;ID: <span class="string">"1"</span>, Balance: <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;ID: <span class="string">"2"</span>, Balance: <span class="number">-10</span>&#125;,</span><br><span class="line">    &#123;ID: <span class="string">"3"</span>, Balance: <span class="number">0</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">key=1, value=&amp;main.Customer&#123;ID:"</span><span class="number">3</span><span class="string">", Balance:0&#125;</span></span><br><span class="line"><span class="string">key=2, value=&amp;main.Customer&#123;ID:"</span><span class="number">3</span><span class="string">", Balance:0&#125;</span></span><br><span class="line"><span class="string">key=3, value=&amp;main.Customer&#123;ID:"</span><span class="number">3</span><span class="string">", Balance:0&#125;</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>上述代码的输出会是三个相同的额值，即 <code>{ID: &quot;3&quot;, Balance: 0}</code> 。出现这个问题的原因在于 for 循环遍历数据时，所有的值都被分配给一个唯一的变量，该变量有一个单一的唯一地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">storeCustomers</span><span class="params">(customers []Customer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, customer := <span class="keyword">range</span> customers &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%p\n"</span>, &amp;customer)      ❶ 打印 customer 地址，会发现是一样的</span><br><span class="line">        s.m[customer.ID] = &amp;customer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0xc000096020</span></span><br><span class="line"><span class="number">0xc000096020</span></span><br><span class="line"><span class="number">0xc000096020</span></span><br></pre></td></tr></table></figure>
<p>该指针的最后一次分配是切片的最后一个元素 Customer3 的引用。所以才会出现上述代码中的现象（打印了三个相同的值）</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308191015329.png" alt></p>
<p>我们可以通过强制在循环内创建一个局部变量或通过索引创建一个引用切片元素的指针来解决这个问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">storeCustomers</span><span class="params">(customers []Customer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, customer := <span class="keyword">range</span> customers &#123;</span><br><span class="line">        current := customer                 ❶ 创建一个局部变量，以解决这个问题</span><br><span class="line">        s.m[current.ID] = &amp;current       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">storeCustomers</span><span class="params">(customers []Customer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> customers &#123;</span><br><span class="line">        customer := &amp;customers[i]        ❶ 使用切片的索引创建一个引用切片元素的指针来解决</span><br><span class="line">        s.m[customer.ID] = customer    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-迭代中的常见问题"><a href="#map-迭代中的常见问题" class="headerlink" title="map 迭代中的常见问题"></a>map 迭代中的常见问题</h3><ol>
<li>map 的迭代顺序是没有规定的。每次迭代的顺序都是不同的。</li>
<li>在迭代过程中更新地图（插入或删除元素）是允许的；它不会导致编译错误或运行时错误。（但是在迭代过程中向 map 添加元素时，在后续迭代中可能会遇到该元素，也可能不会）</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">    <span class="number">0</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">if</span> v &#123;</span><br><span class="line">        m[<span class="number">10</span>+k] = <span class="literal">true</span>  <span class="comment">// 在遍历期间插入元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure>
<p>下面是运行上述代码可能得到的结果，因为一边遍历，一遍插入元素，所以会出现新插入的元素可能会在后面可见或者不可见。所以影响了最终的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[0:true 1:false 2:true 10:true 12:true 20:true 22:true 30:true]</span><br><span class="line">map[0:true 1:false 2:true 10:true 12:true 20:true 22:true 30:true 32:true]</span><br><span class="line">map[0:true 1:false 2:true 10:true 12:true 20:true]</span><br></pre></td></tr></table></figure></p>
<p><strong>🎡总结</strong></p>
<p>当我们使用 map 时，不应该依靠以下内容：</p>
<ol>
<li>数据按键排序</li>
<li>保留插入顺序</li>
<li>一个确定的迭代顺序</li>
<li>在同一轮迭代中添加元素，并期待后续在迭代中遇到该元素</li>
</ol>
<h3 id="break-的使用"><a href="#break-的使用" class="headerlink" title="break 的使用"></a>break 的使用</h3><p>记住一个 break 的原则：break 语句只会终止最深层的 for、switch 或 select 语句的执行。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span>      ❶ 这个 <span class="keyword">break</span> 不是终止 <span class="keyword">for</span>，而是终止 <span class="keyword">switch</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要终止 for ，最符合的方式是使用标签</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loop:                           ❶ 定一个循环标签</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> i &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">break</span> loop          ❷ <span class="keyword">break</span> loop标签。这样就能终止整个 <span class="keyword">for</span> 循环</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出 0，1，2</span></span><br></pre></td></tr></table></figure>
<p>例如，在下面示例中，我们想要在上下文被取消的时候中断循环:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loop:                          ❶ 定一个循环标签</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">            <span class="comment">// Do something</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">break</span> loop         ❷ 上下文被取消时，终止整个 <span class="keyword">for</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="在循环中使用-defer"><a href="#在循环中使用-defer" class="headerlink" title="在循环中使用 defer"></a>在循环中使用 defer</h3><p>defer 语句会被延迟调用 —— 直到包含它 defer 的函数返回时才会调用。这就会导致一些使用上的问题。</p>
<p>常见的错误就是不了解在循环中使用 defer 的后果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFiles</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> path := <span class="keyword">range</span> ch &#123;                    ❶ 遍历通道中的文件路径</span><br><span class="line">        file, err := os.Open(path)            ❷ 打开文件</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">defer</span> file.Close()                    ❸ 关闭文件</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Do something with file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defer 是在包含函数返回时调度函数调用，在这种情况下，defer 调用并不是在每个循环期间执行的，而是在 readFiles 函数返回时才执行。如果 readFiles 不返回，文件描述符将永远保持打开状态，导致内存泄漏。</p>
<p>一种解决的方法是放弃使用 defer，改为手动关闭文件。</p>
<p>另一种解决方法是，将文件的读取操作抽取出来单独封装在一个函数中，在其中实现 defer 的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFiles</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> path := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        <span class="keyword">if</span> err := readFile(path); err != <span class="literal">nil</span> &#123;    ❶ 每读取一个文件就关闭一个文件</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;  <span class="comment">// 将读取文件单独封装，确保 defer 能被执行</span></span><br><span class="line">    file, err := os.Open(path)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">defer</span> file.Close()                            ❷</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Do something with file</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种解决思路是将 readFile 函数设计为一个闭包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFiles</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> path := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        err := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">defer</span> file.Close()</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;()                  ❶ 运行闭包，确保调用 <span class="keyword">defer</span> 关闭文件</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种解决方法本质上和第二种是一致的。</p>
<h3 id="不理解-rune"><a href="#不理解-rune" class="headerlink" title="不理解 rune"></a>不理解 rune</h3><p>我们需要先理解两个基础概念：</p>
<ol>
<li>字符集 从名字理解就是字符的集合，比如 <code>Unicode</code>字符集包含了2^21字符。</li>
<li>编码 是一个字符列表在二进制种的翻译。比如UTF-8就是一种标准的编码格式，所有的字符都用1-4个字节表示。</li>
</ol>
<blockquote>
<p>代码点（Code Point）是指在字符编码标准中，每个字符所对应的唯一数值。字符编码是一种将字符映射到数字的方式，以便计算机能够处理和存储文本数据。不同的字符编码标准使用不同的方法来分配代码点。</p>
<p>最常见的字符编码之一是 Unicode，它为世界上几乎所有的字符都定义了唯一的代码点。Unicode使用十六进制表示代码点，例如大写字母”A”在Unicode中的代码点为U+0041，其中”U+”表示Unicode代码点的前缀，后面跟着四位十六进制数。— chatgpt</p>
</blockquote>
<p>在<code>Unicode</code>中，使用一个概念<code>代码点</code>去表示一个单值。比如<code>汉</code>这个字符的代码点就是<code>U+6C49</code>.使用UTF-8，<code>汉</code>被编码成3个字节：<code>0xE6, 0xB1, 0x89</code>。在Go中，<code>rune</code>就是一个代码点。所以在Go中，一个<code>rune</code>就是<code>int32</code>的别名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在Go语言中，<code>rune</code>类型实际上是一个<code>int32</code>类型的别名，用于表示一个Unicode代码点。这使得在处理和操作Unicode字符时更加方便，因为它可以容纳所有可能的Unicode代码点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;str := &quot;你好，世界！&quot;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;for _, r := range str &#123;</span><br><span class="line">&gt;    fmt.Printf(&quot;Unicode code point: %U\n&quot;, r)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>字符串 “你好，世界！” 中的每个字符都被转换为对应的Unicode代码点，并使用<code>%U</code>格式化输出。</p>
</blockquote>
<h3 id="字符串迭代和长度"><a href="#字符串迭代和长度" class="headerlink" title="字符串迭代和长度"></a>字符串迭代和长度</h3><p>len内置函数并不返回字符数，而是字节数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"汉"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 3 个字节</span></span><br><span class="line"></span><br><span class="line">s := <span class="keyword">string</span>([]<span class="keyword">byte</span>&#123;<span class="number">0xE6</span>, <span class="number">0xB1</span>, <span class="number">0x89</span>&#125;)</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, s)  <span class="comment">// 汉</span></span><br></pre></td></tr></table></figure>
<p>迭代字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hêllo"</span>            ❶ 包含一个特殊的符文：ê</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"position %d: %c\n"</span>, i, s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"len=%d\n"</span>, <span class="built_in">len</span>(s))</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">position 0: h</span></span><br><span class="line"><span class="string">position 1: Ã  // 错误的打印了字符</span></span><br><span class="line"><span class="string">position 3: l</span></span><br><span class="line"><span class="string">position 4: l</span></span><br><span class="line"><span class="string">position 5: o</span></span><br><span class="line"><span class="string">len=6  // 长度为6，但是只有5个字符，并且字符打印出错</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>这是因为，我们并不是迭代每一个符文；相反，我们是迭代每一个符文的起始索引</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308191252346.png" alt></p>
<p>有什么办法可以在迭代的时候正常显示呢？</p>
<p>方法一就是在迭代的时候不使用下标，而是使用变量本身</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hêllo"</span></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"position %d: %c\n"</span>, i, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">position 0: h</span></span><br><span class="line"><span class="string">position 1: ê</span></span><br><span class="line"><span class="string">position 3: l</span></span><br><span class="line"><span class="string">position 4: l</span></span><br><span class="line"><span class="string">position 5: o</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>方法二是将字符串转换为 rune 切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hêllo"</span></span><br><span class="line">runes := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> runes &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"position %d: %c\n"</span>, i, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">position 0: h</span></span><br><span class="line"><span class="string">position 1: ê</span></span><br><span class="line"><span class="string">position 2: l</span></span><br><span class="line"><span class="string">position 3: l</span></span><br><span class="line"><span class="string">position 4: o</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>方法二开销比方法一大，因为多了一层类型转换。</p>
<p><strong>🎡总结</strong></p>
<p>如果我们想要迭代一个字符串的符文，我们可以直接在字符串上使用 range 循环。但是我们必须记住，索引不对应于符文索引，而是对应于符文字节序列的起始索引。因为一个符文可以由多个字节组成，如果我们想要访问符文本身，我们应该使用 range 的值变量，而不是字符串中的索引。同时，如果我们想要获取字符串的第i个符文，我们在大多数情况下应该将字符串转换为一个 rune 切片。</p>
<h3 id="trim-函数"><a href="#trim-函数" class="headerlink" title="trim 函数"></a>trim 函数</h3><p>Go开发者在使用字符串包时常见的一个错误是混淆 TrimRight 和 TrimSuffix 函数。</p>
<p><strong>TrimRight</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.TrimRight(<span class="string">"123oxo"</span>, <span class="string">"xo"</span>))</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>TrimRight 方法倒序迭代每个字符。如果某个字符在提供的字符集中，则该函数会将其删除。如果不在，则函数停止迭代并返回剩余字符串</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308192143378.png" alt></p>
<p><strong>TrimSuffix</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.TrimSuffix(<span class="string">"123oxo"</span>, <span class="string">"xo"</span>))</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">123o</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>由于123oxo 以xo 结尾，所以此代码将打印出123o。此外，删除末尾后缀并不是一个重复的操作，所以 TrimSuffix(“123xoxo”, “xo”) 返回 123xo。</p>
<p>使用 TrimLeft 和 TrimPrefix 函数处理字符串左侧的空格，与上述原则是相同的。</p>
<p>Trim=TrimLeft + TrimRight。 因此，它会删除集合中包含的所有前置和尾部的字符。</p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>写一个 concat 函数，使用 += 操作符来连接切片的所有字符串元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">(values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s := <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">        s += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数的问题在于，字符串是不可变的。因此，每次迭代都不会更新 s，而是在内存中重新分配一个新的字符串，这显著影响了该函数的性能。</p>
<p>解决这个问题的方法是使用 strings 包和 Builder 结构体:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">(values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    sb := strings.Builder&#123;&#125;               ❶ 创建一个 strings.Builder</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">        _, _ = sb.WriteString(value)      ❷ 追加字符串</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.String()                    ❸ 返回拼接的字符串</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WriteString返回一个错误作为第二个输出，但我们有意忽略它。实际上，这个方法永远不会返回非nil错误。那么这个方法返回签名中的错误的目的是什么？ strings.Builder 实现了io.StringWriter接口，它包含一个方法：WriteString（s string）（n int，err error）。因此，为了遵守此接口，WriteString必须返回一个错误。</p>
<p>除了上述的 WriteString 外，strings.Builder 还支持其他的追加方法：</p>
<ol>
<li>Write —— 追加字节切片</li>
<li>WriteByte —— 追加单个字节</li>
<li>WriteRune —— 追加 rune</li>
</ol>
<p>注意事项：</p>
<p>strings.Builder 内部维护了一个字节切片，每次调用 WriteString 都会导致在这个切片上调用 append，所以，这个结构体不应该同时被使用，因为对 append 的调用会导致竞争条件。其次，如果字符串的未来长度是知道的，我们应该预先分配空间，strings.Builder 公开了一个方法Grow(n int)，以保证有 n 个字节的空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">(values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(values); i++ &#123;     ❶ 计算总长度。注意这里使用 <span class="built_in">len</span>。Grow 关心的是字节数量。</span><br><span class="line">        total += <span class="built_in">len</span>(values[i])</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sb := strings.Builder&#123;&#125;</span><br><span class="line">    sb.Grow(total)                         ❷ 预先分配空间</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">        _, _ = sb.WriteString(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>strings.Builder 是连接字符串列表的推荐解决方案。通常，应该在循环内使用此解决方案。但是如果我们只需要连接几个字符串（如名字和姓氏），使用 strings.Builder 不如使用 += 运算符或 fmt.Sprintf 方案可读性高。</p>
<p>一般原则上，我们可以记住，性能方面，当我们需要连接超过五个字符串时，strings.Builder解决方案更快。即使这个确切的数字取决于许多因素，例如连接的字符串的大小和机器，这也可以成为一个经验法则，帮助我们决定何时选择一个解决方案而不是另一个。此外，我们不应忘记，如果将来字符串的字节数量事先已知，应使用Grow方法来预分配内部字节片。</p>
<h3 id="无效的字符串转换"><a href="#无效的字符串转换" class="headerlink" title="无效的字符串转换"></a>无效的字符串转换</h3><p>大部分的 I/O 操作是使用 []byte 完成的。例如，io.Reader、io.Writer 和 io.ReadAll 与 []byte 一起工作，而不是字符串。因此，使用字符串意味着额外的转换，尽管 bytes 包中包含了与 strings 包相同的许多操作。</p>
<p>我们将实现一个 getBytes 函数，它接受一个 io.Reader 作为输入，从中读取数据，并调用一个 sanitize 函数。删除所有前导和尾部空格</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBytes</span><span class="params">(reader io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    b, err := io.ReadAll(reader)                    ❶ b 是一个 <span class="keyword">byte</span> 切片</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Call sanitize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，我们的 sanitize 函数该怎么实现呢？接收一个 字符串，然后去除空格？然后再将字符串返回？最终再在 getBytes 中转换为 []byte？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sanitize</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.TrimSpace(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么做是有代价的，需要将一个[]byte转换为字符串，去除空格后，再将字符串转换为[]byte。</p>
<p>事实上，在 strings 包中的所有公开函数在 bytes 包中都有相应的替代函数：TrimSpace、Split、Count、Contains、Index 等等。所以我们不必接受一个字符串，然后再返回一个字符串，然后再将结果转换为 []byte。</p>
<h3 id="子字符串内存泄露"><a href="#子字符串内存泄露" class="headerlink" title="子字符串内存泄露"></a>子字符串内存泄露</h3><p>要提取字符串的子集，我们可以使用以下语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"Hello, World!"</span></span><br><span class="line">s2 := s1[:<span class="number">5</span>] <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>但上述函数存在一个问题，这个示例从前五个字节创建一个字符串，而不是前五个符文。因此，在多字节编码符文的情况下，我们不应该使用这个语法。相反，我们应该先将输入字符串转换为 []rune 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"Hêllo, World!"</span></span><br><span class="line">s2 := <span class="keyword">string</span>([]<span class="keyword">rune</span>(s1)[:<span class="number">5</span>]) <span class="comment">// Hêllo</span></span><br></pre></td></tr></table></figure>
<p>另外一个例子，我们接受日志消息，假设日志最开头是长度为 36 的UUID，然后在是日志内容。现在我们需要保留最新的 n个UUID 的缓存。假设这些日志消息可能非常庞大（高达数千字节）。以下是一种实现方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s store)</span> <span class="title">handleLog</span><span class="params">(log <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(log) &lt; <span class="number">36</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"log is not correctly formatted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    uuid := log[:<span class="number">36</span>]  <span class="comment">// 取出日志前面 uuid</span></span><br><span class="line">    s.store(uuid)</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码存在内存泄漏吗？是的！log[:36] 将创建一个新字符串，同时也会引用同一后备数组。因此，我们在内存中存储的每个 uuid 字符串将包含不只是36个字节，而是初始日志字符串中的字节（数千字节）</p>
<p>那么怎么解决这个问题呢？</p>
<p>方法一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s store)</span> <span class="title">handleLog</span><span class="params">(log <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(log) &lt; <span class="number">36</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"log is not correctly formatted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    uuid := <span class="keyword">string</span>([]<span class="keyword">byte</span>(log[:<span class="number">36</span>]))     ❶ 先转换为 []<span class="keyword">byte</span> 类型，然后转换为字符串</span><br><span class="line">    s.store(uuid)</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过首先将子串转换为[]byte，然后再转换回字符串来，通过这样做，我们创建了一个新的字符串，并且可以防止发生内存泄漏。且 UUID 字符串由仅由36个字节组成的数组支持。</p>
<p>方法二：</p>
<p>Go 1.18 中，标准库还包括了一个使用 strings.Clone 方法返回字符串的新副本的解决方案：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uuid := strings.Clone(log[:<span class="number">36</span>])</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>在使用Go中的子字符串操作时，我们需要记住两件事情。首先，提供的区间是基于字节而不是基于符文数量。其次，子字符串操作可能会导致内存泄漏，因为生成的子字符串将与初始字符串共享相同的后备数组。防止发生这种情况的解决方案是手动执行字符串复制或使用Go 1.18中的strings.Clone。</p>
<h3 id="不知该用哪种类型的方法接收器"><a href="#不知该用哪种类型的方法接收器" class="headerlink" title="不知该用哪种类型的方法接收器"></a>不知该用哪种类型的方法接收器</h3><p>在 Go 语言中，我们可以将值或指针接收器附加到方法上。使用值接收器时，Go 会复制该值并将其传递给方法。对对象所作的任何更改都仅限于该方法范围内，原始对象仍保持不变。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customer <span class="keyword">struct</span> &#123;</span><br><span class="line">    balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c customer)</span> <span class="title">add</span><span class="params">(v <span class="keyword">float64</span>)</span></span> &#123;              ❶ 值接收器</span><br><span class="line">    c.balance += v</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := customer&#123;balance: <span class="number">100.</span>&#125;</span><br><span class="line">    c.add(<span class="number">50.</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"balance: %.2f\n"</span>, c.balance)    ❷ balance 依然是 <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，使用指针接收器时，Go将对象的地址传递给方法。从本质上讲，它仍然是一个副本，但我们只复制指针，而不是对象本身（在Go中不存在按引用传递）。对接收器的任何修改都是在原始对象上完成的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customer <span class="keyword">struct</span> &#123;</span><br><span class="line">    balance <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *customer)</span> <span class="title">add</span><span class="params">(operation <span class="keyword">float64</span>)</span></span> &#123;    ❶ 指针接收器</span><br><span class="line">    c.balance += operation</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := customer&#123;balance: <span class="number">100.0</span>&#125;</span><br><span class="line">    c.add(<span class="number">50.0</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"balance: %.2f\n"</span>, c.balance)   ❷ balance 为 <span class="number">150</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>receiver 必须是一个指针：</p>
<ol>
<li><p>如果该方法需要改变接收者。例如如果接收者是一个切片，并且方法需要追加元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice []<span class="keyword">int</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *slice)</span> <span class="title">add</span><span class="params">(element <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *s = <span class="built_in">append</span>(*s, element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果方法接收器包含无法复制的字段：例如，sync包的类型部分</p>
</li>
</ol>
<p>receiver 应该是指针：</p>
<ol>
<li>如果接收器是一个大对象，使用指针可以使调用更有效，因为这样可以防止进行广泛的复制。</li>
</ol>
<p>receiver 必须是一个值：</p>
<ol>
<li>如果我们必须强制接收器的不可变性</li>
<li>接收者是一个map、函数或管道</li>
<li>如果接收器是一个不必被改变的切片</li>
<li>如果接收者是一个小的数组或结构体，自然应该是没有可变字段的值类型，例如 time.Time</li>
<li>如果接收器是 int、float64 或 string 等基本类型</li>
</ol>
<h3 id="命名返回参数"><a href="#命名返回参数" class="headerlink" title="命名返回参数"></a>命名返回参数</h3><p>命名返回参数简单示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="params">(b <span class="keyword">int</span>)</span></span> &#123;    ❶ 命名结果参数 <span class="keyword">int</span> b</span><br><span class="line">    b = a</span><br><span class="line">    <span class="keyword">return</span>                 ❷ 返回变量 b 的当前值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么时候建议我们使用命名结果参数？</p>
<p>假设我们有一个从给定地址中获取坐标的接口，在这种情况下，为了让代码更易于阅读，我们应该使用命名结果参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> locator <span class="keyword">interface</span> &#123;</span><br><span class="line">    getCoordinates(address <span class="keyword">string</span>) (lat, lng <span class="keyword">float32</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么时候建议不使用命名的结果参数？</p>
<p>假设我我们需要将一个 Customer 类型存储到数据库中，这里的将错误参数命名为 err 是没有帮助的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreCustomer</span><span class="params">(customer Customer)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，何时使用命名结果参数取决于上下文。在大多数情况下，如果不清楚使用它们是否使我们的代码更可读，我们就不应该使用命名结果参数。</p>
<p>还有一种场景是命名结果参数并不会使我们的代码更易于阅读，而是初始化了的命名结果参数可能会非常方便</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r io.Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nr <span class="keyword">int</span></span><br><span class="line">        nr, err = r.Read(buf)</span><br><span class="line">        n += nr</span><br><span class="line">        buf = buf[nr:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，命名结果参数并不会真正增加可读性。但是，由于n和err都被初始化为它们的零值，使得实现变得更短了。但另一方面，对于读者来说，这个函数可能有点令人困惑。</p>
<h3 id="命名返回参数意外边界情况"><a href="#命名返回参数意外边界情况" class="headerlink" title="命名返回参数意外边界情况"></a>命名返回参数意外边界情况</h3><p>在一些情况下命名的结果参数很有用。但是由于这些结果参数被初始化为它们的零值，如果我们不够小心，使用它们有时会导致微妙的错误。</p>
<p>我们将之前的 getCoordinates 方法修改一下，传入一个 ctx，并在函数内部添加一个验证地址是否有效的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l loc)</span> <span class="title">getCoordinates</span><span class="params">(ctx context.Context, address <span class="keyword">string</span>)</span> <span class="params">(lat, lng <span class="keyword">float32</span>, err error)</span></span> &#123;</span><br><span class="line">    isValid := l.validateAddress(address)          ❶ 验证地址</span><br><span class="line">    <span class="keyword">if</span> !isValid &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, errors.New(<span class="string">"invalid address"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;                          ❷ 检查上下文是否已取消</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get and return coordinates</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里存在一个问题，if ctx.Err() != nil 的作用域中返回的错误是err。但我们没有为err变量分配任何值。但它是一个命名参数，所以它仍然被分配为错误类型的零值：nil。因此，这段代码总是会返回一个nil错误。但其实 ctx 发生了错误。</p>
<p>一种解决方法是将 ctx.Err() 分配给 err</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ctx.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err = ctx.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但不建议第二种方式，因为和上面 <code>if !isValid</code> 的返回风格不一致，在一个方法中，最好不要出现不一致的写法。</p>
<h3 id="nil-receiver"><a href="#nil-receiver" class="headerlink" title="nil receiver"></a>nil receiver</h3><p>我们将会创建一个名为 Customer 的结构体，并实现一个 Validate 方法来进行合理性检查。但我们不想只返回第一个错误信息，我们希望返回整个错误列表。为了实现这个目标，我们需要创建一个自定义错误类型以便传递多个错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MultiError <span class="keyword">struct</span> &#123;</span><br><span class="line">    errs []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MultiError)</span> <span class="title">Add</span><span class="params">(err error)</span></span> &#123;      ❶ 添加一个错误</span><br><span class="line">    m.errs = <span class="built_in">append</span>(m.errs, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MultiError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;      ❷ 实现了error接口</span><br><span class="line">    <span class="keyword">return</span> strings.Join(m.errs, <span class="string">";"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Customer)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m *MultiError                           ❶ 实例化一个空的 *MultiError</span><br><span class="line">    <span class="keyword">if</span> c.Age &lt; <span class="number">0</span> &#123;</span><br><span class="line">        m = &amp;MultiError&#123;&#125;</span><br><span class="line">        m.Add(errors.New(<span class="string">"age is negative"</span>))    ❷ 如果年龄为负数，则添加一个错误</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.Name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</span><br><span class="line">            m = &amp;MultiError&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m.Add(errors.New(<span class="string">"name is nil"</span>))        ❸ 如果名字为负数，则添加一个错误</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">customer := Customer&#123;Age: <span class="number">33</span>, Name: <span class="string">"John"</span>&#125;</span><br><span class="line"><span class="keyword">if</span> err := customer.Validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"customer is invalid: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">2021/05/08 13:47:28 customer is invalid: &lt;nil&gt;</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>这个结果可能会相当令人惊讶。Customer 是有效的，但 err！= nil 的条件为真，打印了 <code>&lt;nil&gt;</code></p>
<p>我们再来看另一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(foo *Foo)</span> <span class="title">Bar</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bar"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> foo *Foo</span><br><span class="line">    fmt.Println(foo.Bar())   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo 被初始化为指针的零值：nil。但是编译这段代码是可以通过的，而且如果我们运行它，它会打印 bar。所以空指针是一个有效的接收器。</p>
<p>回到上上个例子中，m会被初始化为指针的零值：nil。然后，如果所有的检查都有效，提供给 return 语句的参数不是直接的 nil 而是一个 nil指针。因为nil指针是一个有效的接收器，将结果转换为接口不会产生nil值。换句话说，调用Validate的调用者将始终获得一个非nil的错误。</p>
<p>如何解决这个例子呢？最简单的解决方法就是：如果 m 不是 nil，那就返回它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Customer)</span> <span class="title">Validate</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m *MultiError</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> c.Age &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.Name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m     ❶ 仅在至少有一个错误时返回 m</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>       ❷ 返回 <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用文件名作为入参"><a href="#使用文件名作为入参" class="headerlink" title="使用文件名作为入参"></a>使用文件名作为入参</h3><p>当我们创建一个需要读文件的函数时，传递一个文件名作为入参并不合适，比如单元测试的时候就很难写。</p>
<p>比如我们编写一个读取行数的函数，我们需要覆盖3种case:正常case/空文件/只有空行的文件。那我们就需要创建3个文件在单元测试中。</p>
<p>所以比较好的方式是使用<code>io.Reader</code>作为参数。</p>
<h3 id="defer-参数和不同-receiver"><a href="#defer-参数和不同-receiver" class="headerlink" title="defer 参数和不同 receiver"></a>defer 参数和不同 receiver</h3><p>我们的一个函数需要调用两个函数foo和bar。同时，它必须处理关于执行的状态：</p>
<ul>
<li>如果foo和bar都没有返回错误，则状态为StatusSuccess</li>
<li>如果foo返回错误，则为StatusErrorFoo</li>
<li>如果bar函数返回一个错误，则为StatusErrorBar </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StatusSuccess  = <span class="string">"success"</span></span><br><span class="line">    StatusErrorFoo = <span class="string">"error_foo"</span></span><br><span class="line">    StatusErrorBar = <span class="string">"error_bar"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> status <span class="keyword">string</span>  <span class="comment">// 定义状态</span></span><br><span class="line">    <span class="keyword">defer</span> notify(status)               ❶ 延迟调用 notify，并传入 status</span><br><span class="line">    <span class="keyword">defer</span> incrementCounter(status)     ❷ 延迟调用 incrementCounter，并传入 status</span><br><span class="line">    <span class="keyword">if</span> err := foo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        status = StatusErrorFoo        ❸ 将状态设置为 StatusErrorFoo</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> err := bar(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        status = StatusErrorBar        ❹ 将状态设置为 StatusErrorBar</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    status = StatusSuccess             ❺ 将状态设置为 StatusSuccess</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们声明一个状态变量。然后使用 defer 延迟调用 notify 和 incrementCounter 函数。然而，如果我们尝试使用这个函数，我们会发现无论执行路径如何，notify 和 incrementCounter 总是被调用并使用相同的状态：一个空字符串！</p>
<p>出现这个问题的原因是，参数会立即被评估，而不是在包围函数返回时。在我们的示例中，我们将 notify（status）和 incrementCounter（status）作为延迟函数调用。但是传入的参数 status 将是当前的值，而不是最终的值。</p>
<p>解决方法一，将一个字符串指针传递给延迟函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> status <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">defer</span> notify(&amp;status)                ❶ 传递一个字符串指针</span><br><span class="line">    <span class="keyword">defer</span> incrementCounter(&amp;status)      ❷ 传递一个字符串指针</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The rest of the function is unchanged</span></span><br><span class="line">    <span class="keyword">if</span> err := foo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        status = StatusErrorFoo</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> err := bar(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        status = StatusErrorBar</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    status = StatusSuccess</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 defer 会立即评估参数：在这里，是 status 的地址。status 本身在函数中逐渐更新，但是其地址保持不变。因此，如果 notify 或 incrementCounter使用string指针引用的值，它将按预期工作。</p>
<p>解决方法二，另一种解决方案是在 defer 语句中调用闭包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> status <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                   ❶ 将一个闭包函数作为延迟函数调用</span><br><span class="line">        notify(status)               ❷ 在闭包内调用 notify 并引用 status</span><br><span class="line">        incrementCounter(status)     ❸ </span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The rest of the function is unchanged</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，在执行闭包时 status 会被计算，而不是在我们调用 defer 时。这种解决方案也是可行的，并且不需要更改notify 和 incrementCounter的签名。</p>
<p>另一种比较容易混淆的就是结构体函数的<code>defer</code>调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    s := Struct&#123;id: &quot;foo&quot;&#125;</span><br><span class="line">    defer s.print()</span><br><span class="line">    s.id = &quot;bar&quot;</span><br><span class="line">&#125;</span><br><span class="line">type Struct struct &#123;</span><br><span class="line">    id string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s Struct) print() &#123; </span><br><span class="line">    fmt.Println(s.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值传递输出的结果是<code>foo</code>，指针传递输出的结果是<code>bar</code>.</p>
<h3 id="使用-panic"><a href="#使用-panic" class="headerlink" title="使用 panic"></a>使用 panic</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                       ❶ 在 <span class="keyword">defer</span> 函数中进行 <span class="built_in">recover</span> 调用</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"recover"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    f()                                  ❷ 调用 f，会导致程序崩溃</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"a"</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"foo"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅在 defer 函数内调用 recover() 以捕获 goroutine panic 是有用的。</p>
<p>什么情况下才适合使用 panic？</p>
<p>在 go 语言中，panic 用于表示真正的异常情况，例如，net/http 包中的 WriteHeader 方法，我们会注意到有一个调用 checkWriteHeaderCode 函数的语句，来检查状态码是否有效</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkWriteHeaderCode</span><span class="params">(code <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> code &lt; <span class="number">100</span> || code &gt; <span class="number">999</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"invalid WriteHeader code %v"</span>, code))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 go 语言中，我们应该谨慎使用 panic，只有在特殊情况下才会使用 panic 导致应用程序停止。在大多数其他情况下，应该使用一个函数来处理错误，将错误类型作为最后一个返回参数。</p>
<h3 id="包装-error"><a href="#包装-error" class="headerlink" title="包装 error"></a>包装 error</h3><p>自Go 1.13起，<code>%w</code> 可以使我们能够方便地包装错误，一般来说，错误包装的两个主要用途如下</p>
<ol>
<li>给错误添加额外的上下文信息</li>
<li>将错误标记为特定的错误</li>
</ol>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308212055921.png" alt></p>
<p>例如，我们收到来自特定用户的请求，访问数据库资源，但在查询过程中出现“权限被拒绝”错误。为了调试目的，虽然最终记录了错误，但希望添加额外的上下文信息。</p>
<p><code>%v</code> 和<code>%w</code> 的不同之处在于，使用 <code>%v</code>  时错误本身未被包装。而是将其转化为另一个错误以添加到上下文中，源错误不再可用。</p>
<h3 id="检查-error-类型"><a href="#检查-error-类型" class="headerlink" title="检查 error 类型"></a>检查 error 类型</h3><p>使用%w指令来包装错误时，我们同样需要改变检查特定错误类型的方式；否则，我们可能会不准确地处理错误。</p>
<p>让我们讨论一个具体的例子。我们将编写一个HTTP处理程序，以返回ID对应的交易金额。我们的处理程序将解析请求以获取ID，并从数据库（DB）中检索金额。我们的实现可能会有两种失败情况：</p>
<ul>
<li>ID 无效（字符串长度不等于五个字符）</li>
<li>查询数据库失败</li>
</ul>
<p>在前一种情况下，我们想要返回 StatusBadRequest（400），而在后一种情况下，我们想要返回ServiceUnavailable（503）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTransactionAmount</span><span class="params">(transactionID <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">float32</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Check transaction ID validity</span></span><br><span class="line"> </span><br><span class="line">    amount, err := getTransactionAmountFromDB(transactionID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ❶ 将错误包装起来，而不是直接返回 transientError</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"failed to get transaction %s: %w"</span>, transactionID, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> amount, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTransactionAmountFromDB</span><span class="params">(transactionID <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">float32</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, transientError&#123;err: err&#125;     ❷ 返回 transientError </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断错误类型时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    transactionID := r.URL.Query().Get(<span class="string">"transaction"</span>)      ❶ 获取 transaction id</span><br><span class="line"> </span><br><span class="line">    amount, err := getTransactionAmount(transactionID)     ❷ 调用 getTransactionAmount 方法</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;     ❸ 如果是 transientError 返回 <span class="number">503</span>，否则返回 <span class="number">400</span></span><br><span class="line">        <span class="keyword">case</span> transientError:</span><br><span class="line">            http.Error(w, err.Error(), http.StatusServiceUnavailable)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们运行代码，并且 getTransactionAmountFromDB 发生异常时，HTTP 状态码总是返回 400？这是怎么回事呢？</p>
<p>这事因为 getTransactionAmount 返回的不是 transientError，而是封装 transientError 的一个错误。因此 switch case 匹配时， 不能匹配到 transientError。</p>
<p>解决这个问题，我们应该使用 errors.As，errors.As 是一种检查包装错误是否是某种类型的方法。该函数递归地取消包装错误，并在错误链中匹配相对应的错误，当匹配到时则返回 true。上述代码改为如下所示即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Get transaction ID</span></span><br><span class="line"> </span><br><span class="line">    amount, err := getTransactionAmount(transactionID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> errors.As(err, &amp;transientError&#123;&#125;) &#123;      ❶ 判断 err 链中是否存在 transientError</span><br><span class="line">            http.Error(w, err.Error(),</span><br><span class="line">                http.StatusServiceUnavailable)      ❷ 如果是 transientError 返回 <span class="number">503</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            http.Error(w, err.Error(),</span><br><span class="line">                http.StatusBadRequest)              ❸ 否则返回 <span class="number">400</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Write response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>errors.As 函数要求第二个参数（目标错误）为指针。否则，该函数会编译但在运行时会抛出异常。</p>
<h3 id="检查-error-值"><a href="#检查-error-值" class="headerlink" title="检查 error 值"></a>检查 error 值</h3><p>项目中有很多已知的error，属于是预期之内的。比如：</p>
<ul>
<li><code>sql.ErrNoRows</code></li>
<li><code>io.EOF</code></li>
</ul>
<p>我们常常使用 <code>==</code>去检查error的值，但当error被<code>%w</code>包装之后，这样判断就会有问题。这个时候我们就需要使用<code>errors.Is</code>.他会递归unwrap,然后依次比对错误链上的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">err := query()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> errors.Is(err, sql.ErrNoRows) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="error-被处理多次"><a href="#error-被处理多次" class="headerlink" title="error 被处理多次"></a>error 被处理多次</h3><p>一个error处理多次在项目中很常见，比如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRoute</span><span class="params">(srcLat, srcLng, dstLat, dstLng <span class="keyword">float32</span>)</span> <span class="params">(Route, error)</span></span> &#123;</span><br><span class="line">    err := validateCoordinates(srcLat, srcLng)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"failed to validate source coordinates"</span>)   </span><br><span class="line">        <span class="keyword">return</span> Route&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    err = validateCoordinates(dstLat, dstLng)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"failed to validate target coordinates"</span>)  </span><br><span class="line">        <span class="keyword">return</span> Route&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> getRoute(srcLat, srcLng, dstLat, dstLng)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateCoordinates</span><span class="params">(lat, lng <span class="keyword">float32</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> lat &gt; <span class="number">90.0</span> || lat &lt; <span class="number">-90.0</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"invalid latitude: %f"</span>, lat)                </span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid latitude: %f"</span>, lat)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lng &gt; <span class="number">180.0</span> || lng &lt; <span class="number">-180.0</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"invalid longitude: %f"</span>, lng)              </span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid longitude: %f"</span>, lng)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当传入 200 时，会发现错误被处理的两遍。分别在 validateCoordinates 中和 GetRoute 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021/06/01 20:35:12 invalid latitude: 200.000000</span><br><span class="line">2021/06/01 20:35:12 failed to validate source coordinates</span><br></pre></td></tr></table></figure></p>
<p>良好的习惯是，错误应该只被处理一次。记录错误是处理错误的一种方式，返回错误也是如此。因此，我们应该记录或返回错误，而不是两者同时进行。</p>
<p>更新后的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRoute</span><span class="params">(srcLat, srcLng, dstLat, dstLng <span class="keyword">float32</span>)</span> <span class="params">(Route, error)</span></span> &#123;</span><br><span class="line">    err := validateCoordinates(srcLat, srcLng)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 %w 将错误进行包装</span></span><br><span class="line">        <span class="keyword">return</span> Route&#123;&#125;, fmt.Errorf(<span class="string">"failed to validate source coordinates: %w"</span>, err)  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    err = validateCoordinates(dstLat, dstLng)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Route&#123;&#125;, fmt.Errorf(<span class="string">"failed to validate target coordinates: %w"</span>, err) </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> getRoute(srcLat, srcLng, dstLat, dstLng)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>validateCoordinates 返回的每个错误现在都被包装起来，以提供错误的附加上下文。以携带上下文信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021/06/01 20:35:12 failed to validate source coordinates:</span><br><span class="line">    invalid latitude: 200.000000</span><br></pre></td></tr></table></figure>
<p>这样，不会丢失任何有价值的信息。此外，每个错误只处理一次，这简化了我们的代码，避免重复的错误信息。</p>
<h3 id="不需要处理的-error"><a href="#不需要处理的-error" class="headerlink" title="不需要处理的 error"></a>不需要处理的 error</h3><p>当我们不需要处理error的时候，经常会那么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func f() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    notify() </span><br><span class="line">&#125;</span><br><span class="line">func notify() error &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样其实会让读者产生误区，究竟是不需要处理error还是忘记处理了，所以我们可以改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = notify()</span><br></pre></td></tr></table></figure>
<h3 id="处理-defer-中的-error"><a href="#处理-defer-中的-error" class="headerlink" title="处理 defer 中的 error"></a>处理 defer 中的 error</h3><p>当我们在执行 sql 查询的时候，我们需要 close rows。但是 close rows 时可能出错，我们怎么解决这个问题呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> query = <span class="string">"..."</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getBalance</span><span class="params">(db *sql.DB, clientID <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">float32</span>, error)</span></span> &#123;</span><br><span class="line">    rows, err := db.Query(query, clientID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close()     ❶ 延迟调用 <span class="built_in">close</span></span><br><span class="line">    <span class="comment">// Use rows</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们有一种选择是记录 close 的 error。将 <code>rows.Close()</code> 放在 defer 中，如果 close 发生错误就记录一条日志信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := rows.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"failed to close rows: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>那我们如果需要将 close 的错误信息传播给 getBalance，这时该怎么实现呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    closeErr := rows.Close()     ❶ 执行 <span class="built_in">close</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;              ❷ 如果 getBalance 发生了其他错误</span><br><span class="line">        <span class="keyword">if</span> closeErr != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"failed to close rows: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 getBalance 没有发生其他错误，这时如果 closeErr 有值的话会给到 err 返回。如果 closeErr 无知则 err 为空</span></span><br><span class="line">    err = closeErr ❸ </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并行是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。</p>
<h3 id="认为并发一定更快"><a href="#认为并发一定更快" class="headerlink" title="认为并发一定更快"></a>认为并发一定更快</h3><p>作为Go开发人员，我们不能直接创建线程，但我们可以创建 goroutine，可以把它们看作应用程序级别的线程。然而，操作系统线程的上下文切换是由操作系统在CPU内核上进行的，而 goroutine 的上下文切换是由Go运行时在操作系统线程上进行。</p>
<ul>
<li><p>G - Goroutine（协程）</p>
</li>
<li><p>M - OS线程（代表机器）</p>
</li>
<li><p>P - CPU 核心（表示处理器）</p>
</li>
</ul>
<p>每个操作系统线程（M）由操作系统调度程序分配给 CPU 核心（P）。然后，每个 goroutine（G）在M上运行。 GOMAXPROCS 变量定义了同时执行用户级代码的 M 的数量限制。但是，如果线程在系统调用中被阻塞（例如I/O），则调度程序可以启动更多M。自Go 1.5以来，默认情况下GOMAXPROCS等于可用CPU核心数。</p>
<p>当一个 goroutine 被创建但还不能被执行时；例如，所有其他的 M 已经在执行 G。在这种情况下，Go 运行时会怎么处理呢？答案是排队。Go 运行时处理两种类型的队列：每个 P 一个本地队列和所有 P 共享的全局队列。</p>
<p>例如，下图显示了在 GOMAXPROCS 等于4的四核计算机上给定调度情况：</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308232117401.png" alt></p>
<p>P0、P1和P3正处理忙碌状态。P2 处于空闲状态。</p>
<p>每执行 61 次，Golang 调度器就会检查全局队列中是否有可用的 goroutine。如果没有，就会检查其本地队列。与此同时，如果全局和本地队列都为空，Golang 调度器可以从其他本地队列中挑选 goroutine。这种调度原则称为工作窃取，它允许未被充分利用的处理器积极寻找另一个处理器的 goroutine 并窃取一些。</p>
<p>在 Go 1.14 之前，调度器是协作式的，这意味着仅在特定的阻塞情况下（例如通道发送或接收、I/O、等待获取互斥锁）才能进行 goroutine 切换。从 Go 1.14 开始，Go 调度器现在是抢占式的：当 goroutine 运行特定的时间（10 毫秒）后，它将被标记为可抢占，并可以被切换上下文以替换为另一个 goroutine。这使得长时间运行的作业可以被强制共享 CPU 时间。</p>
<blockquote>
<p><strong>协作式调度</strong>：</p>
<p>在协作式调度中，goroutines主动让出CPU的执行时间。这意味着一个goroutine执行任务时，它可以选择何时释放CPU，允许其他goroutines执行。</p>
<p>这种方式通常用于编写并发程序，其中goroutines之间需要明确地协调和共享资源。</p>
<p>协作式调度器的优点是可以避免竞态条件和锁的使用，因为goroutines只在明确的时机让出CPU，而不会在任意时刻被强制停止。</p>
<p>编写协作式代码通常更容易理解和调试，但也需要开发人员注意避免长时间的占用CPU，以免阻塞其他goroutines。</p>
<p><strong>抢占式调度</strong>： </p>
<p>在抢占式调度中，调度器可以在任何时间中断正在运行的goroutine，并切换到另一个goroutine，无需等待正在运行的goroutine主动释放CPU。</p>
<p>这种方式通常用于需要更好的响应时间和更公平的资源共享的应用程序，例如实时系统或需要处理大量计算密集型任务的应用程序。</p>
<p>抢占式调度器可以确保没有单个goroutine会长时间占用CPU，从而提高系统的响应性。</p>
<p>但是，使用抢占式调度器可能需要更多的开销，因为需要更频繁地进行上下文切换，可能会引入一些竞态条件和锁。</p>
</blockquote>
<p>下面使用归并排序来举例：</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202308232138776.png" alt></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sequentialMergesort</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    middle := <span class="built_in">len</span>(s) / <span class="number">2</span></span><br><span class="line">    sequentialMergesort(s[:middle])     ❶ 递归前半部分排序</span><br><span class="line">    sequentialMergesort(s[middle:])     ❷ 递归后半部分排序</span><br><span class="line">    merge(s, middle)                    ❸ 合并</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(s []<span class="keyword">int</span>, middle <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们编写另一个版本的归并排序，并且使用协程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parallelMergesortV1</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    middle := <span class="built_in">len</span>(s) / <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;             ❶ 在协程中进行前半部分的排序</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        parallelMergesortV1(s[:middle])</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;             ❷ 在协程中进行后半部分的排序</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        parallelMergesortV1(s[middle:])</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    wg.Wait()</span><br><span class="line">    merge(s, middle)        ❸ 合并</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按道理来说，使用协程的版本会更快！但是结果却相反，第一种传统的方式更快。为什么会这样呢？</p>
<p>这是因为，如果我们有一个包含1024个元素的切片，那么父协程将会启动两个协程，每个协程负责处理512个元素的一半。每个协程都会启动两个新协程来处理256个元素，然后是128个，依此类推。这是因为协程需要的开销太大了，还不如传统的方式来运行。</p>
<p>另外一种解决方法是，定义一个阀值，当高于这个阀值时我们使用协程来并行处理。当低于阀值时我们使用传统的方式来处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="number">2048</span>                      ❶ 定义阀值</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parallelMergesortV2</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= max &#123;</span><br><span class="line">        sequentialMergesort(s)        ❷ 低于阀值时我们使用传统的方式来处理</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                          ❸ 高于阀值时我们使用协程来并行处理</span><br><span class="line">        middle := <span class="built_in">len</span>(s) / <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        wg.Add(<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            parallelMergesortV2(s[:middle])</span><br><span class="line">        &#125;()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            parallelMergesortV2(s[middle:])</span><br><span class="line">        &#125;()</span><br><span class="line"> </span><br><span class="line">        wg.Wait()</span><br><span class="line">        merge(s, middle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark_sequentialMergesort-4       2278993555 ns/op  # 第一种方式</span><br><span class="line">Benchmark_parallelMergesortV1-4      17525998709 ns/op  # 第二种方式</span><br><span class="line">Benchmark_parallelMergesortV2-4       1313010260 ns/op  # 第三种方式</span><br></pre></td></tr></table></figure>
<p>这种方法比第一种要快 40% 左右。所以也并不是所有场景下都是并发更快！</p>
<h3 id="何时使用通道或互斥锁来解决并发问题"><a href="#何时使用通道或互斥锁来解决并发问题" class="headerlink" title="何时使用通道或互斥锁来解决并发问题"></a>何时使用通道或互斥锁来解决并发问题</h3><p>互斥锁和通道具有不同的语义。每当我们想共享状态或访问共享资源时，互斥锁确保对该资源的独占访问。相反，通道是一种进行信号传递的机制。协调或所有权转移应通过通道实现</p>
<p>即一般来说，并行 Goroutine 需要同步，因此需要使用互斥锁。相反的，同时执行的 Goroutine 通常需要协调管理，因此需要使用通道。</p>
<h3 id="race-问题"><a href="#race-问题" class="headerlink" title="race 问题"></a>race 问题</h3><p><strong>数据竞争</strong></p>
<p>我们来看一个数据竞争的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i++       ❶ 增加 i</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>当我们使用 -race 来运行时，会检测出 data race</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00c00008e000 by goroutine 7:</span><br><span class="line">  main.main.func2()</span><br><span class="line"> </span><br><span class="line">Previous write at 0x00c00008e000 by goroutine 6:</span><br><span class="line">  main.main.func1()</span><br><span class="line">==================</span><br></pre></td></tr></table></figure>
<p>我们该如何避免数据竞争呢？第一种选择是让增量操作变为原子操作，即在单个操作中完成：可以使用sync/atomic包来进行原子操作。下面是一个如何原子地递增int64的示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int64</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(&amp;i, <span class="number">1</span>)    ❶ 原子性的增加 i</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    atomic.AddInt64(&amp;i, <span class="number">1</span>)    ❷ 原子性的增加 i</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>sync/atomic 包提供了 int32、int64、uint32和uint64的原语，但不支持int。</p>
<p>另一种选项是使用像互斥锁（mutex）这样的特殊数据结构来同步两个 goroutine</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">mutex := sync.Mutex&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutex.Lock()        ❶ 上锁</span><br><span class="line">    i++                 ❷ i++</span><br><span class="line">    mutex.Unlock()      ❸ 释放锁</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    i++</span><br><span class="line">    mutex.Unlock()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>另一个可能的选项是避免共享相同的内存位置，而是跨 Goroutine 进行通信</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="number">1</span>     ❶ 通知 goroutine 将计数器加 <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line">i += &lt;-ch       ❷ 从通道接收增加的值</span><br><span class="line">i += &lt;-ch</span><br></pre></td></tr></table></figure>
<p>每个 goroutine 通过通道发送通知，告知我们应将 i 增加 1。父协程收集通知并增加 i。由于它是唯一一个写入 i 的协程，因此该解决方案也避免了数据竞态。</p>
<p><strong>内存模型</strong></p>
<p>创建 Goroutine 是在 Goroutine 执行开始之前发生的。因此，先读取一个变量，然后启动一个新的 Goroutine 来写入这个变量，不会导致数据竞争</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>相反，一个 goroutine 的退出不能保证在任何事件之前发生。因此，下面的示例存在数据竞争</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i++</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure>
<p>一个通道上的发送操作发生在相应的接收操作完成之前。在示例中，父 goroutine 在发送前递增了一个变量，而另一个 goroutine 在通道读取后读取了该变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;()</span><br><span class="line">i++</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>关闭一个通道是在收到它被关闭之前</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-ch</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;()</span><br><span class="line">i++</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>无缓冲通道的接收操作发生在发送操作之前</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    &lt;-ch</span><br><span class="line">&#125;()</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure>
<p>因为来自无缓冲通道的接收操作发生在发送操作之前，因此对 i 的写操作将始终在读操作之前发生。</p>
<p><a href="https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/" target="_blank" rel="noopener">https://colobu.com/2021/07/13/Updating-the-Go-Memory-Model/</a></p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p><strong>context.WithTimeout</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> publishHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    pub publisher</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h publishHandler)</span> <span class="title">publishPosition</span><span class="params">(position flight.Position)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">4</span>*time.Second) ❶ <span class="number">4</span>s后超时的上下文</span><br><span class="line">    <span class="keyword">defer</span> cancel()                                                          ❷ <span class="keyword">defer</span> cancel</span><br><span class="line">    <span class="keyword">return</span> h.pub.Publish(ctx, position)                                     ❸ 传递超时上下文</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码使用 context.WithTimeout 函数来创建一个上下文。这个函数接受一个超时时间和一个上下文为参数。在这里，由于 publishPosition 没有收到一个现有的上下文，我们通过 context.Background 创建了一个新的上下文。同时，context.WithTimeout 返回两个变量：所创建的上下文和一个被调用后会取消上下文的取消函数 cancel func()。将创建的上下文传递给 Publish 方法应该能在最多4秒内使其返回。</p>
<p><strong>context.WithCancel</strong></p>
<p>Go语言上下文的另一个用例是传递 cancel 信号，我们想创建一个应用程序，在另一个goroutine中调用CreateFileWatcher(ctx context.Context, filename string)。这个函数创建了一个特定的文件监听器，它一直从文件中读取并捕获更新。当提供的上下文过期或被取消时，此函数会处理它以关闭文件描述符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())    ❶ 创建可取消的上下文</span><br><span class="line">    <span class="keyword">defer</span> cancel()                                             ❷ 延迟调用cancel</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        CreateFileWatcher(ctx, <span class="string">"foo.txt"</span>)                      ❸ 传递上下文</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 main 函数返回时，它调用 cancel 函数来取消传递给 CreateFileWatcher 函数的上下文，使文件描述符可以正常关闭。</p>
<p><strong>context.WithValue</strong></p>
<p>Go语言上下文的另一个用例是携带键值列表，可以通过以下方式创建传达值的上下文</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.WithValue(parentCtx, <span class="string">"key"</span>, <span class="string">"value"</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以使用Value方法来访问该值:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.WithValue(context.Background(), <span class="string">"key"</span>, <span class="string">"value"</span>)</span><br><span class="line">fmt.Println(ctx.Value(<span class="string">"key"</span>))</span><br></pre></td></tr></table></figure>
<p>提供的键和值可以是任何类型。实际上，对于值，我们可以传递任何类型。但为什么键也要是一个空接口而不是一个字符串？这事因为这么做，可能会发生碰撞：来自不同包的两个函数可能使用相同的字符串值作为键。因此，后者会覆盖前者的值。因此，在处理上下文键时的最佳实践是创建一个未导出的自定义类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> provider</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> key <span class="keyword">string</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> myCustomKey key = <span class="string">"key"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    ctx = context.WithValue(ctx, myCustomKey, <span class="string">"foo"</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Done 和 Err</strong></p>
<p>context.Context 类型导出一个Done方法，该方法返回一个只读通知通道：&lt;-chan struct{}。当与上下文相关的工作应被取消时（截止时期关闭或者调用 cancel取消），此通道将关闭。</p>
<p>此外，context.Context 导出了一个 Err 方法，如果 Done channel 尚未关闭，则返回 nil。否则，它将返回一个非 nil 的错误，如果通道被取消，则返回context.Canceled错误。如果上下文的截止日期已过，则会出现 context.DeadlineExceeded 错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(ctx context.Context, ch <span class="keyword">chan</span> Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg := &lt;-ch:               ❶ 不断收到来自 ch 的消息</span><br><span class="line">            <span class="comment">// Do something with msg</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():              ❷ 如果上下文被取消或者完成，则返回与其相关的错误</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>🎡总结</strong></p>
<p>正如我们所提到的， context 允许我们携带截止时间、取消信号和/或键值列表。一般而言，用户等待的函数应该接受 context 作为参数，这样可以上游调用者可以决定在何时取消调用此函数。</p>
<p>如果对于应该使用哪种上下文感到疑惑，我们应该使用context.TODO()代替传递空的context.Background上下文。</p>
<h3 id="错误的传递-context"><a href="#错误的传递-context" class="headerlink" title="错误的传递 context"></a>错误的传递 context</h3><p>有一个函数，接收 HTTP 请求，并在 doSomeTask 中构建 response 响应。然后在响应写入 kafka 中，并且将响应返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    response, err := doSomeTask(r.Context(), r)         ❶ 构建 HTTP Response</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                                         ❷ 创建一个协程将 response 传递到 kafka</span><br><span class="line">        err := publish(r.Context(), response)</span><br><span class="line">        <span class="comment">// Do something with err</span></span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    writeResponse(response)                             ❸ HTTP 响应</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附加到 HTTP 请求的上下文可能会在以下场景被取消：</p>
<ol>
<li>当客户端的连接被关闭时</li>
<li>在 HTTP/2 请求的情况下，当请求被取消的时候</li>
<li>当响应已经被写回客户端的时候</li>
</ol>
<p>当是第三种情况的时候，如果响应是在 kafak publish 之后写的，这种情况下没有问题。但是如果响应是在 kafka 发布之前或者 publish 期间写的，那么 kafka 发布消息就会失败。</p>
<p>那么如何解决这种问题呢？</p>
<p>第一种解决方法是不传播父级的 context 上下文，反而我们会使用空上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := publish(context.Background(), response)    ❶ 使用空的上下文而不是 HTTP 请求上下文</span><br></pre></td></tr></table></figure>
<p>第二种解决方法是我们实现自己的上下文，但是不携带 cancel 的信号，并且能解决第一种解决方案中的使用空的上下文不能在其中传递值的问题。</p>
<p>context.Context 是一个包含四个方法的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>) <span class="comment">// 上下文的截止时间</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 取消信号或者信号到期时，返回一个关闭的通道</span></span><br><span class="line">    Err() error <span class="comment">// 取消信号或者信号到期时，Err 返回一个错误</span></span><br><span class="line">    Value(key any) any  <span class="comment">// 传递值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们自己实现的 context 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> detach <span class="keyword">struct</span> &#123;                  ❶ 自定义结构体，封装 context</span><br><span class="line">    ctx context.Context</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d detach)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(time.Time, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> time.Time&#123;&#125;, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d detach)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d detach)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d detach)</span> <span class="title">Value</span><span class="params">(key any)</span> <span class="title">any</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d.ctx.Value(key)           ❷ 将值塞入 ctx 中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己实现的 context 除了调用父级上下文检索值的 Value 方法之外，其他方法都返回默认值，因此上下文永远不会被视为已过期或已取消。</p>
<p>使用时，我们将自己实现的 context 传递就去即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := publish(detach&#123;ctx: r.Context()&#125;, response)    ❶ 传入自己实现的 context</span><br></pre></td></tr></table></figure>
<p>现在传递给发布函数的上下文将永不过期或被取消，并且它将携带父级上下文的值。</p>
<h3 id="何时停止-Goroutine"><a href="#何时停止-Goroutine" class="headerlink" title="何时停止 Goroutine"></a>何时停止 Goroutine</h3><p>Goroutine 的最小堆栈大小为 2 KB，可以随需要增长和缩小（64 位系统上的最大堆栈大小为 1 GB，32 位系统上为 250 MB）</p>
<p>让我们来看一个例子，其中 goroutine 的停止时间点不明确，创建的 Goroutine 会在 ch 被关闭时退出。但我们确切知道这个 channel 何时关闭吗？这可能不明显，因为 ch 是由 foo 函数创建的。如果这个 channel 从未被关闭，就会造成资源泄漏。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch := foo()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>我们再来看另外一个例子，这段代码的问题在于当主 goroutine 退出时（可能是由于操作系统信号或者因为它有有限的工作负载），应用也会停止。因此，由监听器创建的资源并没有被优雅地关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newWatcher()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Run the application</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> watcher <span class="keyword">struct</span> &#123; <span class="comment">/* Some resources */</span> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWatcher</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w := watcher&#123;&#125;</span><br><span class="line">    <span class="keyword">go</span> w.watch()      ❶ 创建 gorouting 来监听外部配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们怎么解决这个问题呢？一个选项是将一个在 main 返回时将被取消的上下文传递给 newWatcher。例如下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"> </span><br><span class="line">    newWatcher(ctx)      ❶ 将上下文传递给 newWatcher</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Run the application</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWatcher</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    w := watcher&#123;&#125;</span><br><span class="line">    <span class="keyword">go</span> w.watch(ctx)      ❷ 传播上下文</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样有个问题，问题在于我们使用信号来传达 goroutine 需要停止运行的消息。我们没有在资源被关闭之前阻塞父级 goroutine。我们需要确保阻塞父级 goroutine 直到资源被关闭，不然就可能发生父级 goroutine 结束了，w.watch 还没被关闭的情况。</p>
<p>所以正确的做法是，我们应该调用 w 的 close 方法来关闭资源</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    w := newWatcher()</span><br><span class="line">    <span class="keyword">defer</span> w.<span class="built_in">close</span>()     ❶ 延迟调用 w 的 <span class="built_in">close</span> 方法</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Run the application</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWatcher</span><span class="params">()</span> <span class="title">watcher</span></span> &#123;</span><br><span class="line">    w := watcher&#123;&#125;</span><br><span class="line">    <span class="keyword">go</span> w.watch()</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w watcher)</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Close the resources</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以通过使用 defer 来调用这个 close 方法，以确保在应用程序退出之前关闭资源，而不是通过向 watcher 发送信号来关闭其资源。</p>
<h3 id="range-中执行协程"><a href="#range-中执行协程" class="headerlink" title="range 中执行协程"></a>range 中执行协程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> s &#123;      ❶ 迭代每个元素</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Print(i)       ❷ 访问变量 i</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的输出不是确定性的。例如，有时它会打印出 233，而其他时候则会打印出 333。这是什么原因呢？</p>
<p>这是因为在这个例子中，我们通过闭包创建新的 goroutine。它引用了外部变量：这里是变量 i。我们必须知道当闭包 goroutine 执行时，它并不捕获创建 goroutine 时的值。相反，所有 goroutine 都引用相同的变量。</p>
<p>那该怎么解决呢？</p>
<p>第一个选择，如果我们仍要使用闭包，涉及创建一个新变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> s &#123;</span><br><span class="line">    val := i            ❶ 针对每次迭代，创建一个本地变量</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Print(val)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次迭代中，我们会创建一个新的局部变量 val。这个变量捕获了当前迭代中的 i 值，在协程创建前。因此，当每个闭包协程执行打印语句时，都会使用预期的值。这段代码会打印出 123。</p>
<p>第二个选项不再依赖闭包，而是使用实际的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> s &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;     ❶ 接受 val 参数</span><br><span class="line">        fmt.Print(val)</span><br><span class="line">    &#125;(i)                   ❷ 将 i 传入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法不是闭包，该函数不引用来自其主体外部的变量 val；val 现在是函数的一部分输入。通过这样做，我们在每次迭代中都固定了i。</p>
<h3 id="switch-channel-的随机选择"><a href="#switch-channel-的随机选择" class="headerlink" title="switch+channel  的随机选择"></a>switch+channel  的随机选择</h3><p>下面例子中，我们希望先处理 messageCh 通道中的内容，然后在处理 disconnectCh 中的内容，代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;                         ❶ 使用 <span class="keyword">select</span> 语句从多个channel中接收数据</span><br><span class="line">    <span class="keyword">case</span> v := &lt;-messageCh:           ❷ 处理 messageCh </span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    <span class="keyword">case</span> &lt;-disconnectCh:             ❸ 处理 disconnectCh</span><br><span class="line">        fmt.Println(<span class="string">"disconnection, return"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    messageCh &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">disconnectCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是得到的结果如下，并没有打印10条消息，然后在处理 disconnectCh。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">disconnection, return</span><br></pre></td></tr></table></figure>
<p>出现这样的原因是，当有一个或者多个通道可以处理时，那么将通过伪随机选择选一个通道进行处理。这么做的好处是防止饥饿。</p>
<p>那么假如我们要实现上述的需求【⚠️上述的需求中有多个 goroutine 生产者】，那么该怎么实现呢？下面是一种解决方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v := &lt;-messageCh:</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    <span class="keyword">case</span> &lt;-disconnectCh:</span><br><span class="line">        <span class="keyword">for</span> &#123;                          ❶ 内部 <span class="keyword">for</span> <span class="keyword">select</span></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;-messageCh:     ❷ 读取剩余消息</span><br><span class="line">                fmt.Println(v)</span><br><span class="line">            <span class="keyword">default</span>:                   ❸ <span class="keyword">default</span> 执行 <span class="keyword">return</span> 返回</span><br><span class="line">                fmt.Println(<span class="string">"disconnection, return"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该解决方案使用一个带有两个 case 的 for/select：一个是 messageCh，另一个是默认情况。只有在没有其他 case 匹配时，才会在 select 语句中使用 default。在这种情况下，这意味着我们只有在接收到 messageCh 中所有剩余的消息后才会返回。</p>
<p>⚠️这么做能保证顺序的前提是 messageCh 的消息是一次性发送完成的，而不是分开发送，这样在执行第二个从 messageCh 中读取消息时，肯定会有数据，而不是先执行 default。</p>
<p>另一种情况下，如果是单个 goroutine 作为生产者的情况下，我们则可以使用不带缓冲区的 channel 来达到目的。</p>
<h3 id="使用-channel-作为通知信道"><a href="#使用-channel-作为通知信道" class="headerlink" title="使用 channel 作为通知信道"></a>使用 channel 作为通知信道</h3><p>在Go语言中，一个空结构体是一个没有任何字段的结构体。无论架构如何，它占用零字节的存储空间，我们可以使用unsafe.Sizeof验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s struct&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(s))</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么不使用一个空接口（var i interface{}）？因为一个空接口是有大小的；它在32位架构上占用8字节，在64位架构上占用16字节。</p>
</blockquote>
<p>一个没有数据的信道应该用 chan struct{} 类型来表示。这样一来，就可以为接收者明确表示，他们不应该从消息内容中期望任何含义——只是表示他们已经接收到了一条消息。在Go中，这些信道被称为通知信道。</p>
<h3 id="nil-channel"><a href="#nil-channel" class="headerlink" title="nil channel"></a>nil channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span>     ❶ <span class="literal">nil</span> chanel</span><br><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure>
<p>ch 是 chan int 类型。channel 的零值为 nil，因此 ch 为 nil。协程不会触发 panic；但是，它将一直阻塞。</p>
<p>如果我们向一个 nil 的通道发送消息，原理是一样的。这个 goroutine 会永远阻塞：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">ch &lt;- <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>nil channel 有时候很有用，我们可以使用 nil 通道来实现一种优雅的状态机，从而将一个 case 从 select 语句中去除。例如一下示例：从两个通道接收。如果其中一个关闭，我们将其赋值为nil，因此我们只从一个通道接收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(ch1, ch2 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ch1 != <span class="literal">nil</span> || ch2 != <span class="literal">nil</span> &#123;    ❶ 保证至少一个通道不为 <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v, open := &lt;-ch1:</span><br><span class="line">                <span class="keyword">if</span> !open &#123;</span><br><span class="line">                    ch1 = <span class="literal">nil</span>             ❷ 一旦 ch1 关闭，就将 ch1 设置为 <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                ch &lt;- v</span><br><span class="line">            <span class="keyword">case</span> v, open := &lt;-ch2:</span><br><span class="line">                <span class="keyword">if</span> !open &#123;</span><br><span class="line">                    ch2 = <span class="literal">nil</span>             ❸ 一旦 ch2 关闭，就将 ch2 设置为 <span class="literal">nil</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                ch &lt;- v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(ch)</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 Go 的 <code>select</code> 语句中，如果多个 <code>case</code> 中的通道都是可读的（或者都是可写的），选择哪个 <code>case</code> 是非确定性的。当其中一个通道为 <code>nil</code> 时，它被视为不可读（或不可写），而 <code>select</code> 语句会自动选择其他可读（或可写）的通道来执行。</p>
</blockquote>
<h3 id="有-无缓冲的-channel"><a href="#有-无缓冲的-channel" class="headerlink" title="有/无缓冲的 channel"></a>有/无缓冲的 channel</h3><p>一个非缓存信道是没有容量的信道。它可以通过省略大小或提供零大小来创建</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>使用无缓冲信道（有时称为同步信道），发送者将一直阻塞，直到接收者从信道接收到数据</p>
<p>相反地，带缓冲的通道具有容量，必须创建一个大小大于或等于1的通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>有了缓冲通道，发送者可以在通道未满的情况下发送消息。一旦通道满了，它将阻塞直到接收者协程收到了一条消息。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">ch3 &lt;<span class="number">-1</span>               <span class="comment">// 未阻塞</span></span><br><span class="line">ch3 &lt;<span class="number">-2</span>               <span class="comment">// 阻塞</span></span><br></pre></td></tr></table></figure>
<h3 id="append的时候-data-races"><a href="#append的时候-data-races" class="headerlink" title="append的时候 data races"></a>append的时候 data races</h3><p>对切片使用 append 添加元素一定会产生数据竞争吗？并不一定！需要分场景。</p>
<p>在下面的例子中, 我们将初始化一个slice并创建两个goroutines，这些goroutines将使用append创建一个具有额外元素的新 slice:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                ❶ 在协程<span class="number">1</span>中 <span class="built_in">append</span> 一个元素</span><br><span class="line">    s1 := <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;                ❷ 在协程<span class="number">2</span>中 <span class="built_in">append</span> 另一个元素</span><br><span class="line">    s2 := <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>这个例子会造成数据竞争吗？答案是不会。因为 slice 有两个属性，长度和容量。长度是 Slice 中可用元素的数量，而容量是支持数组中元素的总数。当我们使用 append 时，行为取决于 Slice 是否已满（长度 == 容量）。如果是，Go 运行时会创建一个新的数组以添加新元素；否则，运行时将其添加到现有的支持数组中。</p>
<p>在上述例子中，我们创建了一个长度和容量都为1的切片。因此，由于切片已经满了，所以在每个 goroutine 中使用 append 都将返回一个底层为新数组的切片。它不会改变现有的数组，所以不会产生数据竞争。</p>
<p>假如我们更换一下初始化方法，不在创建长度为1的切片，而是创建长度为0的但容量为1的切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1</span>)  <span class="comment">// 长度为0，但容量为1的切片</span></span><br></pre></td></tr></table></figure>
<p>这样是否为造成数据竞争呢？答案是会。我们使用 make([]int, 0, 1) 创建一个切片，因此数组并没有被填满。两个 goroutines 都试图更新支撑数组的同一个索引（索引 1），这就会导致数据竞争。这时，我们应该怎么处理呢？我们可以创建 s 的副本来解决这个问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sCopy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(sCopy, s)                          ❶ 复制切片，并在复制后使用 <span class="built_in">append</span> </span><br><span class="line"> </span><br><span class="line">    s1 := <span class="built_in">append</span>(sCopy, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sCopy := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(sCopy, s)                          ❷ 复制切片，并在复制后使用 <span class="built_in">append</span> </span><br><span class="line"> </span><br><span class="line">    s2 := <span class="built_in">append</span>(sCopy, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>两个 goroutine 都会复制切片，然后它们在各自的切片副本上使用 append，而不是原始切片，这样就可以防止数据竞争。</p>
<p><strong>🎡总结</strong></p>
<ol>
<li>访问相同的切片个索引，并且至少有一个 goroutine 在更新值时，这将会引起数据竞争。</li>
<li>访问不同的切片索引不会导致数据竞争，不同的索引意味着不同的内存位置。</li>
<li>访问同一个 map（无论是相同的键还是不同的键）且至少有一个 goroutine 更新它，就会产生数据竞争。这是因为 map 的底层实现是一个哈希表（hash table），它包含了桶（buckets）和哈希函数。当你向 map 中插入或检索数据时，Go 会使用键的哈希值来确定数据在哪个桶中。即，在并发情况下，多个goroutine同时对map进行操作时，可能会造成多个goroutine同时读写同一个哈希桶，导致数据竞争的问题。例如，多个goroutine同时向同一个桶中插入数据，可能会导致插入的数据被覆盖或者丢失，从而破坏了map的正确性。</li>
<li>通常情况下，我们不应根据切片是否已满来采用不同的实现。我们应该考虑到，在并发应用程序中对共享切片使用 append 可能会导致数据竞争。因此，应避免这种情况。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://yflee.in/go100mistakes.html" target="_blank" rel="noopener">https://yflee.in/go100mistakes.html</a></li>
<li><a href="https://www.luozhiyun.com/archives/797" target="_blank" rel="noopener">https://www.luozhiyun.com/archives/797</a></li>
<li><a href="https://qcrao.com/post/100-go-mistakes-reading-notes/" target="_blank" rel="noopener">https://qcrao.com/post/100-go-mistakes-reading-notes/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/611451902" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/611451902</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/28/Python 日志库对比/" rel="prev" title="Python 日志库对比">
      <i class="fa fa-chevron-left"></i> Python 日志库对比
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/10/24/Go Cookbook/" rel="next" title="Go CookBook">
      Go CookBook <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#摘要"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量屏蔽"><span class="nav-number">2.</span> <span class="nav-text">变量屏蔽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不必要的嵌套"><span class="nav-number">3.</span> <span class="nav-text">不必要的嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滥用-init"><span class="nav-number">4.</span> <span class="nav-text">滥用 init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过度使用-getter-和-setter"><span class="nav-number">5.</span> <span class="nav-text">过度使用 getter 和 setter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口污染"><span class="nav-number">6.</span> <span class="nav-text">接口污染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口概念"><span class="nav-number">6.1.</span> <span class="nav-text">接口概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么时候使用接口"><span class="nav-number">6.2.</span> <span class="nav-text">什么时候使用接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口污染-1"><span class="nav-number">6.3.</span> <span class="nav-text">接口污染</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口应该在哪里"><span class="nav-number">7.</span> <span class="nav-text">接口应该在哪里</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回接口"><span class="nav-number">8.</span> <span class="nav-text">返回接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#any"><span class="nav-number">9.</span> <span class="nav-text">any</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候用泛型"><span class="nav-number">10.</span> <span class="nav-text">什么时候用泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是泛型"><span class="nav-number">10.1.</span> <span class="nav-text">什么是泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">10.2.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体内嵌"><span class="nav-number">11.</span> <span class="nav-text">结构体内嵌</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的选项模式"><span class="nav-number">12.</span> <span class="nav-text">函数的选项模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#项目结构"><span class="nav-number">13.</span> <span class="nav-text">项目结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#utility-包"><span class="nav-number">14.</span> <span class="nav-text">utility 包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量名和包名冲突"><span class="nav-number">15.</span> <span class="nav-text">变量名和包名冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码文档"><span class="nav-number">16.</span> <span class="nav-text">代码文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码检查工具"><span class="nav-number">17.</span> <span class="nav-text">代码检查工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八进制字面量的误解"><span class="nav-number">18.</span> <span class="nav-text">八进制字面量的误解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#整数溢出"><span class="nav-number">19.</span> <span class="nav-text">整数溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点"><span class="nav-number">20.</span> <span class="nav-text">浮点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切片长度和容量"><span class="nav-number">21.</span> <span class="nav-text">切片长度和容量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切片初始化"><span class="nav-number">22.</span> <span class="nav-text">切片初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil-切片和-empty-切片"><span class="nav-number">23.</span> <span class="nav-text">nil 切片和 empty 切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查切片是否为空"><span class="nav-number">24.</span> <span class="nav-text">检查切片是否为空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy-切片"><span class="nav-number">25.</span> <span class="nav-text">copy 切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slice-共享底层数组带来的问题"><span class="nav-number">26.</span> <span class="nav-text">slice 共享底层数组带来的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切片内存泄漏"><span class="nav-number">27.</span> <span class="nav-text">切片内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#低效的-map-初始化"><span class="nav-number">28.</span> <span class="nav-text">低效的 map 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map-原理"><span class="nav-number">28.1.</span> <span class="nav-text">map 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">28.2.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-内存泄漏"><span class="nav-number">29.</span> <span class="nav-text">map 内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误的值比较"><span class="nav-number">30.</span> <span class="nav-text">错误的值比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range-循环是值拷贝"><span class="nav-number">31.</span> <span class="nav-text">range 循环是值拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range-对象何时被计算"><span class="nav-number">32.</span> <span class="nav-text">range 对象何时被计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range-中使用指针"><span class="nav-number">33.</span> <span class="nav-text">range 中使用指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-迭代中的常见问题"><span class="nav-number">34.</span> <span class="nav-text">map 迭代中的常见问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-的使用"><span class="nav-number">35.</span> <span class="nav-text">break 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在循环中使用-defer"><span class="nav-number">36.</span> <span class="nav-text">在循环中使用 defer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不理解-rune"><span class="nav-number">37.</span> <span class="nav-text">不理解 rune</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串迭代和长度"><span class="nav-number">38.</span> <span class="nav-text">字符串迭代和长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trim-函数"><span class="nav-number">39.</span> <span class="nav-text">trim 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串拼接"><span class="nav-number">40.</span> <span class="nav-text">字符串拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无效的字符串转换"><span class="nav-number">41.</span> <span class="nav-text">无效的字符串转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子字符串内存泄露"><span class="nav-number">42.</span> <span class="nav-text">子字符串内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不知该用哪种类型的方法接收器"><span class="nav-number">43.</span> <span class="nav-text">不知该用哪种类型的方法接收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名返回参数"><span class="nav-number">44.</span> <span class="nav-text">命名返回参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名返回参数意外边界情况"><span class="nav-number">45.</span> <span class="nav-text">命名返回参数意外边界情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil-receiver"><span class="nav-number">46.</span> <span class="nav-text">nil receiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用文件名作为入参"><span class="nav-number">47.</span> <span class="nav-text">使用文件名作为入参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-参数和不同-receiver"><span class="nav-number">48.</span> <span class="nav-text">defer 参数和不同 receiver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-panic"><span class="nav-number">49.</span> <span class="nav-text">使用 panic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装-error"><span class="nav-number">50.</span> <span class="nav-text">包装 error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查-error-类型"><span class="nav-number">51.</span> <span class="nav-text">检查 error 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查-error-值"><span class="nav-number">52.</span> <span class="nav-text">检查 error 值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#error-被处理多次"><span class="nav-number">53.</span> <span class="nav-text">error 被处理多次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不需要处理的-error"><span class="nav-number">54.</span> <span class="nav-text">不需要处理的 error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理-defer-中的-error"><span class="nav-number">55.</span> <span class="nav-text">处理 defer 中的 error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发和并行"><span class="nav-number">56.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#认为并发一定更快"><span class="nav-number">57.</span> <span class="nav-text">认为并发一定更快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时使用通道或互斥锁来解决并发问题"><span class="nav-number">58.</span> <span class="nav-text">何时使用通道或互斥锁来解决并发问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#race-问题"><span class="nav-number">59.</span> <span class="nav-text">race 问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context"><span class="nav-number">60.</span> <span class="nav-text">Context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误的传递-context"><span class="nav-number">61.</span> <span class="nav-text">错误的传递 context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时停止-Goroutine"><span class="nav-number">62.</span> <span class="nav-text">何时停止 Goroutine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range-中执行协程"><span class="nav-number">63.</span> <span class="nav-text">range 中执行协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-channel-的随机选择"><span class="nav-number">64.</span> <span class="nav-text">switch+channel  的随机选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-channel-作为通知信道"><span class="nav-number">65.</span> <span class="nav-text">使用 channel 作为通知信道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil-channel"><span class="nav-number">66.</span> <span class="nav-text">nil channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有-无缓冲的-channel"><span class="nav-number">67.</span> <span class="nav-text">有/无缓冲的 channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#append的时候-data-races"><span class="nav-number">68.</span> <span class="nav-text">append的时候 data races</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">69.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rex"
      src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
  <p class="site-author-name" itemprop="name">Rex</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">446</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa-hand-o-right"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rex</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
