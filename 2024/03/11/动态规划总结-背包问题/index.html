<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rexyan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"top","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="基础 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &amp;gt; 1 给你n ，请计算 F(n) 。  dp[i]的定义为：第i个数的斐波那契数值是dp[i] 状态转移方程 dp[i] = dp[">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划总结-背包问题">
<meta property="og:url" content="https://rexyan.github.io/2024/03/11/动态规划总结-背包问题/index.html">
<meta property="og:site_name" content="星尘">
<meta property="og:description" content="基础 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &amp;gt; 1 给你n ，请计算 F(n) 。  dp[i]的定义为：第i个数的斐波那契数值是dp[i] 状态转移方程 dp[i] = dp[">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%9F%BA%E7%A1%80.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20240311184649.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20240311185706.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20240311190131.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202403112307201.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-01%E8%83%8C%E5%8C%85.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20240312111451.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202403142305021.png">
<meta property="og:updated_time" content="2025-10-31T03:20:39.406Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="动态规划总结-背包问题">
<meta name="twitter:description" content="基础 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &amp;gt; 1 给你n ，请计算 F(n) 。  dp[i]的定义为：第i个数的斐波那契数值是dp[i] 状态转移方程 dp[i] = dp[">
<meta name="twitter:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%9F%BA%E7%A1%80.png">

<link rel="canonical" href="https://rexyan.github.io/2024/03/11/动态规划总结-背包问题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>动态规划总结-背包问题 | 星尘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css" />
  <!-- 自定义为霞鹜文楷字体 -->
  <style>
	  body,div.post-body,h1,h2,h3,h4 {
		font-family: "LXGW WenKai Screen", sans-serif;
		font-size: 104%;
	  }
  </style>
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">星尘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-读书">

    <a href="/books/" rel="section"><i class="address-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-瞎扯">

    <a href="/crap/" rel="section"><i class="crap fa-fw"></i>瞎扯</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



<script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script>

<meta name="referrer" content="never">




  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rexyan.github.io/2024/03/11/动态规划总结-背包问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
      <meta itemprop="name" content="Rex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星尘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划总结-背包问题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-11 11:55:57" itemprop="dateCreated datePublished" datetime="2024-03-11T11:55:57+00:00">2024-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-31 03:20:39" itemprop="dateModified" datetime="2025-10-31T03:20:39+00:00">2025-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/博客/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%9F%BA%E7%A1%80.png" alt></p>
<h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p>
<ol>
<li>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</li>
<li>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 排除 Corner Case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建 dp table </span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 dp 数组</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历顺序: 由前向后。因为后面要用到前面的状态</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 确定递归公式/状态转移公式</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。</p>
<ol>
<li><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p>
</li>
<li><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！所以dp[i] = dp[i - 1] + dp[i - 2] 。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h4><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 ：</p>
<ul>
<li>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</li>
<li>输出：6</li>
<li>解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</li>
</ul>
<ol>
<li><p>dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]</p>
</li>
<li><p>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。</p>
<p>dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。</p>
<p>dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。</p>
<p>那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (len(cost) + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 初始值，表示从起点开始不需要花费体力</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># 初始值，表示经过第一步不需要花费体力</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 在第i步，可以选择从前一步（i-1）花费体力到达当前步，或者从前两步（i-2）花费体力到达当前步</span></span><br><span class="line">            <span class="comment"># 选择其中花费体力较小的路径，加上当前步的花费，更新dp数组</span></span><br><span class="line">            dp[i] = min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len(cost)]  <span class="comment"># 返回到达楼顶的最小花费</span></span><br></pre></td></tr></table></figure>
<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/20240311184649.png" alt></p>
<ol>
<li><p><code>dp [i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有 <code>dp [i][j]</code> 条不同的路径。</p>
</li>
<li><p>想要求<code>dp [i][j]</code>，只能有两个方向来推导出来，即<code>dp [i-1][j]</code> 和 <code>dp [i][j-1]</code>。</p>
<p>此时在回顾一下 <code>dp[i - 1][j]</code> 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，<code>dp[i][j - 1]</code>同理。</p>
<p>那么很自然，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为dp[i][j]只有这两个方向过来。</p>
</li>
<li><p>首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理</p>
</li>
<li><p><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p>
<p>这样就可以保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值的。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 创建一个二维列表用于存储唯一路径数</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置第一行和第一列的基本情况</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算每个单元格的唯一路径数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回右下角单元格的唯一路径数</span></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/20240311185706.png" alt></p>
<ol>
<li><p><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。</p>
</li>
<li><p>递推公式和 不同路径 一样，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>。</p>
<p>但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）</p>
</li>
<li><p>初始化的时候，如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的<code>dp[i][0]</code>应该还是初始值0</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/20240311190131.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span> <span class="keyword">or</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>:  <span class="comment"># 遇到障碍物时，直接退出循环，后面默认都是0</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h4><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例: 输入: 10, 输出: 36, 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p>
<ol>
<li>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</li>
<li>有两种渠道得到dp[i], 一个是<code>j * (i - j)</code>直接相乘。一个是<code>j * dp[i - j]</code>，相当于是拆分(i - j)。也可以这么理解，<code>j * (i - j)</code>是单纯的把整数拆分为两个数相乘，而<code>j * dp[i - j]</code>是拆分成两个以及两个以上的个数相乘。所以递推公式：<code>dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});</code></li>
<li>那么在取最大值的时候，为什么还要比较dp[i] 呢？因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。</li>
<li>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]</li>
<li>因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。例如 6 拆成 <code>3 * 3</code>， 10 拆成 <code>3 * 3 * 4</code>。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成两个相同的 可能是最大值。那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 假设对正整数 i 拆分出的第一个正整数是 j（1 &lt;= j &lt; i），则有以下两种方案：</span></span><br><span class="line">    <span class="comment"># 1) 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j * (i-j)</span></span><br><span class="line">    <span class="comment"># 2) 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i-j]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)   <span class="comment"># 创建一个大小为n+1的数组来存储计算结果</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>  <span class="comment"># 初始化dp[2]为1，因为当n=2时，只有一个切割方式1+1=2，乘积为1</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment"># 从3开始计算，直到n</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 遍历所有可能的切割点</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i // <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 计算切割点j和剩余部分(i-j)的乘积，并与之前的结果进行比较取较大值</span></span><br><span class="line">                </span><br><span class="line">                dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]  <span class="comment"># 返回最终的计算结果</span></span><br></pre></td></tr></table></figure>
<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h4><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202403112307201.png" alt></p>
<p>当 n 为 3 的时候：</p>
<p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<p>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p>
<p>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p>
<p>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p>
<p>有2个元素的搜索树数量就是dp[2]。</p>
<p>有1个元素的搜索树数量就是dp[1]。</p>
<p>有0个元素的搜索树数量就是dp[0]。</p>
<p>所以<code>dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</code></p>
<ol>
<li><p>dp[i]：1到i为节点组成的二叉搜索树的个数为dp[i]。也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p>
</li>
<li><p>在上面的分析中，其实已经看出其递推关系， <code>dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</code></p>
<p>j相当于是头结点的元素，从1遍历到i为止。</p>
<p>所以递推公式：<code>dp[i] += dp[j - 1] * dp[i - j];</code> ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p>
</li>
<li><p>dp[0] = 1 需要初始化为 1，否则乘法的结果就都变成0了。</p>
</li>
<li><p>从递归公式：<code>dp[i] += dp[j - 1] * dp[i - j]</code>可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)  <span class="comment"># 创建一个长度为n+1的数组，初始化为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 当n为0时，只有一种情况，即空树，所以dp[0] = 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 遍历从1到n的每个数字</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):  <span class="comment"># 对于每个数字i，计算以i为根节点的二叉搜索树的数量</span></span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j]  <span class="comment"># 利用动态规划的思想，累加左子树和右子树的组合数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]  <span class="comment"># 返回以1到n为节点的二叉搜索树的总数量</span></span><br></pre></td></tr></table></figure>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-01%E8%83%8C%E5%8C%85.png" alt></p>
<h4 id="01背包-1"><a href="#01背包-1" class="headerlink" title="01背包"></a>01背包</h4><p>有n件物品和一个最多能背重量为w的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。例如：</p>
<p>背包最大重量为4。物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>问背包能背的物品最大价值是多少？</p>
<ul>
<li><p><strong><code>dp[i][j]</code> 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong></p>
</li>
<li><p><strong>不放物品i</strong>：由<code>dp[i - 1][j]</code>推出，即背包容量为j，里面不放物品i的最大价值，此时<code>dp[i][j]</code>就是<code>dp[i - 1][j]</code>。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</p>
</li>
<li><p><strong>放物品i</strong>：由<code>dp[i - 1][j - weight[i]]</code>推出，<code>dp[i - 1][j - weight[i]]</code> 为背包容量为<code>j - weight[i]</code>的时候不放物品 i 的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i]</code> （物品i的价值），就是背包放物品 i 得到的最大价值。</p>
</li>
<li>所以递归公式： <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></li>
<li>初始化的时候，第一列肯定都是0，因为背包大小为0 的时候，放不下任何物品。第一行则要根据实际情况来计算，第一行表示物品0尝试放到不同的背包中，这是如果背包可以放下，则 <code>dp[0][j]</code> 应该是value[0]，因为背包容量放足够放编号0物品。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/20240312111451.png" alt></p>
<ul>
<li>遍历顺序：这里先遍历背包和先遍历物品都可以，可以从递推公式看出，<code>dp[i][j]</code> 是从上方和左上方推导出来的，所以这里的遍历顺序关系不大。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_2_wei_bag_problem1</span><span class="params">()</span>:</span></span><br><span class="line">    weight = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    value = [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    bagweight = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 二维数组, 注意这里新增了第0列，所以 bagweight + 1</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (bagweight + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(weight))]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化。这里其实是 Python 特有的写法。 range(weight[0], bagweight + 1) 代表的是能放下第一个物品的背包开始。</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(weight[<span class="number">0</span>], bagweight + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># weight数组的大小就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(weight)):  <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(bagweight + <span class="number">1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; weight[i]:</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]  <span class="comment"># 容量为 j 的背包，放不下物品i</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]) <span class="comment"># 能放下，所以加上物品 i 的价值，value[i]</span></span><br><span class="line"></span><br><span class="line">    print(dp[len(weight) - <span class="number">1</span>][bagweight])  <span class="comment"># 取右下角的结果</span></span><br><span class="line"></span><br><span class="line">test_2_wei_bag_problem1()</span><br></pre></td></tr></table></figure>
<p><strong>滚动数组（一维数组）解法</strong></p>
<p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p>
<p>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></p>
<p>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>
<ul>
<li>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</li>
<li>dp[j]可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code> 表示容量为 <code>dp[j - weight[i]]</code> 的背包所背的最大价值。</li>
<li><code>dp[j - weight[i]] + value[i]</code> 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）。此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的<code>dp[i-1][j]</code>，即不放物品i，一个是取<code>dp[j - weight[i]] + value[i]</code>，即放物品i，指定是取最大的，毕竟是求最大价值，</li>
<li><p>所以递归公式: <code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></p>
</li>
<li><p><strong>遍历顺序：二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小</strong>。<strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品就会被重复加入多次！从后往前循环，每次取得状态不会和之前取得状态重合，这样就保证了每种物品只取了一次。</p>
</li>
<li><strong>两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，不可以先遍历背包容量嵌套遍历物品</strong>。背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_1_wei_bag_problem</span><span class="params">()</span>:</span></span><br><span class="line">    weight = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    value = [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    bagWeight = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (bagWeight + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(weight)):  <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(bagWeight, weight[i] - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># 遍历背包容量，range(bagWeight, weight[i]) 表示从能放下 weight[i] 的背包开始。</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line"></span><br><span class="line">    print(dp[bagWeight])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_1_wei_bag_problem()</span><br></pre></td></tr></table></figure>
<p><strong>01背包两种解法的区别：</strong></p>
<ol>
<li>使用一维数组时，必须先遍历物品，然后遍历背包。二维数组则没有要求，可以互换。</li>
<li>使用一维数组时，遍历背包是倒序遍历，即从大的背包开始处理。这么做是为了保证每个物品只被放入一次（从 dp 公式可以看出，dp[j] 是从 dp[j] 之前的数推导出来的，如果是正序遍历的话，就会有值被重复计算了两次，即物品被重复放入的情况。）</li>
</ol>
<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p>
<p>示例: 输入: [1, 5, 11, 5]，输出: true，解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
<ul>
<li>这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。那么只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</li>
<li>dp[j] 表示： 容量为j的背包，所背的物品价值最大可以为dp[j]。<strong>dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]</strong>（这题中，每一个元素的数值可以看成重量也可以看成价值）</li>
<li>01背包的递推公式为：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code>本题，相当于背包里放入数值，那么物品i的重量是 <code>nums[i]</code>，其价值也是 <code>nums[i]</code>。所以递推公式：<code>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        _sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[i]中的i表示背包内总和</span></span><br><span class="line">        <span class="comment"># 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line">        <span class="comment"># 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">10001</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            _sum += num</span><br><span class="line">        <span class="comment"># 也可以使用内置函数一步求和</span></span><br><span class="line">        <span class="comment"># _sum = sum(nums)</span></span><br><span class="line">        <span class="keyword">if</span> _sum % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = _sum // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始 0-1背包</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, num - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">                dp[j] = max(dp[j], dp[j - num] + num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 集合中的元素正好可以凑成总和target</span></span><br><span class="line">        <span class="keyword">if</span> dp[target] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h4><p>有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<p>如果 x == y，那么两块石头都会被完全粉碎；</p>
<p>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</p>
<p>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0</p>
<p>示例：</p>
<ul>
<li>输入：[2,7,4,1,8,1], 输出：1</li>
</ul>
<p>解释：</p>
<ul>
<li>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</li>
<li>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</li>
<li>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</li>
<li>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</li>
</ul>
<p>本题其实就是尽量让石头分成重量相同的<strong>两堆</strong>，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。</p>
<ul>
<li>dp[j] 表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]“</li>
<li>递推公式 <code>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</code></li>
<li>dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。而我们要求的target其实只是最大重量的一半。</li>
<li><strong>在计算 target 的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeightII</span><span class="params">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">15001</span></span><br><span class="line">        total_sum = sum(stones)</span><br><span class="line">        target = total_sum // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> stone <span class="keyword">in</span> stones:  <span class="comment"># 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, stone - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># 遍历背包</span></span><br><span class="line">                dp[j] = max(dp[j], dp[j - stone] + stone)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> total_sum - dp[target] - dp[target]</span><br></pre></td></tr></table></figure>
<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h4><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<ul>
<li>输入：nums: [1, 1, 1, 1, 1], S: 3，输出：5</li>
</ul>
<p>解释：</p>
<ul>
<li>-1+1+1+1+1 = 3</li>
<li>+1-1+1+1+1 = 3</li>
<li>+1+1-1+1+1 = 3</li>
<li>+1+1+1-1+1 = 3</li>
<li>+1+1+1+1-1 = 3</li>
</ul>
<p>一共有5种方法让最终目标和为3。</p>
<ul>
<li><p>假设加法的总和为x，那么减法对应的总和就是<code>sum - x</code>。所以我们要求的是 <code>x - (sum - x) = target</code>，<code>x = (target + sum) / 2</code> <strong>此时问题就转化为，装满容量为x的背包，有几种方法</strong>。这里的x，就是 bagSize，也就是我们后面要求的背包容量。</p>
</li>
<li><p>每个物品（题目中的1）只用一次，所以是 01 背包。</p>
</li>
<li><p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p>
</li>
<li><p>有哪些来源可以推出dp[j]呢？只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。</p>
<p>例如：dp[j]，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
</li>
<li><p>所以递推公式为：<code>dp[j] += dp[j - nums[i]]</code></p>
</li>
<li><p>目标和为0时，只有一种方案，即什么都不选, 即 dp[0] 为 1</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 计算nums的总和</span></span><br><span class="line">        total_sum = sum(nums)  </span><br><span class="line">        <span class="keyword">if</span> abs(target) &gt; total_sum:</span><br><span class="line">          	<span class="comment"># 此时没有方案</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">if</span> (target + total_sum) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">          	<span class="comment"># 此时没有方案</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">        <span class="comment"># 目标和</span></span><br><span class="line">        target_sum = (target + total_sum) // <span class="number">2</span>  </span><br><span class="line">        <span class="comment"># 创建动态规划数组，初始化为0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target_sum + <span class="number">1</span>)  </span><br><span class="line">        <span class="comment"># 当目标和为0时，只有一种方案，即什么都不选</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target_sum, num - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j] += dp[j - num]  <span class="comment"># 状态转移方程，累加不同选择方式的数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[target_sum]  <span class="comment"># 返回达到目标和的方案数</span></span><br></pre></td></tr></table></figure>
<h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h4><p><a href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE" target="_blank" rel="noopener">https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.png" alt></p>
<h4 id="完全背包-1"><a href="#完全背包-1" class="headerlink" title="完全背包"></a>完全背包</h4><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。例如，物品重量和价值如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><strong>每件商品都有无限个！</strong>问背包能背的物品最大价值是多少？</p>
<ul>
<li><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</p>
</li>
<li><p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历。</p>
</li>
<li>01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。<strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的</strong> 因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。也就是说<strong>对于纯完全背包问题，其for循环的先后循环是可以颠倒的</strong>！</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1: 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_CompletePack</span><span class="params">()</span>:</span></span><br><span class="line">    weight = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    value = [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    bagWeight = <span class="number">4</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (bagWeight + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(weight)):  <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(weight[i], bagWeight + <span class="number">1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line">    print(dp[bagWeight])</span><br><span class="line">test_CompletePack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2: 先遍历背包，再遍历物品</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_CompletePack</span><span class="params">()</span>:</span></span><br><span class="line">    weight = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    value = [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">    bagWeight = <span class="number">4</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (bagWeight + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(bagWeight + <span class="number">1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(weight)):  <span class="comment"># 遍历物品</span></span><br><span class="line">            <span class="keyword">if</span> j - weight[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</span><br><span class="line">    print(dp[bagWeight])</span><br><span class="line">test_CompletePack()</span><br></pre></td></tr></table></figure>
<h4 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h4><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。示例:</p>
<ul>
<li>输入: amount = 5, coins = [1, 2, 5]，输出: 4</li>
</ul>
<p>解释: 有四种方式可以凑成总金额:</p>
<ul>
<li>5=5</li>
<li>5=2+2+1</li>
<li>5=2+1+1+1</li>
<li>5=1+1+1+1+1</li>
</ul>
<ul>
<li><p>注意本题目是求组合数，<strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong>。<code>5 = 2 + 2 + 1</code>, </p>
<p><code>5 = 2 + 1 + 2</code>, 这表示一种组合，都是 2 2 1。但却是两种排列。</p>
</li>
<li><p>dp[j]：凑成总金额j的货币组合数为dp[j]</p>
</li>
<li><p>dp[j] 就是所有的<code>dp[j - coins[i]]</code>（考虑coins[i]的情况）相加。所以递推公式：<code>dp[j] += dp[j - coins[i]]</code></p>
</li>
<li><p>dp[0] 应该为1</p>
<blockquote>
<p>对于这个递推公式 <code>dp[j] += dp[j - coins[i]]</code>，其中 <code>dp[j]</code> 表示组合凑成金额 <code>j</code> 的方法数。当我们考虑凑出金额为 0 的情况时，我们需要思考一下。</p>
<p>如果 <code>dp[0]</code> 为 0，那么意味着没有任何硬币可以组合凑出金额为 0。这看起来似乎是合理的，因为我们没有任何硬币可用。然而，在动态规划中，我们需要考虑一种特殊的情况，即不使用任何硬币。当需要凑出金额为 0 时，我们实际上可以选择不使用任何硬币，这样就有一种方法可以凑出金额为 0，即空集合 <code>{}</code>。</p>
<p>因此，为了确保我们在计算后续金额时不会漏掉这种情况，我们将 <code>dp[0]</code> 初始化为 1，表示存在一种方法凑出金额为 0。这样，我们的动态规划递推过程就能正确地计算出凑出其他金额的方法数。</p>
<p>总结起来，将 <code>dp[0]</code> 初始化为 1 是为了处理金额为 0 的特殊情况，确保不会漏掉这种情况，并在后续的递推过程中得到正确的结果。– By GPT-3.5</p>
</blockquote>
</li>
<li><p>对于遍历顺序，这里因为是求组合，所以一定是 <strong>外层for循环遍历物品，内层for遍历背包</strong>。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*(amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(coins)):</span><br><span class="line">            <span class="comment"># 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i], amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] += dp[j - coins[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h4 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a>组合总和 Ⅳ</h4><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例: nums = [1, 2, 3]，target = 4。所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)，请注意，顺序不同的序列被视作不同的组合。因此输出为 7</p>
<ul>
<li><strong>本题就是求排列</strong>，组合不强调顺序，排列强调顺序</li>
<li><strong>dp[i]: 凑成目标正整数为i的排列个数为dp[i]</strong></li>
<li>递推公式：<code>dp[i] += dp[i - nums[j]]</code></li>
<li>同上，dp[0] 应该为1</li>
<li>这里需要考虑顺序，所以 <strong>外层for遍历背包，内层for循环遍历物品</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):  <span class="comment"># 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):  <span class="comment"># 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> i - nums[j] &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i] += dp[i - nums[j]]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>
<h4 id="爬楼梯（进阶版）"><a href="#爬楼梯（进阶版）" class="headerlink" title="爬楼梯（进阶版）"></a>爬楼梯（进阶版）</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。</p>
<p>输入描述：输入共一行，包含两个正整数，分别表示n, m。输出描述：输出一个整数，表示爬到楼顶的方法数。</p>
<p>输入示例：3 2，输出示例：3。提示：当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。</p>
<p>此时你有三种方法可以爬到楼顶。</p>
<ul>
<li>1 阶 + 1 阶 + 1 阶段</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ul>
<p>1阶，2阶，…. m阶就是物品，楼顶就是背包。每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。</p>
<p>问跳到楼顶有几种方法其实就是问装满背包有几种方法。<strong>此时大家应该发现这就是一个完全背包问题了！</strong></p>
<ul>
<li><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong></li>
<li>求装满背包有几种方法，递推公式一般都是 <code>dp[i] += dp[i - nums[j]]</code></li>
<li>同上，dp[0] 应该为1</li>
<li>这里对强调顺序，所以这里是求排列，所以 <strong>外层for遍历背包（楼顶），内层for循环遍历物品（1阶，2阶）</strong></li>
</ul>
<p>代码和上题一样。</p>
<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的<strong>最少</strong>的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。</p>
<p>示例 ：输入：coins = [1, 2, 5], amount = 11，输出：3，解释：11 = 5 + 5 + 1</p>
<ul>
<li><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p>
</li>
<li><p>对于当前的金额 i，我们遍历硬币数组 coins，对于每个硬币的面额 coin，我们考虑两种情况：</p>
<ol>
<li><p>如果当前的硬币面额 coin 小于等于金额 i，也就是说可以使用这个硬币来凑成金额 i。那么我们需要考虑将这个硬币放入组合中的情况。</p>
<p>在这种情况下，我们需要计算凑成金额 i - coin 所需的最少硬币个数，即 dp[i - coin]。因为当前硬币 coin 的面额是已知的，所以凑成金额 i 的最少硬币个数就是凑成金额 i - coin 的最少硬币个数再加上一个硬币，所以是 dp[i - coin] + 1。</p>
</li>
<li><p>如果当前的硬币面额 coin 大于金额 i，也就是说无法使用这个硬币来凑成金额 i。那么我们不需要考虑将这个硬币放入组合中的情况，直接跳过即可。</p>
</li>
</ol>
<p>综上所述，我们选取两种情况中最小的硬币个数，即 min(dp[i], dp[i - coin] + 1)，作为凑成金额 i 的最少硬币个数。</p>
</li>
<li><p>凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0</p>
</li>
<li><p>考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在<code>min(dp[j - coins[i]] + 1, dp[j])</code>比较的过程中被初始值覆盖。所以下标非0的元素都是应该是最大值。</p>
</li>
<li><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。所以本题并不强调集合是组合还是排列。所以顺序不重要。</p>
</li>
<li><p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序。（01背包，一维数组因为物品不能重复使用，所以内循环是倒序，且外循环遍历物品，内循环遍历背包容量）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先遍历物品，后遍历背包</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)  <span class="comment"># 创建动态规划数组，初始值为正无穷大</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 初始化背包容量为0时的最小硬币数量为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:  <span class="comment"># 遍历硬币列表，相当于遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(coin, amount + <span class="number">1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">                <span class="keyword">if</span> dp[i - coin] != float(<span class="string">'inf'</span>):  <span class="comment"># 如果dp[i - coin]不是初始值，则进行状态转移</span></span><br><span class="line">                    dp[i] = min(dp[i - coin] + <span class="number">1</span>, dp[i])  <span class="comment"># 更新最小硬币数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[amount] == float(<span class="string">'inf'</span>):  <span class="comment"># 如果最终背包容量的最小硬币数量仍为正无穷大，表示无解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]  <span class="comment"># 返回背包容量为amount时的最小硬币数量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先便利背包，后遍历物品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (amount + <span class="number">1</span>)  <span class="comment"># 创建动态规划数组，初始值为正无穷大</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 初始化背包容量为0时的最小硬币数量为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount + <span class="number">1</span>):  <span class="comment"># 遍历背包容量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(coins)):  <span class="comment"># 遍历硬币列表，相当于遍历物品</span></span><br><span class="line">                <span class="comment"># 如果dp[i - coins[j]]不是初始值，则进行状态转移</span></span><br><span class="line">                <span class="keyword">if</span> i - coins[j] &gt;= <span class="number">0</span> <span class="keyword">and</span> dp[i - coins[j]] != float(<span class="string">'inf'</span>):  </span><br><span class="line">                    dp[i] = min(dp[i - coins[j]] + <span class="number">1</span>, dp[i])  <span class="comment"># 更新最小硬币数量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[amount] == float(<span class="string">'inf'</span>):  <span class="comment"># 如果最终背包容量的最小硬币数量仍为正无穷大，表示无解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]  <span class="comment"># 返回背包容量为amount时的最小硬币数量</span></span><br></pre></td></tr></table></figure>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>示例 1：输入：n = 12，输出：3，解释：12 = 4 + 4 + 4</p>
<p>示例 2：输入：n = 13，输出：2，解释：13 = 4 + 9</p>
<ul>
<li><strong>完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？</strong></li>
<li><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></li>
<li>dp[j] 可以由<code>dp[j - i * i]</code>推出， <code>dp[j - i * i] + 1</code> 便可以凑成dp[j]。此时我们要选择最小的dp[j]，所以递推公式：<code>dp[j] = min(dp[j - i * i] + 1, dp[j])</code></li>
<li>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0</li>
<li>从递归公式 <code>dp[j] = min(dp[j - i * i] + 1, dp[j])</code> 中可以看出每次dp[j]都要选最小的，<strong>所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖</strong>。</li>
<li>这里是求个数，所以有顺序和没有顺序都可以，即不管是谁在外循环，谁在内循环都可以。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先遍历物品, 再遍历背包</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):  <span class="comment"># 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, int(i ** <span class="number">0.5</span>) + <span class="number">1</span>):  <span class="comment"># 遍历物品</span></span><br><span class="line">                <span class="comment"># 更新凑成数字 i 所需的最少完全平方数数量</span></span><br><span class="line">                dp[i] = min(dp[i], dp[i - j * j] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先遍历背包, 再遍历物品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, int(n ** <span class="number">0.5</span>) + <span class="number">1</span>):  <span class="comment"># 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i * i, n + <span class="number">1</span>):  <span class="comment"># 遍历背包</span></span><br><span class="line">                <span class="comment"># 更新凑成数字 j 所需的最少完全平方数数量</span></span><br><span class="line">                dp[j] = min(dp[j - i * i] + <span class="number">1</span>, dp[j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在内部循环中，<code>j</code> 表示正在考虑的完全平方数。通过从 1 遍历到 <code>int(i ** 0.5) + 1</code>，代码确保了在计算 <code>dp[i]</code> 时只考虑了不超过 <code>i</code> 的完全平方数。这是因为在计算 <code>dp[i]</code> 时，我们只需要考虑小于等于 <code>i</code> 的完全平方数的情况。</p>
<p>例如，当 <code>i</code> 为 9 时，<code>int(i ** 0.5) + 1</code> 等于 4。因此，在内部循环中，<code>j</code> 的取值为 1、2、3，分别对应完全平方数 1、4、9。这样，我们只考虑了小于等于 9 的完全平方数，而不需要考虑更大的完全平方数。</p>
<p>通过这样的循环范围，代码能够有效地在每个 <code>i</code> 的情况下找到最少的完全平方数的数量，以更新 <code>dp[i]</code> 的值。  –By GPT3.5</p>
</blockquote>
<h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h4><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。</p>
<p>示例：输入: s = “applepenapple”, wordDict = [“apple”, “pen”], 输出: true，解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。注意你可以重复使用字典中的单词</p>
<ul>
<li><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p>
</li>
<li><p>拆分时可以重复使用字典中的单词，说明就是一个完全背包</p>
</li>
<li><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p>
</li>
<li><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。所以递推公式是 <code>if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true</code></p>
</li>
<li><p>dp[i] 的状态依靠 dp[j] 是否为true，那么dp[0] 就是递推的根基，dp[0] 一定要为true，否则递推下去后面都都是false了</p>
</li>
<li><p>下标非0的 dp[i] 初始化为 false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词</p>
</li>
<li><p>本题其实我们求的是排列数，为什么呢。 拿  s = “applepenapple”, wordDict = [“apple”, “pen”] 举例。”apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。”apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 是不可以的，<strong>那么我们就是强调物品之间顺序。</strong>所以本题一定是 先遍历 背包，再遍历物品。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">        wordSet = set(wordDict)</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)  <span class="comment"># dp[i] 表示字符串的前 i 个字符是否可以被拆分成单词</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span>  <span class="comment"># 初始状态，空字符串可以被拆分成单词</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i): <span class="comment"># 遍历单词</span></span><br><span class="line">              	<span class="comment"># 如果 s[0:j] 可以被拆分成单词，并且 s[j:i] 在单词集合中存在，则 s[0:i] 可以被拆分成单词</span></span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordSet:</span><br><span class="line">                    dp[i] = <span class="literal">True</span>  </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%80%BB%E7%BB%93</a></p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202403142305021.png" alt></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/02/04/Docker 搭建 RustDesk/" rel="prev" title="Docker 搭建 RustDesk">
      <i class="fa fa-chevron-left"></i> Docker 搭建 RustDesk
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/16/动态规划总结-打家劫舍/" rel="next" title="动态规划总结-打家劫舍">
      动态规划总结-打家劫舍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#斐波那契数"><span class="nav-number">1.1.</span> <span class="nav-text">斐波那契数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#爬楼梯"><span class="nav-number">1.2.</span> <span class="nav-text">爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用最小花费爬楼梯"><span class="nav-number">1.3.</span> <span class="nav-text">使用最小花费爬楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同路径"><span class="nav-number">1.4.</span> <span class="nav-text">不同路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同路径-II"><span class="nav-number">1.5.</span> <span class="nav-text">不同路径 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整数拆分"><span class="nav-number">1.6.</span> <span class="nav-text">整数拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同的二叉搜索树"><span class="nav-number">1.7.</span> <span class="nav-text">不同的二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01背包"><span class="nav-number">2.</span> <span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01背包-1"><span class="nav-number">2.1.</span> <span class="nav-text">01背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分割等和子集"><span class="nav-number">2.2.</span> <span class="nav-text">分割等和子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最后一块石头的重量II"><span class="nav-number">2.3.</span> <span class="nav-text">最后一块石头的重量II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目标和"><span class="nav-number">2.4.</span> <span class="nav-text">目标和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一和零"><span class="nav-number">2.5.</span> <span class="nav-text">一和零</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完全背包"><span class="nav-number">3.</span> <span class="nav-text">完全背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#完全背包-1"><span class="nav-number">3.1.</span> <span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#零钱兑换II"><span class="nav-number">3.2.</span> <span class="nav-text">零钱兑换II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合总和-Ⅳ"><span class="nav-number">3.3.</span> <span class="nav-text">组合总和 Ⅳ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#爬楼梯（进阶版）"><span class="nav-number">3.4.</span> <span class="nav-text">爬楼梯（进阶版）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#零钱兑换"><span class="nav-number">3.5.</span> <span class="nav-text">零钱兑换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完全平方数"><span class="nav-number">3.6.</span> <span class="nav-text">完全平方数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单词拆分"><span class="nav-number">3.7.</span> <span class="nav-text">单词拆分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rex"
      src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
  <p class="site-author-name" itemprop="name">Rex</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">446</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa-hand-o-right"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rex</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
