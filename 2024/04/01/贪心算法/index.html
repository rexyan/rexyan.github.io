<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rexyan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"top","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="简单分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &amp;gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例  1，输入">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心算法">
<meta property="og:url" content="https://rexyan.github.io/2024/04/01/贪心算法/index.html">
<meta property="og:site_name" content="星尘">
<meta property="og:description" content="简单分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &amp;gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例  1，输入">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202403312133648.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061731887.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061741685.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061752347.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061752584.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061755521.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061831528.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071009146.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071016752.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071054281.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071108216.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071125308.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071139659.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071205073.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071452982.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071454720.png">
<meta property="og:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071513532.png">
<meta property="og:updated_time" content="2025-10-31T03:20:39.411Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="贪心算法">
<meta name="twitter:description" content="简单分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &amp;gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例  1，输入">
<meta name="twitter:image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/202403312133648.png">

<link rel="canonical" href="https://rexyan.github.io/2024/04/01/贪心算法/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>贪心算法 | 星尘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css" />
  <!-- 自定义为霞鹜文楷字体 -->
  <style>
	  body,div.post-body,h1,h2,h3,h4 {
		font-family: "LXGW WenKai Screen", sans-serif;
		font-size: 104%;
	  }
  </style>
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">星尘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-读书">

    <a href="/books/" rel="section"><i class="address-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-瞎扯">

    <a href="/crap/" rel="section"><i class="crap fa-fw"></i>瞎扯</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



<script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script>

<meta name="referrer" content="never">




  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rexyan.github.io/2024/04/01/贪心算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
      <meta itemprop="name" content="Rex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星尘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          贪心算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-01 22:55:57" itemprop="dateCreated datePublished" datetime="2024-04-01T22:55:57+00:00">2024-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-31 03:20:39" itemprop="dateModified" datetime="2025-10-31T03:20:39+00:00">2025-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/博客/" itemprop="url" rel="index"><span itemprop="name">博客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><h4 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例  1，输入: g = [1,2,3], s = [1,1]，输出: 1 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。</p>
<ul>
<li><p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p>
</li>
<li><p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
</li>
<li><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
</li>
<li><p>先遍历胃口，后遍历的饼干。如果是先遍历饼干，那么可能会出现饼干比胃口小，而满足不了其他小胃口的情况。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202403312133648.png" alt></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大饼干优先</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(self, g, s)</span>:</span></span><br><span class="line">        g.sort()  <span class="comment"># 将孩子的贪心因子排序</span></span><br><span class="line">        s.sort()  <span class="comment"># 将饼干的尺寸排序</span></span><br><span class="line">        index = len(s) - <span class="number">1</span>  <span class="comment"># 饼干数组的下标，从最后一个饼干开始</span></span><br><span class="line">        result = <span class="number">0</span>  <span class="comment"># 满足孩子的数量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(g)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 遍历胃口，从最后一个孩子开始</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= <span class="number">0</span> <span class="keyword">and</span> s[index] &gt;= g[i]:  <span class="comment"># 遍历饼干</span></span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小饼干优先</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(self, g, s)</span>:</span></span><br><span class="line">        g.sort()  <span class="comment"># 将孩子的贪心因子排序</span></span><br><span class="line">        s.sort()  <span class="comment"># 将饼干的尺寸排序</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):  <span class="comment"># 遍历饼干</span></span><br><span class="line">            <span class="keyword">if</span> index &lt; len(g) <span class="keyword">and</span> g[index] &lt;= s[i]:  <span class="comment"># 如果当前孩子的贪心因子小于等于当前饼干尺寸</span></span><br><span class="line">                index += <span class="number">1</span>  <span class="comment"># 满足一个孩子，指向下一个孩子</span></span><br><span class="line">        <span class="keyword">return</span> index  <span class="comment"># 返回满足的孩子数目</span></span><br></pre></td></tr></table></figure>
<h4 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h4><p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）以这种方式修改数组后，返回数组可能的最大和。</p>
<p>示例，输入：A = [4,2,3], K = 1，输出：5，解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</p>
<ul>
<li>贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</li>
<li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li>
<li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li>
<li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li>
<li>第四步：求和</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestSumAfterKNegations</span><span class="params">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class="line">        A.sort(key=<span class="keyword">lambda</span> x: abs(x), reverse=<span class="literal">True</span>)  <span class="comment"># 第一步：按照绝对值降序排序数组A</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):  <span class="comment"># 第二步：执行K次取反操作</span></span><br><span class="line">            <span class="keyword">if</span> A[i] &lt; <span class="number">0</span> <span class="keyword">and</span> K &gt; <span class="number">0</span>:</span><br><span class="line">                A[i] *= <span class="number">-1</span></span><br><span class="line">                K -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> K % <span class="number">2</span> == <span class="number">1</span>:  <span class="comment"># 第三步：如果K还有剩余次数，将绝对值最小的元素取反</span></span><br><span class="line">            A[<span class="number">-1</span>] *= <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        result = sum(A)  <span class="comment"># 第四步：计算数组A的元素和</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h4><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<p>输入：[5,5,5,10,20]，输出：true，解释：</p>
<ol>
<li><p>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</p>
</li>
<li><p>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</p>
</li>
<li><p>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</p>
</li>
<li><p>由于所有客户都得到了正确的找零，所以我们输出 true。</p>
</li>
</ol>
<ul>
<li><p>只需要维护三种金额的数量，5，10和20。有如下三种情况：</p>
<ul>
<li>情况一：账单是5，直接收下。</li>
<li>情况二：账单是10，消耗一个5，增加一个10</li>
<li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li>
</ul>
</li>
<li><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？<strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p>
</li>
<li>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span><span class="params">(self, bills: List[int])</span> -&gt; bool:</span></span><br><span class="line">        five = <span class="number">0</span></span><br><span class="line">        ten = <span class="number">0</span></span><br><span class="line">        twenty = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="comment"># 情况一：收到5美元</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">5</span>:</span><br><span class="line">                five += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况二：收到10美元</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> five &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                ten += <span class="number">1</span></span><br><span class="line">                five -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情况三：收到20美元</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">20</span>:</span><br><span class="line">                <span class="comment"># 先尝试使用10美元和5美元找零</span></span><br><span class="line">                <span class="keyword">if</span> five &gt; <span class="number">0</span> <span class="keyword">and</span> ten &gt; <span class="number">0</span>:</span><br><span class="line">                    five -= <span class="number">1</span></span><br><span class="line">                    ten -= <span class="number">1</span></span><br><span class="line">                    <span class="comment">#twenty += 1</span></span><br><span class="line">                <span class="comment"># 如果无法使用10美元找零，则尝试使用三张5美元找零</span></span><br><span class="line">                <span class="keyword">elif</span> five &gt;= <span class="number">3</span>:</span><br><span class="line">                    five -= <span class="number">3</span></span><br><span class="line">                    <span class="comment">#twenty += 1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="中等-序列问题"><a href="#中等-序列问题" class="headerlink" title="中等-序列问题"></a>中等-序列问题</h3><h4 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和  [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>示例 1，输入: [1,7,4,9,2,5]，输出: 6，解释: 整个序列均为摆动序列。</p>
<p>示例 2，输入: [1,17,5,10,13,15,10,5,16,8]，输出: 7，解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p>
<ul>
<li><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。<strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061731887.png" alt></p>
</li>
<li><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p>
</li>
<li><p>prediff =（nums[i] - nums[i-1]）, curdiff =（nums[i+1] - nums[i]）</p>
</li>
<li><p>需要考虑三种情况</p>
<ul>
<li><p><strong>情况一：上下坡中有平坡</strong></p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061741685.png" alt></p>
<p>它的摇摆序列长度是多少呢？ <strong>其实是长度是 3</strong>，也就是我们在删除的时候 要不删除左面的三个 2，要不就删除右边的三个 2。这种情况下，可以删除左边的三个2，也可以删除右边的三个2。所以我们记录峰值的条件应该是： <code>(preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)</code></p>
</li>
<li><p><strong>情况二：数组首尾两端</strong></p>
<p>题目中说了，如果只有两个不同的元素，那摆动序列也是 2。因为我们在计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]）的时候，至少需要三个数字才能计算，而数组只有两个数字。这里我们可以写死，就是 如果只有两个元素，且元素不同，那么结果为 2。</p>
<p>那么不写死的话，如何和我们的判断规则结合在一起呢？可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff &lt; 0 或者 &gt;0 也记为波谷。那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0结果为 2。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061752347.png" alt></p>
<p>针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）。<strong>所以将 result 初始化为 1，这是为了解决只有两个元素的情况。</strong></p>
</li>
<li><p><strong>情况三：单调坡度有平坡</strong></p>
<p>在版本一中，我们忽略了一种情况，即 如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]，如图</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061752584.png" alt></p>
<p>版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。之所以版本一会出问题，是因为我们实时更新了 prediff。那么我们应该什么时候更新 prediff 呢？我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。</p>
</li>
</ul>
</li>
<li><p><strong>本题异常情况的本质，就是要考虑平坡</strong>， 平坡分两种，一个是 上下中间有平坡，一个是单调有平坡</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061755521.png" alt></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)  <span class="comment"># 如果数组长度为0或1，则返回数组长度</span></span><br><span class="line">        curDiff = <span class="number">0</span>  <span class="comment"># 当前一对元素的差值</span></span><br><span class="line">        preDiff = <span class="number">0</span>  <span class="comment"># 前一对元素的差值</span></span><br><span class="line">        result = <span class="number">1</span>  <span class="comment"># 记录峰值的个数，初始为1（默认最右边的元素被视为峰值）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i]  <span class="comment"># 计算下一个元素与当前元素的差值</span></span><br><span class="line">            <span class="comment"># 如果遇到一个峰值</span></span><br><span class="line">            <span class="keyword">if</span> (preDiff &lt;= <span class="number">0</span> <span class="keyword">and</span> curDiff &gt; <span class="number">0</span>) <span class="keyword">or</span> (preDiff &gt;= <span class="number">0</span> <span class="keyword">and</span> curDiff &lt; <span class="number">0</span>):</span><br><span class="line">                result += <span class="number">1</span>  <span class="comment"># 峰值个数加1</span></span><br><span class="line">                preDiff = curDiff  <span class="comment"># 注意这里，只在摆动变化的时候更新preDiff</span></span><br><span class="line">        <span class="keyword">return</span> result  <span class="comment"># 返回最长摆动子序列的长度</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)  <span class="comment"># 如果数组长度为0或1，则返回数组长度</span></span><br><span class="line">        <span class="comment">#题目里nums长度大于等于1，当长度为1时，其实到不了for循环里去，所以不用考虑nums长度</span></span><br><span class="line">        preDiff,curDiff ,result  = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span> curDiff * preDiff &lt;= <span class="number">0</span> <span class="keyword">and</span> curDiff !=<span class="number">0</span>:  <span class="comment">#差值为0时，不算摆动</span></span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">                <span class="comment">#如果当前差值和上一个差值为一正一负时，才需要用当前差值替代上一个差值</span></span><br><span class="line">                preDiff = curDiff  </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h4><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p>
<p>示例 1，输入: N = 10，输出: 9</p>
<p>示例 2，输入: N = 1234，输出: 1234</p>
<p>示例 3，输入: N = 332，输出: 299</p>
<ul>
<li>例如 98，一旦出现 strNum[i - 1] &gt; strNum[i] 的情况（非单调递增），首先想让 strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</li>
<li>以 332 举例，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</li>
</ul>
<p>贪心解法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 将整数转换为字符串</span></span><br><span class="line">        strNum = list(str(N))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从右往左遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strNum) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 如果当前字符比前一个字符小，说明需要修改前一个字符</span></span><br><span class="line">            <span class="keyword">if</span> strNum[i - <span class="number">1</span>] &gt; strNum[i]:</span><br><span class="line">                print(<span class="string">f"前一个元素 <span class="subst">&#123;strNum[i - <span class="number">1</span>]&#125;</span> 大于当前元素<span class="subst">&#123;strNum[i]&#125;</span>"</span>)</span><br><span class="line">                strNum[i - <span class="number">1</span>] = str(int(strNum[i - <span class="number">1</span>]) - <span class="number">1</span>)  <span class="comment"># 将前一个字符减1</span></span><br><span class="line">                <span class="comment"># 将修改位置后面的字符都设置为9，因为修改前一个字符可能破坏了递增性质</span></span><br><span class="line">                print(<span class="string">f"此时数据变为: <span class="subst">&#123;strNum&#125;</span>"</span>)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(strNum)):</span><br><span class="line">                    strNum[j] = <span class="string">'9'</span></span><br><span class="line">                print(<span class="string">f"填充 9 后为: <span class="subst">&#123;strNum&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将列表转换为字符串，并将字符串转换为整数并返回</span></span><br><span class="line">        <span class="keyword">return</span> int(<span class="string">''</span>.join(strNum))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    r = s.monotoneIncreasingDigits(<span class="number">31490</span>)</span><br><span class="line">    print(r)</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">前一个元素 9 大于当前元素0</span></span><br><span class="line"><span class="string">此时数据变为: ['3', '1', '4', '8', '0']</span></span><br><span class="line"><span class="string">填充 9 后为: ['3', '1', '4', '8', '9']</span></span><br><span class="line"><span class="string">前一个元素 3 大于当前元素1</span></span><br><span class="line"><span class="string">此时数据变为: ['2', '1', '4', '8', '9']</span></span><br><span class="line"><span class="string">填充 9 后为: ['2', '9', '9', '9', '9']</span></span><br><span class="line"><span class="string">29999</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>暴力解法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        max_digit = <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            digit = num % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> max_digit &gt;= digit:</span><br><span class="line">                max_digit = digit</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            num //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.checkNum(i):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>checkNum</code> 方法接收一个整数 <code>num</code>，它的作用是检查 <code>num</code> 的每个数字是否按照递增的顺序排列。它通过不断地取出 <code>num</code> 的个位数字，并与一个变量 <code>max_digit</code> 比较，来判断当前数字是否小于等于之前遇到的最大数字。如果满足条件，则更新 <code>max_digit</code> 为当前数字，否则返回 <code>False</code>。最后，如果所有的数字都满足条件，即整个 <code>num</code> 是递增的，那么返回 <code>True</code>。</p>
<h3 id="中等-股票问题"><a href="#中等-股票问题" class="headerlink" title="中等-股票问题"></a>中等-股票问题</h3><h4 id="买卖股票最佳时机II"><a href="#买卖股票最佳时机II" class="headerlink" title="买卖股票最佳时机II"></a>买卖股票最佳时机II</h4><p>给定一个数组，它的第  i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1，输入: [7,1,5,3,6,4]，输出:7，解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
<p>示例 2，输入: [1,2,3,4,5]，输出: 4，解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<ul>
<li><p>这道题目可能我们只会想，选一个低的买入，再选个高的卖，再选一个低的买入…..循环反复。<strong>如果想到其实最终利润是可以分解的，那么本题就很容易了</strong></p>
</li>
<li><p>假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。<strong>此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404061831528.png" alt></p>
<ul>
<li>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong></li>
<li>那么只收集正利润就是贪心所贪的地方！<strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            result += max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="有难度-区间问题"><a href="#有难度-区间问题" class="headerlink" title="有难度-区间问题"></a>有难度-区间问题</h3><h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p>示例  1，输入: [2,3,1,1,4]，输出: true，解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<p>示例  2，输入: [3,2,1,0,4]，输出: false，解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<ul>
<li>当前位置元素如果是 3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？其实跳几步无所谓，关键在于可跳的覆盖范围。</li>
<li>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。这个范围内，别管是怎么跳的，反正一定可以跳过来。</li>
<li><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></li>
<li>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。<strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071009146.png" alt></p>
<ul>
<li>i 每次移动只能在 cover 的范围内移动，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。而 cover 每次只取 max(该元素数值补充后的范围, cover 本身范围)。如果 cover 大于等于了终点下标，直接 return true 就可以了</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        cover = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># python不支持动态修改for循环中变量,使用while循环代替</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= cover:</span><br><span class="line">            cover = max(i + nums[i], cover)</span><br><span class="line">            <span class="keyword">if</span> cover &gt;= len(nums) - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>示例，输入: [2,3,1,1,4]，输出: 2，解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳  1 步，然后跳  3 步到达数组的最后一个位置。说明: 假设你总是可以到达数组的最后一个位置。</p>
<ul>
<li>本题求解的是最少的跳跃次数，上题求解的是判断你是否能够到达最后一个位置</li>
<li>本题要计算最少步数，那么就要想清楚什么时候步数才一定要加一</li>
<li>贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。</li>
<li><strong>不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数</strong></li>
<li><strong>所以这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071016752.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        cur_distance = <span class="number">0</span>  <span class="comment"># 当前覆盖最远距离下标</span></span><br><span class="line">        ans = <span class="number">0</span>  <span class="comment"># 记录走的最大步数</span></span><br><span class="line">        next_distance = <span class="number">0</span>  <span class="comment"># 下一步覆盖最远距离下标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            next_distance = max(nums[i] + i, next_distance)  <span class="comment"># 更新下一步覆盖最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> i == cur_distance:  <span class="comment"># 遇到当前覆盖最远距离下标</span></span><br><span class="line">                ans += <span class="number">1</span>  <span class="comment"># 需要走下一步</span></span><br><span class="line">                cur_distance = next_distance  <span class="comment"># 更新当前覆盖最远距离下标（相当于加油了）</span></span><br><span class="line">                <span class="comment"># 当前覆盖最远距离达到数组末尾，不用再做ans++操作，直接结束</span></span><br><span class="line">                <span class="keyword">if</span> next_distance &gt;= len(nums) - <span class="number">1</span>:  </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h4><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p>示例 1，输入：points = [[10,16],[2,8],[1,6],[7,12]]，输出：2，解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</p>
<p>示例 2，输入：points = [[1,2],[3,4],[5,6],[7,8]]，输出：4</p>
<ul>
<li>局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。</li>
<li><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。那么按照气球起始位置排序，还是按照气球终止位置排序呢？其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</li>
<li><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071054281.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(points) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(points)):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]: <span class="comment"># 气球i和气球i-1不挨着，注意这里不是&gt;=</span></span><br><span class="line">                result += <span class="number">1</span>     </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                points[i][<span class="number">1</span>] = min(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]) <span class="comment"># 更新重叠气球最小右边界</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h4><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
<p>示例 1，输入: [ [1,2], [2,3], [3,4], [1,3] ]，输出: 1，解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p>示例 2，输入: [ [1,2], [1,2], [1,2] ]，输出: 2，解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p>示例 3，输入: [ [1,2], [2,3] ]，输出: 0，解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p>
<ul>
<li>这里也需要排序，<strong>是按照右边界排序，还是按照左边界排序呢？</strong>其实都可以。主要就是为了让区间尽可能的重叠。</li>
<li><strong>下面图片按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071108216.png" alt></p>
<p>区间，1，2，3，4，5，6都按照右边界排好序。当确定区间 1 和 区间2 重叠后，如何确定是否与 区间3 也重贴呢？就是取 区间1 和 区间2 右边界的最小值，因为这个最小值之前的部分一定是 区间1 和区间2 的重合部分，如果这个最小值也触达到区间3，那么说明 区间 1，2，3都是重合的。接下来就是找大于区间1结束位置的区间，是从区间4开始。<strong>那有同学问了为什么不从区间5开始？别忘了已经是按照右边界排序的了</strong>。区间4结束之后，再找到区间6，所以一共记录非交叉区间的个数是三个。总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">贪心 基于左边界</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 按照左边界升序排序</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 记录重叠区间数量</span></span><br><span class="line">        count = <span class="number">0</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(intervals)):</span><br><span class="line">        		<span class="comment"># 存在重叠区间</span></span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>]:  </span><br><span class="line">            		<span class="comment"># 更新重叠区间的右边界</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = min(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])  </span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">贪心 基于左边界 把452.用最少数量的箭引爆气球代码稍做修改</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 按照左边界升序排序</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])  </span><br><span class="line">        <span class="comment"># 不重叠区间数量，初始化为1，因为至少有一个不重叠的区间</span></span><br><span class="line">        result = <span class="number">1</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]:  </span><br><span class="line">              	<span class="comment"># 没有重叠</span></span><br><span class="line">                result += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">              	<span class="comment"># 重叠情况</span></span><br><span class="line">                <span class="comment"># 更新重叠区间的右边界</span></span><br><span class="line">                intervals[i][<span class="number">1</span>] = min(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])  </span><br><span class="line">        <span class="keyword">return</span> len(intervals) - result</span><br></pre></td></tr></table></figure>
<h4 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h4><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p>示例，输入：S = “ababcbacadefegdehijhklij”，输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。提示，S的长度在[1, 500]之间。S只包含小写字母 ‘a’ 到 ‘z’ 。</p>
<ul>
<li>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</li>
<li>可以分为如下两步：<ul>
<li>统计每一个字符最后出现的位置</li>
<li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071125308.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span><span class="params">(self, s: str)</span> -&gt; List[int]:</span></span><br><span class="line">        last_occurrence = &#123;&#125;  <span class="comment"># 存储每个字符最后出现的位置</span></span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            last_occurrence[ch] = i</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            end = max(end, last_occurrence[ch])  <span class="comment"># 找到当前字符出现的最远位置</span></span><br><span class="line">            <span class="keyword">if</span> i == end:  <span class="comment"># 如果当前位置是最远位置，表示可以分割出一个区间</span></span><br><span class="line">                result.append(end - start + <span class="number">1</span>)</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h4><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1，输入: intervals = [[1,3],[2,6],[8,10],[15,18]]，输出: [[1,6],[8,10],[15,18]]，解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>示例 2，输入: intervals = [[1,4],[4,5]]，输出: [[1,5]]，解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<ul>
<li>先排序，让所有的相邻区间尽可能的重叠在一起，按左边界，或者右边界排序都可以，处理逻辑稍有不同。按照左边界从小到大排序之后，如果 <code>intervals[i][0] &lt;= intervals[i - 1][1]</code> 即 intervals[i] 的左边界 &lt;= intervals[i - 1] 的右边界，则一定有重叠。（本题相邻区间也算重贴，所以是&lt;=）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071139659.png" alt></p>
<ul>
<li>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到 result 数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> len(intervals) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result  <span class="comment"># 区间集合为空直接返回</span></span><br><span class="line"></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])  <span class="comment"># 按照区间的左边界进行排序</span></span><br><span class="line"></span><br><span class="line">        result.append(intervals[<span class="number">0</span>])  <span class="comment"># 第一个区间可以直接放入结果集中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(intervals)):</span><br><span class="line">            <span class="comment"># 发现重叠区间</span></span><br><span class="line">            <span class="keyword">if</span> result[<span class="number">-1</span>][<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]:  </span><br><span class="line">                <span class="comment"># 合并区间，只需要更新结果集最后一个区间的右边界，因为根据排序，左边界已经是最小的</span></span><br><span class="line">                result[<span class="number">-1</span>][<span class="number">1</span>] = max(result[<span class="number">-1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(intervals[i])  <span class="comment"># 区间不重叠</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="有难度-其余问题"><a href="#有难度-其余问题" class="headerlink" title="有难度-其余问题"></a>有难度-其余问题</h3><h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例，输入: [-2,1,-3,4,-1,2,1,-5,4]，输出: 6，解释: 连续子数组  [4,-1,2,1] 的和最大，为  6</p>
<ul>
<li>如果 -2 1 在一起，计算起点的时候，一定是从 1 开始计算，因为负数只会拉低总和，这就是贪心贪的地方</li>
<li>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。全局最优：选取最大“连续和”。<strong>注意这里不是遇到负数就立刻丢弃，而是连续和为负数的时候，才从下一个元素重新计算。</strong></li>
<li><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</li>
<li>从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        result = float(<span class="string">'-inf'</span>)  <span class="comment"># 初始化结果为负无穷大</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            count += nums[i]</span><br><span class="line">            <span class="keyword">if</span> count &gt; result:  <span class="comment"># 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">                result = count</span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">0</span>:  <span class="comment"># 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h4><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p>说明:</p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p>示例 1，输入，gas = [1,2,3,4,5]，cost = [3,4,5,1,2]</p>
<p>输出: 3 解释:</p>
<ul>
<li>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</li>
<li>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</li>
<li>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</li>
<li>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</li>
<li>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</li>
<li>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</li>
<li>因此，3 可为起始索引。</li>
</ul>
<p><strong>方法1：</strong></p>
<p>直接从全局进行贪心选择，情况如下：</p>
<ul>
<li>情况一，如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li>
<li>情况二，rest[i] = gas[i]-cost[i] 为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</li>
<li>情况三，如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。</li>
</ul>
<p><strong>方法2：</strong></p>
<ul>
<li>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的</li>
<li>每个加油站的剩余量rest[i]为gas[i] - cost[i]。i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071205073.png" alt></p>
<ul>
<li><strong>局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置</strong></li>
</ul>
<p>方法1:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        curSum = <span class="number">0</span>  <span class="comment"># 当前累计的剩余油量</span></span><br><span class="line">        minFuel = float(<span class="string">'inf'</span>)  <span class="comment"># 从起点出发，油箱里的油量最小值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            rest = gas[i] - cost[i]</span><br><span class="line">            curSum += rest</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; minFuel:</span><br><span class="line">                minFuel = curSum</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> curSum &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 情况1：整个行程的总消耗大于总供给，无法完成一圈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> minFuel &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 情况2：从起点出发到任何一个加油站时油箱的剩余油量都不会小于0，可以从起点出发完成一圈</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            rest = gas[i] - cost[i]</span><br><span class="line">            minFuel += rest</span><br><span class="line">            <span class="keyword">if</span> minFuel &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 情况3：找到一个位置使得从该位置出发油箱的剩余油量不会小于0，返回该位置的索引</span></span><br><span class="line">                <span class="keyword">return</span> i  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 无法完成一圈</span></span><br></pre></td></tr></table></figure>
<p>方法2:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        curSum = <span class="number">0</span>  <span class="comment"># 当前累计的剩余油量</span></span><br><span class="line">        totalSum = <span class="number">0</span>  <span class="comment"># 总剩余油量</span></span><br><span class="line">        start = <span class="number">0</span>  <span class="comment"># 起始位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gas)):</span><br><span class="line">            curSum += gas[i] - cost[i]</span><br><span class="line">            totalSum += gas[i] - cost[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> curSum &lt; <span class="number">0</span>:  <span class="comment"># 当前累计剩余油量curSum小于0</span></span><br><span class="line">                start = i + <span class="number">1</span>  <span class="comment"># 起始位置更新为i+1</span></span><br><span class="line">                curSum = <span class="number">0</span>  <span class="comment"># curSum重新从0开始累计</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> totalSum &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 总剩余油量totalSum小于0，说明无法环绕一圈</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>
<h4 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h4><p>给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071452982.png" alt></p>
<p>输入：[0,0,null,0,0]，输出：1，解释：如图所示，一台摄像头足以监控所有节点</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071454720.png" alt></p>
<p>输入：[0,0,null,0,null,0,null,null,0]，输出：2，解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p>
<ul>
<li><strong>我们发现题目示例中的摄像头都没有放在叶子节点上！</strong></li>
<li>摄像头可以覆盖上中下三层，如果把摄像头放在叶子节点上，就浪费的一层的覆盖。所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</li>
<li>为什么不从头结点开始看起呢，为啥要从叶子节点看呢？因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。</li>
<li><strong>所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></li>
<li><p>此时这道题目还有两个难点，1. 二叉树的遍历，2. 如何隔两个节点放一个摄像头</p>
<ul>
<li>在二叉树中如何从低向上推导呢？可以使用后序遍历也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。</li>
<li>先来看看每个节点可能有几种状态，0：该节点无覆盖，1：本节点有摄像头，2：本节点有覆盖</li>
</ul>
</li>
<li><p><strong>因为在遍历树的过程中，就会遇到空节点，那么问题来了，空节点究竟是哪一种状态呢？ 空节点表示无覆盖？ 表示有摄像头？还是有覆盖呢？</strong>为了让摄像头数量最少，我们要尽量让叶子节点的父节点安装摄像头，这样才能摄像头的数量最少。那么空节点不能是无覆盖的状态，这样叶子节点就要放摄像头了，空节点也不能是有摄像头的状态，这样叶子节点的父节点就没有必要放摄像头了，而是可以把摄像头放在叶子节点的爷爷节点上。<strong>所以空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了</strong></p>
</li>
<li><p>看单层逻辑处理。主要有如下四类情况：</p>
<ul>
<li><p>情况1：左右节点都有覆盖。左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了</p>
<p><img src="https://raw.githubusercontent.com/rexyan/warehouse/master/202404071513532.png" alt></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>情况2：左右节点至少有一个无覆盖的情况，父节点就应该放摄像头</p>
</li>
<li><p>情况3：左右节点至少有一个有摄像头，那么其父节点就应该是2（覆盖的状态）</p>
</li>
<li><p>情况4：头结点没有覆盖，以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况，所以递归结束之后，还要判断根节点，如果没有覆盖，result++</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">         <span class="comment"># Greedy Algo:</span></span><br><span class="line">        <span class="comment"># 从下往上安装摄像头：跳过leaves这样安装数量最少，局部最优 -&gt; 全局最优</span></span><br><span class="line">        <span class="comment"># 先给leaves的父节点安装，然后每隔两层节点安装一个摄像头，直到Head</span></span><br><span class="line">        <span class="comment"># 0: 该节点未覆盖</span></span><br><span class="line">        <span class="comment"># 1: 该节点有摄像头</span></span><br><span class="line">        <span class="comment"># 2: 该节点有覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 定义递归函数</span></span><br><span class="line">        result = [<span class="number">0</span>]  <span class="comment"># 用于记录摄像头的安装数量</span></span><br><span class="line">        <span class="keyword">if</span> self.traversal(root, result) == <span class="number">0</span>:</span><br><span class="line">            result[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span><span class="params">(self, cur: TreeNode, result: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        left = self.traversal(cur.left, result)</span><br><span class="line">        right = self.traversal(cur.right, result)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况1: 左右节点都有覆盖</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">2</span> <span class="keyword">and</span> right == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2:</span></span><br><span class="line">        <span class="comment"># left == 0 &amp;&amp; right == 0 左右节点无覆盖</span></span><br><span class="line">        <span class="comment"># left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</span></span><br><span class="line">        <span class="comment"># left == 0 &amp;&amp; right == 1 左节点无覆盖，右节点有摄像头</span></span><br><span class="line">        <span class="comment"># left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</span></span><br><span class="line">        <span class="comment"># left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">            result[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况3:</span></span><br><span class="line">        <span class="comment"># left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</span></span><br><span class="line">        <span class="comment"># left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</span></span><br><span class="line">        <span class="comment"># left == 1 &amp;&amp; right == 1 左右节点都有摄像头</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">or</span> right == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/21/单调栈/" rel="prev" title="单调栈">
      <i class="fa fa-chevron-left"></i> 单调栈
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/06/FreeGPT35部署及使用/" rel="next" title="FreeGPT35部署及使用">
      FreeGPT35部署及使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单"><span class="nav-number">1.</span> <span class="nav-text">简单</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分发饼干"><span class="nav-number">1.1.</span> <span class="nav-text">分发饼干</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#K-次取反后最大化的数组和"><span class="nav-number">1.2.</span> <span class="nav-text">K 次取反后最大化的数组和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#柠檬水找零"><span class="nav-number">1.3.</span> <span class="nav-text">柠檬水找零</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中等-序列问题"><span class="nav-number">2.</span> <span class="nav-text">中等-序列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#摆动序列"><span class="nav-number">2.1.</span> <span class="nav-text">摆动序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单调递增的数字"><span class="nav-number">2.2.</span> <span class="nav-text">单调递增的数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中等-股票问题"><span class="nav-number">3.</span> <span class="nav-text">中等-股票问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#买卖股票最佳时机II"><span class="nav-number">3.1.</span> <span class="nav-text">买卖股票最佳时机II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有难度-区间问题"><span class="nav-number">4.</span> <span class="nav-text">有难度-区间问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#跳跃游戏"><span class="nav-number">4.1.</span> <span class="nav-text">跳跃游戏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跳跃游戏II"><span class="nav-number">4.2.</span> <span class="nav-text">跳跃游戏II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用最少数量的箭引爆气球"><span class="nav-number">4.3.</span> <span class="nav-text">用最少数量的箭引爆气球</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无重叠区间"><span class="nav-number">4.4.</span> <span class="nav-text">无重叠区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#划分字母区间"><span class="nav-number">4.5.</span> <span class="nav-text">划分字母区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并区间"><span class="nav-number">4.6.</span> <span class="nav-text">合并区间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有难度-其余问题"><span class="nav-number">5.</span> <span class="nav-text">有难度-其余问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最大子序和"><span class="nav-number">5.1.</span> <span class="nav-text">最大子序和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加油站"><span class="nav-number">5.2.</span> <span class="nav-text">加油站</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监控二叉树"><span class="nav-number">5.3.</span> <span class="nav-text">监控二叉树</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rex"
      src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
  <p class="site-author-name" itemprop="name">Rex</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">446</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa-hand-o-right"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rex</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
