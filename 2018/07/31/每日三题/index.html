<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rexyan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"top","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":false,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="数组及其相关202008252. 公平的糖果交换题目 1234567891011121314151617181920212223爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）返回一个整数数组 an">
<meta name="keywords" content="技术,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="每日三题">
<meta property="og:url" content="https://rexyan.github.io/2018/07/31/每日三题/index.html">
<meta property="og:site_name" content="星尘">
<meta property="og:description" content="数组及其相关202008252. 公平的糖果交换题目 1234567891011121314151617181920212223爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）返回一个整数数组 an">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png">
<meta property="og:updated_time" content="2025-10-31T03:20:39.409Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="每日三题">
<meta name="twitter:description" content="数组及其相关202008252. 公平的糖果交换题目 1234567891011121314151617181920212223爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）返回一个整数数组 an">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png">

<link rel="canonical" href="https://rexyan.github.io/2018/07/31/每日三题/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>每日三题 | 星尘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
  <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css" />
  <!-- 自定义为霞鹜文楷字体 -->
  <style>
	  body,div.post-body,h1,h2,h3,h4 {
		font-family: "LXGW WenKai Screen", sans-serif;
		font-size: 104%;
	  }
  </style>
  
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">星尘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-读书">

    <a href="/books/" rel="section"><i class="address-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-瞎扯">

    <a href="/crap/" rel="section"><i class="crap fa-fw"></i>瞎扯</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



<script src="https://cdn.jsdelivr.net/npm/echarts@4.8.0/dist/echarts.min.js"></script>

<meta name="referrer" content="never">




  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rexyan.github.io/2018/07/31/每日三题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
      <meta itemprop="name" content="Rex">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星尘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          每日三题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-31 20:39:57" itemprop="dateCreated datePublished" datetime="2018-07-31T20:39:57+00:00">2018-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-31 03:20:39" itemprop="dateModified" datetime="2025-10-31T03:20:39+00:00">2025-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="数组及其相关"><a href="#数组及其相关" class="headerlink" title="数组及其相关"></a>数组及其相关</h3><h4 id="20200825"><a href="#20200825" class="headerlink" title="20200825"></a>20200825</h4><h5 id="2-公平的糖果交换"><a href="#2-公平的糖果交换" class="headerlink" title="2. 公平的糖果交换"></a>2. <a href="https://leetcode-cn.com/problems/fair-candy-swap/" target="_blank" rel="noopener">公平的糖果交换</a></h5><p>题目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。</span><br><span class="line"></span><br><span class="line">因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</span><br><span class="line"></span><br><span class="line">返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。</span><br><span class="line"></span><br><span class="line">如果有多个答案，你可以返回其中任何一个。保证答案存在。</span><br><span class="line"></span><br><span class="line"> 示例 1：</span><br><span class="line">输入：A = [1,1], B = [2,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：A = [1,2], B = [2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：A = [2], B = [1,3]</span><br><span class="line">输出：[2,3]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：A = [1,2,5], B = [2,4]</span><br><span class="line">输出：[5,4]</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/fair-candy-swap/solution/gong-ping-de-tang-guo-jiao-huan-by-leetcode/" target="_blank" rel="noopener">官方思路</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fairCandySwap</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        Sa, Sb = sum(A), sum(B)</span><br><span class="line">        setB = set(B)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> x + (Sb - Sa) / <span class="number">2</span> <span class="keyword">in</span> setB:</span><br><span class="line">                <span class="keyword">return</span> [x, x + (Sb - Sa) / <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.fairCandySwap([<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]))</span><br><span class="line">    print(s.fairCandySwap([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">    print(s.fairCandySwap([<span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>]))</span><br><span class="line">    print(s.fairCandySwap([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure>
<h5 id="3-在排序数组中查找元素的第一个和最后一个位置"><a href="#3-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="3. 在排序数组中查找元素的第一个和最后一个位置"></a>3. <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></h5><p>题目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>
<p>思路是我们对 nums 数组从左到右做线性遍历，当遇到 target 时中止。如果我们没有中止过，那么 target 不存在，我们可以返回“错误代码” [-1, -1] 。如果我们找到了有效的左端点坐标，我们可以坐第二遍线性扫描，但这次从右往左进行。这一次，第一个遇到的 target 将是最右边的一个（因为最左边的一个存在，所以一定会有一个最右边的 target）。我们接下来只需要返回这两个坐标。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># 从左往右查找该元素，找不到则返回 [-1, -1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == target:</span><br><span class="line">                left_idx = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 从右往左查找元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[j] == target:</span><br><span class="line">                right_idx = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> [left_idx, right_idx]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.searchRange([<span class="number">1</span>, <span class="number">0</span>], <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>二分法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extreme_insertion_index</span><span class="params">(self, nums, target, left)</span>:</span></span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target <span class="keyword">or</span> (left <span class="keyword">and</span> target == nums[mid]):</span><br><span class="line">                hi = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        left_idx = self.extreme_insertion_index(nums, target, <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> left_idx == len(nums) <span class="keyword">or</span> nums[left_idx] != target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [left_idx, self.extreme_insertion_index(nums, target, <span class="literal">False</span>)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="20200831"><a href="#20200831" class="headerlink" title="20200831"></a>20200831</h4><h5 id="1-旋转数组的最小数字"><a href="#1-旋转数组的最小数字" class="headerlink" title="1. 旋转数组的最小数字"></a>1. <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></h5><p>题目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>旋转数组，就是将一个有序的数组的尾部一部分挪到数组的前面，暴力法：从下标为 0 的元素开始遍历，每次都进行比较，如果当前元素比相邻的下一个元素大，那么就说明下一个元素就是最小值，有一种特殊情况是当数组所有元素都相同时，那么是不会出现上面的这种情况的，那么随便一个元素都是最小值，即取第0个元素即可。</p>
<p>二分法：low 指向数组的第一个元素，high 指向最后一个元素，pivot 为中间元素。因为数组在没有旋转之前是有序的，所以当中间元素 pivot  比右边元素 high 小的时候，说明最小元素在 pivot  或者 pivot  的左边，此时需要移动右指针到 pivot 的位置</p>
<p>当中间元素 pivot 比右边元素 high 大的时候说明最小元素在 pivot 的右边，此时需要移动左指针到 pivot + 1的位置</p>
<p>如果当中间元素 pivot 等于右边元素 high 的时候，那么说明无法判断，这时可以将中间元素往后移动一个位置，然后再次判断，直到左指针等于右指针时，说明找到了最小的元素。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers: List[int])</span> -&gt; int:</span></span><br><span class="line">        low, high = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            pivot = low + (high - low) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[pivot] &lt; numbers[high]:</span><br><span class="line">                high = pivot </span><br><span class="line">            <span class="keyword">elif</span> numbers[pivot] &gt; numbers[high]:</span><br><span class="line">                low = pivot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[low]</span><br></pre></td></tr></table></figure>
<h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><h5 id="1-最小栈"><a href="#1-最小栈" class="headerlink" title="1. 最小栈"></a>1. <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">最小栈</a></h5><p>题目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</span><br><span class="line"></span><br><span class="line">push(x) —— 将元素 x 推入栈中。</span><br><span class="line">pop() —— 删除栈顶的元素。</span><br><span class="line">top() —— 获取栈顶元素。</span><br><span class="line">getMin() —— 检索栈中的最小元素。</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回  0</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []  // 定义一个栈</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack: // 如果栈为空，那么入栈第一个元素，并且将第一个元素作为最</span><br><span class="line">            self.stack.append((x, x))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.append((x, min(x, self.stack[<span class="number">-1</span>][<span class="number">1</span>])))</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">obj = MinStack()</span><br><span class="line">obj.push(<span class="number">1</span>)</span><br><span class="line">obj.push(<span class="number">-1</span>)</span><br><span class="line">obj.push(<span class="number">9</span>)</span><br><span class="line">obj.push(<span class="number">10</span>)</span><br><span class="line">obj.push(<span class="number">4</span>)</span><br><span class="line">a = obj.pop()</span><br><span class="line">param_3 = obj.top()</span><br><span class="line">param_4 = obj.getMin()</span><br></pre></td></tr></table></figure>
<h5 id="2-用两个栈实现队列"><a href="#2-用两个栈实现队列" class="headerlink" title="2. 用两个栈实现队列"></a>2. <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></h5><p>题目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 设定两个栈，一个负责入，一个负责出</span></span><br><span class="line">        self.in_stack = []</span><br><span class="line">        self.out_stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.in_stack.append(value)  <span class="comment"># 添加元素</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.out_stack:  <span class="comment"># 如果 out_stack 有元素，直接弹出即可</span></span><br><span class="line">            <span class="keyword">return</span> self.out_stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.in_stack:  <span class="comment"># 如果out_stack 和 in_stack 都没有元素，那么返回 -1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将 in_stack 中元素一个个的 pop 到 out_stack 中去，到达 out_stack 是反序</span></span><br><span class="line">                <span class="comment"># 例如 in_stack 中元素为 [1,3,5], 那么 out_stack 中元素为 [5,3,1]</span></span><br><span class="line">                <span class="keyword">while</span>(self.in_stack):</span><br><span class="line">                    self.out_stack.append(self.in_stack.pop())</span><br><span class="line">                <span class="comment"># 弹出 out_stack 中的元素，所以 deleteHead 的顺序就是 appendTail 的顺序</span></span><br><span class="line">                <span class="keyword">return</span> self.out_stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = CQueue()</span><br><span class="line">    print(c.appendTail(<span class="number">1</span>))  <span class="comment"># 1</span></span><br><span class="line">    print(c.appendTail(<span class="number">3</span>))  <span class="comment"># 2</span></span><br><span class="line">    print(c.appendTail(<span class="number">5</span>))  <span class="comment"># 3</span></span><br><span class="line">    print(c.deleteHead())  <span class="comment"># 1</span></span><br><span class="line">    print(c.deleteHead())  <span class="comment"># 3</span></span><br><span class="line">    print(c.deleteHead())  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h5 id="3-用两个队列实现栈"><a href="#3-用两个队列实现栈" class="headerlink" title="3. 用两个队列实现栈"></a>3. 用两个队列实现栈</h5><p><a href="https://blog.csdn.net/ailunlee/article/details/85100514" target="_blank" rel="noopener">https://blog.csdn.net/ailunlee/article/details/85100514</a> </p>
<h5 id="4-有效的括号"><a href="#4-有效的括号" class="headerlink" title="4. 有效的括号"></a>4. <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 &apos;(&apos;，&apos;)&apos;，&apos;&#123;&apos;，&apos;&#125;&apos;，&apos;[&apos;，&apos;]&apos; 的字符串，判断字符串是否有效。</span><br><span class="line">有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>利用栈实现，例如要判断的字符串为 <code>{[()]}{}</code> 那么将相反元素入栈，直到栈顶的元素和下一个要判断的元素相同时，那么就进行出栈，如出栈元素和要对比的字符串不一样，那么还是入栈，最后判断栈的大小，栈如果为空，那么就说明全部匹配，否则说明又元素没有匹配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) % <span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 判断为奇数长度直接 False</span></span><br><span class="line"></span><br><span class="line">        stack = []  <span class="comment"># 定义一个栈</span></span><br><span class="line">        tmp_map = &#123;<span class="string">"["</span>: <span class="string">"]"</span>,<span class="string">"&#123;"</span>:<span class="string">"&#125;"</span>,<span class="string">"("</span>:<span class="string">")"</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 栈中没有元素就添加，且判断下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                stack.append(tmp_map.get(x))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果元素相等，那么就弹出栈中元素</span></span><br><span class="line">            <span class="keyword">if</span> x == stack[<span class="number">-1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 元素不相等，那么就添加元素</span></span><br><span class="line">                stack.append(tmp_map.get(x))</span><br><span class="line">        <span class="comment"># 最后栈中还有数据，那么就说明还有没有匹配到的元数</span></span><br><span class="line">        <span class="keyword">if</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = Solution()</span><br><span class="line">    print(c.isValid(<span class="string">"&#123;&#125;&#123;[]()))&#125;"</span>))</span><br></pre></td></tr></table></figure>
<p>上面解法判断有问题，可参考<a href="https://leetcode-cn.com/problems/valid-parentheses/solution/20-you-xiao-de-gua-hao-xiang-qing-chu-san-chong-qi/" target="_blank" rel="noopener">图解</a></p>
<h5 id="5-删除字符串中的所有相邻重复项"><a href="#5-删除字符串中的所有相邻重复项" class="headerlink" title="5. 删除字符串中的所有相邻重复项"></a>5. <a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">删除字符串中的所有相邻重复项</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</span><br><span class="line"></span><br><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>
<p>此题也是利用栈来实现，循环字符串，如果栈为空，那么就入栈，否则判断栈顶的元素是否和当前元素相等，如果相等那么就出栈，否则就入栈，最后栈中的剩余元素就是剩下的不相邻的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, s: str)</span>:</span></span><br><span class="line">        stack = []  <span class="comment"># 定义一个栈</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 栈为空，那么就入栈</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                stack.append(x)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果当前元素等于栈中最后一个元素，那么就出栈</span></span><br><span class="line">            <span class="keyword">if</span> stack[<span class="number">-1</span>] == x:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则入栈</span></span><br><span class="line">                stack.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = Solution()</span><br><span class="line">    print(c.removeDuplicates(<span class="string">"abbaca"</span>))  <span class="comment"># ca</span></span><br></pre></td></tr></table></figure></p>
<h5 id="6-柱状图中最大的矩形"><a href="#6-柱状图中最大的矩形" class="headerlink" title="6. 柱状图中最大的矩形"></a>6. <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">柱状图中最大的矩形</a></h5><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">图解地址</a></p>
<p>方法1: 暴力法</p>
<p>方法2: 使用栈</p>
<h5 id="7-滑动窗口最大值"><a href="#7-滑动窗口最大值" class="headerlink" title="7. 滑动窗口最大值"></a>7. <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进阶：你能在线性时间复杂度内解决此题吗？</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<p>方法1: 暴力法。每次都求窗口的中的最大值即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, k: <span class="string">'int'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n * k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [max(nums[i:i + k]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<p>方法2: 双端队列。<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/shi-pin-jie-xi-shuang-duan-dui-lie-hua-dong-chuang/" target="_blank" rel="noopener">图解地址</a>。<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/" target="_blank" rel="noopener">步骤细节</a></p>
<h5 id="8-设计循环队列"><a href="#8-设计循环队列" class="headerlink" title="8. 设计循环队列"></a>8. <a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">设计循环队列</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</span><br><span class="line"></span><br><span class="line">循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</span><br><span class="line"></span><br><span class="line">你的实现应该支持如下操作：</span><br><span class="line"></span><br><span class="line">MyCircularQueue(k): 构造器，设置队列长度为 k 。</span><br><span class="line">Front: 从队首获取元素。如果队列为空，返回 -1 。</span><br><span class="line">Rear: 获取队尾元素。如果队列为空，返回 -1 。</span><br><span class="line">enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</span><br><span class="line">deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</span><br><span class="line">isEmpty(): 检查循环队列是否为空。</span><br><span class="line">isFull(): 检查循环队列是否已满。</span><br></pre></td></tr></table></figure>
<p>方法1: 使用数组 + 双指针。<a href="https://leetcode-cn.com/problems/design-circular-queue/solution/shu-zu-shi-xian-de-xun-huan-dui-lie-by-liweiwei141/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int)</span>:</span></span><br><span class="line">        self.front = <span class="number">0</span></span><br><span class="line">        self.rear = <span class="number">0</span></span><br><span class="line">        self.capacity = k + <span class="number">1</span></span><br><span class="line">        self.arr = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.capacity)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enQueue</span><span class="params">(self, value: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        插入元素。rear 指针往后移动</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.arr[self.rear] = value</span><br><span class="line">        self.rear = (self.rear + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deQueue</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        删除元素。front 指针往后移动</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.front = (self.front + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Front</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取队首元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.arr[self.front]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Rear</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取队尾元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.arr[(self.rear - <span class="number">1</span> + self.capacity) % self.capacity]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        当 rear == front 时，认为队列是空的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.front == self.rear</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        当 rear 在 front 后面一个位置的时候就认为满了。当 rear == front 时，认为队列是空的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear + <span class="number">1</span>) % self.capacity == self.front</span><br></pre></td></tr></table></figure>
<h5 id="9-设计循环双端队列"><a href="#9-设计循环双端队列" class="headerlink" title="9. 设计循环双端队列"></a>9. <a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">设计循环双端队列</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">设计实现双端队列。</span><br><span class="line">你的实现需要支持以下操作：</span><br><span class="line"></span><br><span class="line">MyCircularDeque(k)：构造函数,双端队列的大小为k。</span><br><span class="line">insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</span><br><span class="line">insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</span><br><span class="line">deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</span><br><span class="line">deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</span><br><span class="line">getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</span><br><span class="line">getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</span><br><span class="line">isEmpty()：检查双端队列是否为空。</span><br><span class="line">isFull()：检查双端队列是否满了。</span><br></pre></td></tr></table></figure>
<p>方法1: 数组 + 双指针。和上面类似。<a href="https://leetcode-cn.com/problems/design-circular-deque/solution/shu-zu-shi-xian-de-xun-huan-shuang-duan-dui-lie-by/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int)</span>:</span></span><br><span class="line">        self.front = <span class="number">0</span></span><br><span class="line">        self.rear = <span class="number">0</span></span><br><span class="line">        self.capacity = k + <span class="number">1</span></span><br><span class="line">        self.arr = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.capacity)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertFront</span><span class="params">(self, value: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        插入元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.front = (self.front - <span class="number">1</span> + self.capacity) % self.capacity</span><br><span class="line">        self.arr[self.front] = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertLast</span><span class="params">(self, value: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在后面插入元素，rear 指针后移</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isFull():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.arr[self.rear] = value</span><br><span class="line">        self.rear = (self.rear + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteFront</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        删除前面元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.front = (self.front + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteLast</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        删除后面元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.rear = (self.rear - <span class="number">1</span> + self.capacity) % self.capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFront</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取头元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.arr[self.front]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRear</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取尾元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.arr[(self.rear - <span class="number">1</span> + self.capacity) % self.capacity]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        当 rear == front 时，认为队列是空的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.front == self.rear</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        当 rear 在 front 后面一个位置的时候就认为满了。当 rear == front 时，认为队列是空的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear + <span class="number">1</span>) % self.capacity == self.front</span><br></pre></td></tr></table></figure>
<h5 id="10-接雨水"><a href="#10-接雨水" class="headerlink" title="10. 接雨水"></a>10. <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></h5><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<p>不会，太难</p>
<h4 id="数组，哈希表"><a href="#数组，哈希表" class="headerlink" title="数组，哈希表"></a>数组，哈希表</h4><h5 id="1-搜索插入位置"><a href="#1-搜索插入位置" class="headerlink" title="1. 搜索插入位置"></a>1. <a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p>此题可以用二分法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        size = len(nums)</span><br><span class="line">        <span class="comment"># 如果数组的长度为0，那么说明一个元素都没有，那么该元素插入位置为 0</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前数组中最后一个元素都小于 target，那么该元素插入位置为最后一个，即数组的长度</span></span><br><span class="line">        <span class="keyword">if</span> nums[size - <span class="number">1</span>] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> size</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, size - <span class="number">1</span>  <span class="comment"># 左右指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># left + right 在 Python 中如果发生整型溢出，Python 会自动转成长整形</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 严格小于 target 的元素一定不是解</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                <span class="comment"># 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 下一轮搜索区间是 [left, mid]</span></span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = Solution()</span><br><span class="line">    print(c.searchInsert([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h5 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2. 移除元素"></a>2. <a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>使用双指针法。慢指针，用于记录有多少不同的元素，如果当前元素的值不等于目标值，那么快慢指针一起向下移动，否则快指针移动，慢指针不移动。快指针移动到元素末尾就结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        j = <span class="number">0</span>  <span class="comment"># 慢指针，用于记录有多少不同的元素</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="comment"># 如果当前元素的值不等于目标值，那么快慢指针一起向下移动</span></span><br><span class="line">            <span class="comment"># 否则快指针 i 移动，慢指针不移动。快指针移动到元素末尾就结束</span></span><br><span class="line">            <span class="keyword">if</span> x != target:  <span class="comment"># 如果不相等，那么不相等的元素往前移动</span></span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        print(nums)</span><br><span class="line">        <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = Solution()</span><br><span class="line">    print(c.removeElement([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>], <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h5 id="3-删除排序数组中的重复项"><a href="#3-删除排序数组中的重复项" class="headerlink" title="3. 删除排序数组中的重复项"></a>3. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>这道题也使用双指针法，和上面类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        j = <span class="number">0</span>  <span class="comment"># 慢指针，用于记录有多少不同的元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="comment"># 快指针从1开始，如果快慢指针的值相等，那么快指针加一（寻找不相等的值）</span></span><br><span class="line">            <span class="comment"># 否则快慢指针的值不相等，那么将不重复的值放在慢指针 j+1 的位置上实现前移</span></span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                print(nums)</span><br><span class="line"></span><br><span class="line">        print(nums)</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = Solution()</span><br><span class="line">    print(c.removeElement([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure>
<h5 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">最长不含重复字符的子字符串</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<p>方法1：滑动窗口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        head = <span class="number">0</span>  <span class="comment"># 窗口左边界</span></span><br><span class="line">        tail = <span class="number">0</span>  <span class="comment"># 窗口右边界</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>: <span class="keyword">return</span> len(s) <span class="comment"># 边界条件</span></span><br><span class="line">        res = <span class="number">1</span>  <span class="comment"># 起始窗口大小为 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> tail &lt; len(s) - <span class="number">1</span>:  <span class="comment"># 如果右窗口位置没有到达最后</span></span><br><span class="line">            tail += <span class="number">1</span>  <span class="comment"># 扩大右窗口位置</span></span><br><span class="line">            <span class="keyword">if</span> s[tail] <span class="keyword">not</span> <span class="keyword">in</span> s[head: tail]:  <span class="comment"># 如果新加入的元素没有在以前的窗口中</span></span><br><span class="line">                res = max(tail - head + <span class="number">1</span>, res)  <span class="comment"># 那么就对比以前的大小和当前窗口的大小，取最大值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> s[tail] <span class="keyword">in</span> s[head: tail]:  <span class="comment"># 如果新加入的元素在窗口中，那么就缩小窗口，直到不在为止</span></span><br><span class="line">                    head += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5 id="4-长度最小的子数组"><a href="#4-长度最小的子数组" class="headerlink" title="4. 长度最小的子数组"></a>4. <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</span><br><span class="line"></span><br><span class="line">示例：输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p>这题其实也是双指针的解法，这种解法或者可以称为滑动窗口，两个指针的启示位置分别是 0 和 1，如果两指针之间的值的和加起来不大于目标值，那么就移动前面的指针前移（扩大范围），如果如果两指针之间的值的和加起来大于目标值，那么就移动后面的指针（让其缩小范围）</p>
<h5 id="5-螺旋矩阵-II"><a href="#5-螺旋矩阵-II" class="headerlink" title="5. 螺旋矩阵 II"></a>5. <a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">螺旋矩阵 II</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数 n，生成一个包含 1 到 n 的平方的所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</span><br><span class="line"></span><br><span class="line">示例：n = 3时，矩阵如下</span><br><span class="line">|1 2 3|</span><br><span class="line">|8 9 4|</span><br><span class="line">|7 6 5|</span><br></pre></td></tr></table></figure>
<p>思路是定义一个矩阵（二维数组），大小为 <code>n*n</code>，依次从左往右（上边届不变，遍历完成后上边界 + 1），从上到下（右边届不变，遍历完成后右边界 - 1），然后从右往左（下边界不变，遍历完成后下边界 - 1），从下到上遍历（左边界不变，遍历完成后左边界 + 1），直到填充的元素大小大于或者等于 <code>n*n</code> 时，那么就停止循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; [[int]]:</span></span><br><span class="line">        l, r, t, b = <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        mat = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        num, tar = <span class="number">1</span>, n * n</span><br><span class="line">        <span class="keyword">while</span> num &lt;= tar:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>): <span class="comment"># left to right</span></span><br><span class="line">                mat[t][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            t += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(t, b + <span class="number">1</span>): <span class="comment"># top to bottom</span></span><br><span class="line">                mat[i][r] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(r, l - <span class="number">1</span>, <span class="number">-1</span>): <span class="comment"># right to left</span></span><br><span class="line">                mat[b][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(b, t - <span class="number">1</span>, <span class="number">-1</span>): <span class="comment"># bottom to top</span></span><br><span class="line">                mat[i][l] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
<h5 id="6-两数之和"><a href="#6-两数之和" class="headerlink" title="6. 两数之和"></a>6. <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<p>方法1: 暴力枚举。最容易想到的方法是枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<p>方法2: 哈希表。创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        hashtable = dict()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]  <span class="comment"># hashtable[target - num] 获取的是下标</span></span><br><span class="line">            hashtable[nums[i]] = i <span class="comment"># key 为元素的值，value 为元素的下标</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h5 id="7-三数之和"><a href="#7-三数之和" class="headerlink" title="7. 三数之和"></a>7. 三数之和</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</span><br><span class="line"></span><br><span class="line">示例：给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法：先排序，然后使用双指针。<a href="https://leetcode-cn.com/problems/3sum/solution/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/" target="_blank" rel="noopener">图解地址</a></p>
<h5 id="8-盛最多水的容器"><a href="#8-盛最多水的容器" class="headerlink" title="8. 盛最多水的容器"></a>8. <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></h5><p>解题思路是，使用两个指针即双指针法，分别位于输入数组的第一个元素和最后一个元素。比较两个元素的大小，小的一个进行移动，直到两个元素相遇，每移动一次计算一次面积，最后取出最大的面积即可。</p>
<p>核心思想就是矮柱子选取后如果移动高柱子的话面积是一定会减小的，因为长度距离在变小的时候，此时高度只能小于或等于矮的柱子（木桶原理，盛多少水取决于最矮的柱子）。因此只能移动矮的柱子这边才有可能使得高度比矮柱子大。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(height) - <span class="number">1</span>  <span class="comment"># i 是第一根柱子，j 是最后一根</span></span><br><span class="line">        max_area = <span class="number">0</span>  <span class="comment"># 最大面积初始值为 0 </span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:  <span class="comment"># 循坏条件是两根柱子没有移动到一起</span></span><br><span class="line">            <span class="keyword">if</span> height[i] &lt;= height[j]:  <span class="comment"># 当左柱子的值小于右柱子时</span></span><br><span class="line">                min_height = height[i]  <span class="comment"># 面积的大小取决于当前最小的柱子</span></span><br><span class="line">                i = i + <span class="number">1</span>  <span class="comment"># 左柱子往右移动</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 否则左柱子的值大于右柱子，需要将右柱子往左移动</span></span><br><span class="line">                min_height = height[j]</span><br><span class="line">                j = j - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            area = (j - i + <span class="number">1</span>) * min_height  <span class="comment"># 计算面积，面积等于最低的柱子 * 两个柱子之间的长度</span></span><br><span class="line">            max_area = max(area, max_area)  <span class="comment"># 取最大的面积</span></span><br><span class="line">        <span class="keyword">return</span> max_area  <span class="comment"># 返回最终的最大面积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.maxArea([<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]))</span><br></pre></td></tr></table></figure>
<p>笨方法就是遍历，计算出所有柱子的所有组合的面积，然后返回最大的，但是这样时间复杂度就是O(n^2) </p>
<h5 id="9-移动零"><a href="#9-移动零" class="headerlink" title="9. 移动零"></a>9. <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br><span class="line"></span><br><span class="line">说明:必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。</span><br></pre></td></tr></table></figure>
<p>方法：使用一个指针记录第一个 0 所在的位置，然后让后面非0元素与其交换即可。<a href="https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/" target="_blank" rel="noopener">图解地址</a></p>
<h5 id="10-爬楼梯"><a href="#10-爬楼梯" class="headerlink" title="10. 爬楼梯"></a>10. <a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><br><span class="line"></span><br><span class="line">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line"></span><br><span class="line">注意：给定 n 是一个正整数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<p>方法：可以使用递归或者动态规划。动态规划在这里就是斐波那契数列，即 dp[i] = dp[i-2] + dp[i-1]。<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/cong-zhi-jue-si-wei-fen-xi-dong-tai-gui-hua-si-lu-/" target="_blank" rel="noopener">图解地址</a>。<a href="https://leetcode-cn.com/problems/climbing-stairs/solution/70zhong-quan-chu-ji-python3hui-ji-liao-ti-jie-qu-w/" target="_blank" rel="noopener">图解地址2</a></p>
<p>递归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(100)  # 缓存装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>) + self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<p>斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span> <span class="keyword">or</span> n==<span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h5 id="11-合并两个有序数组"><a href="#11-合并两个有序数组" class="headerlink" title="11. 合并两个有序数组"></a>11. <a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</span><br><span class="line"></span><br><span class="line">说明：初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br><span class="line"> </span><br><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetcode/" target="_blank" rel="noopener">图解地址</a></p>
<p>方法1: 合并后排序</p>
<p>方法2: 双指针 / 从前往后。这种解法类似于合并两个有序的链表。两个指针分别位于两个数组的头部，每次比较最小的，并且将最小的插入到目标数组中，然后比较小的值的指针后移。</p>
<p>方法3：双指针 / 从后往前。此解法很精妙，可以参考图解地址。和上面正好相反，两个指针分别位于两个数组的尾部，每次比较最大的，并且将并且将最大的插入到目标数组中，然后比较大的值的指针前移。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        p1 = m - <span class="number">1</span></span><br><span class="line">        p2 = n - <span class="number">1</span></span><br><span class="line">        p = m + n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]: <span class="comment"># 判断两个指针中哪个元素的值大，哪个大就将哪个放入到最大的位置</span></span><br><span class="line">                nums1[p] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span>  <span class="comment"># 指针前移</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p] =  nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span>  <span class="comment"># 指针前移</span></span><br><span class="line">            p -= <span class="number">1</span>  <span class="comment"># 要插入值的位置前移</span></span><br><span class="line">        </span><br><span class="line">        nums1[:p2 + <span class="number">1</span>] = nums2[:p2 + <span class="number">1</span>]  <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h5 id="12-加一"><a href="#12-加一" class="headerlink" title="12. 加一"></a>12. <a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">加一</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>
<p>方法1: <a href="https://leetcode-cn.com/problems/plus-one/solution/hua-jie-suan-fa-66-jia-yi-by-guanpengchn/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        length = len(digits) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 处理了 499，123 这两种情况</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(length + <span class="number">1</span>):</span><br><span class="line">            digits[length - x] += <span class="number">1</span></span><br><span class="line">            digits[length - x] %= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> digits[length - x] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">        <span class="comment"># 处理 999 这种情况</span></span><br><span class="line">        digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = Solution()</span><br><span class="line">    print(c.plusOne([<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]))</span><br></pre></td></tr></table></figure>
<h5 id="13-有效的字母异位词"><a href="#13-有效的字母异位词" class="headerlink" title="13. 有效的字母异位词"></a>13. <a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词(字母一样，顺序不一样，字母可以重复)。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br><span class="line">说明:</span><br><span class="line">你可以假设字符串只包含小写字母。</span><br></pre></td></tr></table></figure>
<p>方法1: 排序。排序后比较是否相同，相同即满足条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) != len(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> sorted(s) != sorted(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>方法2: 使用哈希表。出现该字母，次数就加一，遍历另一个的是就减一，如果最后不等于0，那么就说明步满足条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) != len(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">          </span><br><span class="line">        dicts = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            dicts[s[i]] = dicts[s[i]] + <span class="number">1</span></span><br><span class="line">            dicts[t[i]] = dicts[t[i]] - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> dicts.values():</span><br><span class="line">            <span class="keyword">if</span> val != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h5 id="14-字母异位词分组"><a href="#14-字母异位词分组" class="headerlink" title="14. 字母异位词分组"></a>14. <a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法1: 排序数组分类。当且仅当它们的排序字符串相等时，两个字符串是字母异位词。<a href="https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        ans = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            ans[tuple(sorted(s))].append(s) <span class="comment"># 排序，相同的放在字典同一个 key 中</span></span><br><span class="line">        <span class="keyword">return</span> ans.values()</span><br></pre></td></tr></table></figure>
<p>方法2: 统计单词中字母出现次数，如果次数一样，那么就将他们进行分组。<a href="https://leetcode-cn.com/problems/group-anagrams/solution/zi-mu-yi-wei-ci-fen-zu-by-leetcode/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(strs)</span>:</span></span><br><span class="line">        ans = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            count = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                count[ord(c) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">            ans[tuple(count)].append(s)</span><br><span class="line">        <span class="keyword">return</span> ans.values()</span><br></pre></td></tr></table></figure>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h5 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h5><h6 id="1-合并两个有序链表"><a href="#1-合并两个有序链表" class="headerlink" title="1. 合并两个有序链表"></a>1. <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p>方法1：递归。定义两个链表 l1 和 l2，如果 <code>l1</code> 或者 <code>l2</code> 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 <code>l1</code> 和 <code>l2</code> 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="comment"># l1 小于 l2</span></span><br><span class="line">        <span class="keyword">elif</span> l1.value &lt; l2.value:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="comment"># l2 大于 l1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>
<p>方法2:  迭代。可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/" target="_blank" rel="noopener">图解地址</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        prehead = ListNode(<span class="number">-1</span>)  <span class="comment"># 声明一个临时节点</span></span><br><span class="line"></span><br><span class="line">        prev = prehead  <span class="comment"># 当前迭代位置的指针</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.value &lt; l2.value:  <span class="comment"># l1 中的元素比 l2 中的小</span></span><br><span class="line">                prev.next = l1  <span class="comment"># 将当前小元素 l1 加入 prev 中</span></span><br><span class="line">                l1 = l1.next  <span class="comment"># l1 往下移动一步</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.next = l2  <span class="comment"># 将当前小元素 l2 加入 prev 中</span></span><br><span class="line">                l2 = l2.next  <span class="comment"># l2 往下移动一步</span></span><br><span class="line">            prev = prev.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># l1 或者 l2 有一个链表为空了，将另一个不为空的链表直接接在后面</span></span><br><span class="line">        prev.next = l2 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> l1</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回最前面临时节点的下一个元素，也就是链表的第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> prehead.next</span><br></pre></td></tr></table></figure>
<h6 id="2-删除排序链表中的重复元素"><a href="#2-删除排序链表中的重复元素" class="headerlink" title="2. 删除排序链表中的重复元素"></a>2. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>
<p>方法1：借助字典，遍历链表存取已经存在的元素，如果之前已经存在，那么就指针直接跳过该元素。</p>
<p>方法2：依次遍历每个元素，对比当前元素和当前元素的下一个元素是否相同，如果相同，那么就使当前元素指向下一个元素的下一个元素。以此来跳过相同的元素。</p>
<p>方法3：双指针。定一个一个临时节点，指针 A 指向临时节点，指针 B 指向临时节点的下一个节点（链表真正的第一个节点），如果 A.value != B.value 那么两者同时往前移动，如果两者相等，那么说明有重复的元素，那么可以将 A 指针停住，B 指针继续往前走，然后继续判断  A.value 和 B.value 的值是否相等。直到两者不相等，那么就 A .next 指向 B，直 B 走到链表末尾。</p>
<h6 id="3-环形链表"><a href="#3-环形链表" class="headerlink" title="3. 环形链表"></a>3. <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，判断链表中是否有环。</span><br></pre></td></tr></table></figure>
<p>方法1: 借助字典或者 set，遍历链表存取已经存在的元素，如果之前已经存在，那么就说明有环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        seen = set()  </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            seen.add(head)</span><br><span class="line">            head = head.next  <span class="comment"># 指针下移</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>方法2: 使用快慢指针。定义两个指针，慢指针每次移动一步，快指针每次移动两步，如果两个指针相遇，那么就说明有环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="comment"># 如果无头元素或者链表只有一个元素，那么直接判断为无环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head  <span class="comment"># 慢指针</span></span><br><span class="line">        fast = head.next  <span class="comment"># 快指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:  <span class="comment"># 如果慢指针不等于快指针</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.next:  <span class="comment"># 快指针结束了都没有和慢指针重合，那么就是无环了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.next  <span class="comment"># 慢指针每次下移一次</span></span><br><span class="line">            fast = fast.next.next  <span class="comment"># 快指针每次下移两次</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/" target="_blank" rel="noopener">图解地址</a></p>
<h6 id="4-相交链表"><a href="#4-相交链表" class="headerlink" title="4. 相交链表"></a>4. <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写一个程序，找到两个单链表相交的起始节点</span><br></pre></td></tr></table></figure>
<p>方法：双指针法。分别为链表A和链表B设置指针A和指针B，然后开始遍历链表，如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历，直至两个指针相遇。<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/jiao-ni-yong-lang-man-de-fang-shi-zhao-dao-liang-2/" target="_blank" rel="noopener">图解地址</a></p>
<p>如下代码所示，值得注意的是 ，无论是相交还是不相交，对于无环的链表来说，都一定会相遇，因此不会死循环。（要么在某个点相遇，要么在 null 的时候相遇）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pa, pb = headA, headB</span><br><span class="line">        <span class="keyword">while</span> pa != pb:</span><br><span class="line">            pa = pa.next <span class="keyword">if</span> pa <span class="keyword">else</span> headB</span><br><span class="line">            pb = pb.next <span class="keyword">if</span> pb <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> pa</span><br></pre></td></tr></table></figure>
<p>方法2：存链表节点进行查询。遍历链表A，并将其节点存入集合，遍历B的每个节点并在集合中进行查询，一旦遍历过程中查询到相同节点，即说明有交点，否则无</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        A = set()</span><br><span class="line">        cur1 = headA</span><br><span class="line">        cur2 = headB</span><br><span class="line">        <span class="keyword">while</span> cur1:</span><br><span class="line">            A.add(cur1)</span><br><span class="line">            cur1 = cur1.next</span><br><span class="line">        <span class="keyword">while</span> cur2:</span><br><span class="line">            <span class="keyword">if</span> cur2 <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">return</span> cur2</span><br><span class="line">            cur2 = cur2.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h6 id="5-移除链表元素"><a href="#5-移除链表元素" class="headerlink" title="5. 移除链表元素"></a>5. <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">移除链表元素</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">删除链表中等于给定值 val 的所有节点。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<p>方法：在本题中因为是链表是没有顺序的，所以只能一个一个的判断，判断是否为定值 val。需要注意的是需要处理边界值的问题，所以这里引入临时节点。<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode/" target="_blank" rel="noopener">图解地址</a></p>
<h6 id="6-反转链表"><a href="#6-反转链表" class="headerlink" title="6. 反转链表"></a>6. <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></h6><p>反转一个单链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>方法：双指针。<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/" target="_blank" rel="noopener">图解地址</a>, <a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/tu-jie-liu-cheng-python3die-dai-xiang-jie-by-han-h/" target="_blank" rel="noopener">图解地址2</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            temp = cur.next   <span class="comment"># 先把原来cur.next位置存起来</span></span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = temp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>
<h6 id="7-回文链表"><a href="#7-回文链表" class="headerlink" title="7. 回文链表"></a>7. <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">请判断一个链表是否为回文链表。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h5 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h5><h6 id="1-两两交换链表中的节点"><a href="#1-两两交换链表中的节点" class="headerlink" title="1. 两两交换链表中的节点"></a>1. <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p>方法1：可以使用栈，将两两元素入栈，出栈后即交换了顺序。<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> (head <span class="keyword">and</span> head.next):</span><br><span class="line">			<span class="keyword">return</span> head</span><br><span class="line">		p = ListNode(<span class="number">-1</span>)</span><br><span class="line">		<span class="comment"># 用stack保存每次迭代的两个节点</span></span><br><span class="line">		<span class="comment"># head指向新的p节点，函数结束时返回head.next即可</span></span><br><span class="line">		cur,head,stack = head,p,[]</span><br><span class="line">		<span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">			<span class="comment"># 将两个节点放入stack中</span></span><br><span class="line">			_,_ = stack.append(cur),stack.append(cur.next)</span><br><span class="line">			<span class="comment"># 当前节点往前走两步</span></span><br><span class="line">			cur = cur.next.next</span><br><span class="line">			<span class="comment"># 从stack中弹出两个节点，然后用p节点指向新弹出的两个节点</span></span><br><span class="line">			p.next = stack.pop()</span><br><span class="line">			p.next.next = stack.pop()</span><br><span class="line">			p = p.next.next</span><br><span class="line">		<span class="comment"># 注意边界条件，当链表长度是奇数时，cur就不为空	</span></span><br><span class="line">		<span class="keyword">if</span> cur:</span><br><span class="line">			p.next = cur</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			p.next = <span class="literal">None</span></span><br><span class="line">		<span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>
<p>方法2: 迭代实现。<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">		<span class="comment"># 增加一个特殊节点方便处理</span></span><br><span class="line">		p = ListNode(<span class="number">-1</span>)</span><br><span class="line">		<span class="comment"># 创建a，b两个指针，这里还需要一个tmp指针</span></span><br><span class="line">		a,b,p.next,tmp = p,p,head,p</span><br><span class="line">		<span class="keyword">while</span> b.next <span class="keyword">and</span> b.next.next:</span><br><span class="line">		<span class="comment"># a前进一位，b前进两位</span></span><br><span class="line">			a,b = a.next,b.next.next</span><br><span class="line">			<span class="comment"># 这步很关键，tmp指针用来处理边界条件的</span></span><br><span class="line">			<span class="comment"># 假设链表是1-&gt;2-&gt;3-&gt;4，a指向1，b指向2</span></span><br><span class="line">			<span class="comment"># 改变a和b的指向，于是就变成2-&gt;1，但是1指向谁呢？</span></span><br><span class="line">			<span class="comment"># 1是不能指向2的next，1应该指向4，而循环迭代的时候一次处理2个节点</span></span><br><span class="line">			<span class="comment"># 1和2的关系弄清楚了，3和4的关系也能弄清楚，但需要一个指针来处理</span></span><br><span class="line">			<span class="comment"># 2-&gt;1，4-&gt;3的关系，tmp指针就是干这个用的</span></span><br><span class="line">			tmp.next,a.next,b.next = b,b.next,a</span><br><span class="line">			<span class="comment"># 现在链表就变成2-&gt;1-&gt;3-&gt;4</span></span><br><span class="line">			<span class="comment"># tmp和b都指向1节点，等下次迭代的时候</span></span><br><span class="line">			<span class="comment"># a就变成3，b就变成4，然后tmp就指向b，也就是1指向4</span></span><br><span class="line">			tmp,b = a,a</span><br><span class="line">		<span class="keyword">return</span> p.next</span><br></pre></td></tr></table></figure>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="1-二叉树的中序遍历"><a href="#1-二叉树的中序遍历" class="headerlink" title="1. 二叉树的中序遍历"></a>1. <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，返回它的中序 遍历。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br><span class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>
<p>方法1: 递归 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 递归写法</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        back_func(root.left)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        back_func(root.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>方法2: 栈  <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 栈写法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">          <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, res = [root], []</span><br><span class="line">        <span class="keyword">while</span> stack:  <span class="comment"># 栈不为空就循环</span></span><br><span class="line">            <span class="comment"># 左子树中所有最左边的孩子进栈</span></span><br><span class="line">            <span class="keyword">while</span> root.left:</span><br><span class="line">                stack.append(root.left)</span><br><span class="line">                root = root.left</span><br><span class="line">            cur = stack.pop()   <span class="comment"># 弹出一个左孩子记为当前节点，看它有没有右孩子</span></span><br><span class="line">            res.append(cur.val) <span class="comment"># 每弹出一次记得记录一下</span></span><br><span class="line">            <span class="keyword">if</span> cur.right:  <span class="comment"># 如果当前节点有右孩子的话，右孩子进栈，把这个右孩子当作新的根节点</span></span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">                root = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5 id="2-二叉树的前序遍历"><a href="#2-二叉树的前序遍历" class="headerlink" title="2. 二叉树的前序遍历"></a>2. <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，返回它的 前序 遍历。</span><br><span class="line"></span><br><span class="line"> 示例:</span><br><span class="line"></span><br><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br><span class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>
<p>方法1: 递归 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 递归写法</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        res.append(root.val)</span><br><span class="line">        back_func(root.left)</span><br><span class="line">        back_func(root.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>方法2: 迭代  <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, res = [root], []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()  <span class="comment"># 弹出根元素</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                res.append(root.val)  <span class="comment"># 记录根元素的值</span></span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    stack.append(root.right)  <span class="comment"># 右节点入栈  </span></span><br><span class="line">                <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    stack.append(root.left)   <span class="comment"># 左节点入栈</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5 id="3-二叉树的后序遍历"><a href="#3-二叉树的后序遍历" class="headerlink" title="3. 二叉树的后序遍历"></a>3. <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，返回它的 后序 遍历。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br><span class="line">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>
<p>方法1: 递归 <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/" target="_blank" rel="noopener">图解地址</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 递归写法</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       </span><br><span class="line">        back_func(root.left)</span><br><span class="line">        back_func(root.right)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>方法2: 栈 <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/" target="_blank" rel="noopener">图解地址</a></p>
<p>先看后序遍历的顺序, 左右中。</p>
<p>前序是，中左右</p>
<p>所以后续反转是，中右左。和前序相比，只是左右位置改变了</p>
<p>所以思路是在前序遍历中，把left 和 right的顺序调换，然后输出反转的树即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, res = [root], []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()  <span class="comment"># 弹出根元素</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                res.append(root.val)  <span class="comment"># 记录根元素的值</span></span><br><span class="line">                <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    stack.append(root.left)    <span class="comment"># 和前序相比，调换左右的顺序</span></span><br><span class="line">                <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    stack.append(root.right)   <span class="comment"># 和前序相比，调换左右的顺序</span></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]  <span class="comment"># 左右结果反转即可</span></span><br></pre></td></tr></table></figure>
<h5 id="4-N叉树的前序遍历"><a href="#4-N叉树的前序遍历" class="headerlink" title="4.  N叉树的前序遍历"></a>4. <a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener"> N叉树的前序遍历</a></h5><p>给定一个 N 叉树，返回其节点值的<em>前序遍历</em>。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<p>返回其前序遍历: <code>[1,3,5,6,2,4]</code>。<strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p>
<p>方法1： 递归，先处理根节点，再对当前节点的所有子节点递归进行前序遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = [root.val]</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">            res += self.preorder(node)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>方法2: 栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []            </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            		output.append(root.val)</span><br><span class="line">            stack.extend(root.children[::<span class="number">-1</span>])  <span class="comment"># 倒序添加孩子节点，保证左侧孩子始终处于栈顶</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<h5 id="5-N叉树的后序遍历"><a href="#5-N叉树的后序遍历" class="headerlink" title="5. N叉树的后序遍历"></a>5. <a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">N叉树的后序遍历</a></h5><p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<p>返回其后序遍历: <code>[5,6,3,2,4,1]</code>.说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<p>方法1: 递归，先对当前节点的所有子节点递归进行后序遍历，后处理根节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">            res.extend(self.postorder(node))</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>方法2: 迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                output.append(root.val)</span><br><span class="line">            stack.extend(root.children)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> output[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h5 id="6-括号生成"><a href="#6-括号生成" class="headerlink" title="6. 括号生成"></a>6. <a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：n = 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>
<p>方法1: 递归。n 等于3，说明括号有3对，也就是6个，且满足的有效的括号的话，那么左括号 = 右括号 = 3，如果当前左括号的个数已经小于右括号的个数了【例如 (())) 】，那么说明已经不能在组合成有效的括号了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        cur_str = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur_str, left, right, n)</span>:</span></span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            :param cur_str: 从根结点到叶子结点的路径字符串</span></span><br><span class="line"><span class="string">            :param left: 左括号已经使用的个数</span></span><br><span class="line"><span class="string">            :param right: 右括号已经使用的个数</span></span><br><span class="line"><span class="string">            :return:</span></span><br><span class="line"><span class="string">            """</span></span><br><span class="line">            <span class="keyword">if</span> left == n <span class="keyword">and</span> right == n:  <span class="comment"># 如果（ 和 ） 的个数都等于 n 了，那么说明递归结束</span></span><br><span class="line">                res.append(cur_str)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right: <span class="comment"># 如果（ 括号的个数小于 ）的个数，那么说明已经不能组合成有效的括号对了</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:   <span class="comment"># 添加左括号</span></span><br><span class="line">                dfs(cur_str + <span class="string">'('</span>, left + <span class="number">1</span>, right, n)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> right &lt; n:  <span class="comment"># 添加右括号</span></span><br><span class="line">                dfs(cur_str + <span class="string">')'</span>, left, right + <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">        dfs(cur_str, <span class="number">0</span>, <span class="number">0</span>, n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5 id="7-翻转二叉树"><a href="#7-翻转二叉树" class="headerlink" title="7. 翻转二叉树"></a>7. <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">翻转一棵二叉树。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<p>方法1： 递归。交换当前节点的左右子树，然后在递归交换当前节点的 左子树和右子树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">		<span class="string">"""</span></span><br><span class="line"><span class="string">		:type root: TreeNode</span></span><br><span class="line"><span class="string">		:rtype: TreeNode</span></span><br><span class="line"><span class="string">		"""</span></span><br><span class="line">		<span class="comment"># 递归函数的终止条件，节点为空时返回</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">		<span class="comment"># 将当前节点的左右子树交换</span></span><br><span class="line">		root.left,root.right = root.right,root.left</span><br><span class="line">		<span class="comment"># 递归交换当前节点的 左子树和右子树</span></span><br><span class="line">		self.invertTree(root.left)</span><br><span class="line">		self.invertTree(root.right)</span><br><span class="line">		<span class="comment"># 函数返回时就表示当前这个节点，以及它的左右子树</span></span><br><span class="line">		<span class="comment"># 都已经交换完了		</span></span><br><span class="line">		<span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h5 id="8-验证二叉搜索树"><a href="#8-验证二叉搜索树" class="headerlink" title="8. 验证二叉搜索树"></a>8. <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：</span><br><span class="line"></span><br><span class="line">节点的左子树只包含小于当前节点的数。</span><br><span class="line">节点的右子树只包含大于当前节点的数。</span><br><span class="line">所有左子树和右子树自身必须也是二叉搜索树。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>
<p>方法1: 中序遍历。根据二叉搜索树的性质，中序遍历的结果是一个递增的值，只需要在遍历过程中判断当前值是否大于前一个值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack, inorder = [], float(<span class="string">'-inf'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            <span class="comment"># 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> root.val &lt;= inorder:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            inorder = root.val</span><br><span class="line">            root = root.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">平衡二叉树</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br></pre></td></tr></table></figure>
<p>方法：递归，判断每个节点的左右子树的深度不超过1即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.depth(root.left) - self.depth(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> \</span><br><span class="line">            self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left), self.depth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="9-二叉树的最大深度"><a href="#9-二叉树的最大深度" class="headerlink" title="9. 二叉树的最大深度"></a>9. <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>
<p>方法1: 递归。分别求左右子树的高度，然后在取最大值 + 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            left_height = self.maxDepth(root.left) </span><br><span class="line">            right_height = self.maxDepth(root.right) </span><br><span class="line">            <span class="keyword">return</span> max(left_height, right_height) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="10-二叉树的最小深度"><a href="#10-二叉树的最小深度" class="headerlink" title="10. 二叉树的最小深度"></a>10. <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最小深度</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line">示例:给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最小深度</span><br></pre></td></tr></table></figure>
<p>方法1: 递归。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        l, r = self.minDepth(root.left), self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right:  <span class="comment"># 当左右节点都存在时，最小高度 = min(l + r) + 1 </span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span> + min(l, r)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 只存在一个节点，另一个节点不存在时</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span> + l + r</span><br></pre></td></tr></table></figure>
<h5 id="11-树的广度优先遍历"><a href="#11-树的广度优先遍历" class="headerlink" title="11. 树的广度优先遍历"></a>11. 树的广度优先遍历</h5><p>利用队列我们只要在节点出队的时候让该节点的子节点入队即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__list = list()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.__list.append(data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadthFirst</span><span class="params">(tree)</span>:</span></span><br><span class="line">    queue = Queue()</span><br><span class="line">    queue.push(tree)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.isEmpty():</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        result.append(node.data)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> node.getChildren():</span><br><span class="line">            queue.push(c)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h5 id="12-树的深度优先遍历"><a href="#12-树的深度优先遍历" class="headerlink" title="12. 树的深度优先遍历"></a>12. 树的深度优先遍历</h5><p>实现深度优先遍历，我们只要在节点出栈的时候把该节点的子节点从左到右压入堆栈即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__list = list()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.__list.append(data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depthFirst</span><span class="params">(tree)</span>:</span></span><br><span class="line">    stack = Stack()</span><br><span class="line">    stack.push(tree)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stack.isEmpty():</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        result.append(node.data)</span><br><span class="line">        children = node.getChildren()</span><br><span class="line">        children = reversed(children)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> children:</span><br><span class="line">            stack.push(c)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h5 id="1-Pow-x-n"><a href="#1-Pow-x-n" class="headerlink" title="1. Pow(x, n)"></a>1. <a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">Pow(x, n)</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">实现 pow(x, n) ，即计算 x 的 n 次幂函数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2^-2 = 1/2^2 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<p>方法1: 递归。例 2^10 可以看成 2^5 <em> 2^5。如果是 2^9, 那么可以看成 2^4 </em> 2^4 * 2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickMul</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">            y = quickMul(N // <span class="number">2</span>)  <span class="comment"># 2^10 转换为求 2^5</span></span><br><span class="line">            <span class="keyword">return</span> y * y <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> y * y * x  <span class="comment"># 判断是奇数还是偶数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> quickMul(n) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1.0</span> / quickMul(-n)</span><br></pre></td></tr></table></figure>
<h5 id="2-子集"><a href="#2-子集" class="headerlink" title="2. 子集"></a>2. <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>方法：回溯。难</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(<span class="number">0</span>, nums, res, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; tmp)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            tmp.add(nums[j]);</span><br><span class="line">            backtrack(j + <span class="number">1</span>, nums, res, tmp);</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-多数元素"><a href="#3-多数元素" class="headerlink" title="3.  多数元素"></a>3. <a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener"> 多数元素</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br><span class="line"> </span><br><span class="line">示例 1:</span><br><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>方法1: 哈希表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        counts = collections.Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> max(counts.keys(), key=counts.get)</span><br></pre></td></tr></table></figure>
<p>方法2: 排序。取排序后中间位置的元素，因为题目说一定存在，所以不管是奇数个还是偶数个，中间的一定是出现最多的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums) // <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h5 id="1-柠檬水找零"><a href="#1-柠檬水找零" class="headerlink" title="1. 柠檬水找零"></a>1. <a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">柠檬水找零</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。如果你能给每位顾客正确找零，返回 true ，否则返回 false </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[5,5,10]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：[10,10]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：[5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure>
<p>方法： 贪心。给 20 找零的时候，优先使用 10 + 5 的选择，如果没有在使用 3 张5元。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span><span class="params">(self, bills: List[int])</span> -&gt; bool:</span></span><br><span class="line">        Hash = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> bill <span class="keyword">in</span> bills:   <span class="comment"># 每位顾客给的钱</span></span><br><span class="line">            <span class="keyword">if</span> bill == <span class="number">5</span>:    <span class="comment"># 不用找零，直接 5 元计数 + 1</span></span><br><span class="line">                Hash[bill] = Hash.get(bill, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> bill == <span class="number">10</span>: <span class="comment"># 如果是 10 块，那么退还5元，且 10 元计数 + 1</span></span><br><span class="line">                <span class="keyword">if</span> Hash.get(<span class="number">5</span>, <span class="number">0</span>) &gt; <span class="number">0</span>:</span><br><span class="line">                    Hash[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                    Hash[<span class="number">10</span>] = Hash.get(<span class="number">10</span>, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> bill == <span class="number">20</span>: <span class="comment"># 如果是 20，那么优先使用 10 块和 5 块进行找零。没有在使用 3 张 5 块</span></span><br><span class="line">                <span class="keyword">if</span> Hash.get(<span class="number">10</span>, <span class="number">0</span>) &gt; <span class="number">0</span> <span class="keyword">and</span> Hash.get(<span class="number">5</span>, <span class="number">0</span>) &gt; <span class="number">0</span>:</span><br><span class="line">                    Hash[<span class="number">10</span>] -= <span class="number">1</span></span><br><span class="line">                    Hash[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> Hash.get(<span class="number">5</span>, <span class="number">0</span>) &gt; <span class="number">2</span>:</span><br><span class="line">                    Hash[<span class="number">5</span>] -= <span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h5 id="2-买卖股票的最佳时机-II"><a href="#2-买卖股票的最佳时机-II" class="headerlink" title="2. 买卖股票的最佳时机 II"></a>2. <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p>方法： 贪心。只要判断价格是涨的，那么就买入，如果是跌的，那么就不买卖。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        profit = <span class="number">0</span>  <span class="comment"># 盈利的钱</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            tmp = prices[i] - prices[i - <span class="number">1</span>]  <span class="comment"># 如果后一天的价格高于前一天，即是涨的</span></span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span>: </span><br><span class="line">              profit += tmp <span class="comment"># 那么就买卖，收入为两天的差价</span></span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
<h5 id="3-分发饼干"><a href="#3-分发饼干" class="headerlink" title="3.  分发饼干"></a>3. <a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener"> 分发饼干</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</span><br><span class="line"> </span><br><span class="line">示例 1:</span><br><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</span><br></pre></td></tr></table></figure>
<p>方法： 排序，然后利用贪心算法。对饼干进行遍历，如果饼干能满足小孩胃口，满足小孩的数量+1，直到饼干遍历完或者小孩都满足</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(self, g: List[int], s: List[int])</span> -&gt; int:</span></span><br><span class="line">        g.sort()  <span class="comment"># 小孩胃口排序</span></span><br><span class="line">        s.sort()  <span class="comment"># 饼干尺寸排序</span></span><br><span class="line">        n = <span class="number">0</span>     <span class="comment"># 满足的小孩的数量</span></span><br><span class="line">        N = len(g)</span><br><span class="line">        <span class="keyword">for</span> biscuit <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> n==N: <span class="comment"># 所有的小孩都已经满足了</span></span><br><span class="line">                <span class="keyword">return</span> n</span><br><span class="line">            <span class="keyword">if</span> biscuit&gt;= g[n]: <span class="comment"># 当前饼干的尺寸够当前小孩的胃口</span></span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">st</span><span class="params">(data)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(length - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(length - <span class="number">1</span> - x):</span><br><span class="line">            <span class="keyword">if</span> data[y] &gt; data[y+<span class="number">1</span>]:</span><br><span class="line">                data[y], data[y + <span class="number">1</span>] = data[y + <span class="number">1</span>], data[y]</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">st</span><span class="params">(data)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, length):</span><br><span class="line">        tmp_min = x  <span class="comment"># 假设这个元素下标的元素就是最小的</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(x + <span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> data[y] &lt; data[tmp_min]:  <span class="comment"># 如果有比 tmp_min 更小的，那么就更新 tmp_min</span></span><br><span class="line">                tmp_min = y</span><br><span class="line"></span><br><span class="line">        data[x], data[tmp_min] = data[tmp_min], data[x]  <span class="comment"># 最后交换元素</span></span><br><span class="line"></span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">st</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        key = arr[i]  <span class="comment"># 当前元素</span></span><br><span class="line">        j = i - <span class="number">1</span>  <span class="comment"># j 和 j 之前的元素都是有序的</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> key &lt; arr[j]:  <span class="comment"># 如果当前元素小于有序列表中的某个元素。</span></span><br><span class="line">                                        <span class="comment"># 说明找到了插入的位置，需要将其余元素后移</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key  <span class="comment"># 插入元素</span></span><br><span class="line"></span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
<h5 id="快速排序（重点）"><a href="#快速排序（重点）" class="headerlink" title="快速排序（重点）"></a>快速排序（重点）</h5><p><a href="https://blog.csdn.net/pengzonglu7292/article/details/84938910" target="_blank" rel="noopener">https://blog.csdn.net/pengzonglu7292/article/details/84938910</a></p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(begin, end, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> begin &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pivot_index = partition(begin, end, nums)</span><br><span class="line">    quick_sort(begin, pivot_index - <span class="number">1</span>, nums)  <span class="comment"># 重复基准左边</span></span><br><span class="line">    quick_sort(pivot_index + <span class="number">1</span>, end, nums)  <span class="comment"># 重复基准右边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(begin, end, nums)</span>:</span></span><br><span class="line">    pivot = nums[begin]  <span class="comment"># 选择第一个元素为基准</span></span><br><span class="line">    mark = begin</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; pivot:  <span class="comment"># 遍历所有元素</span></span><br><span class="line">            mark += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 把小于基准的元素选出来放到 mark 的位置 [10, 4, 9, 6, 1, 4, 8, 23, 10, 99, 890, 22]</span></span><br><span class="line">            nums[mark], nums[i] = nums[i], nums[mark]</span><br><span class="line">            <span class="comment"># 把基准放到中间去 [8, 4, 9, 6, 1, 4, 10, 23, 10, 99, 890, 22]</span></span><br><span class="line">    nums[begin], nums[mark] = nums[mark], nums[begin]</span><br><span class="line">    <span class="keyword">return</span> mark</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [<span class="number">10</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">99</span>, <span class="number">890</span>, <span class="number">8</span>]</span><br><span class="line">quick_sort(<span class="number">0</span>, <span class="number">11</span>, a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h5 id="归并排序（重点）"><a href="#归并排序（重点）" class="headerlink" title="归并排序（重点）"></a>归并排序（重点）</h5><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = []  <span class="comment"># 存放结果的数组</span></span><br><span class="line">    h = j = <span class="number">0</span>  <span class="comment"># 左右两边的指针都是从 0 开始</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; len(a) <span class="keyword">and</span> h &lt; len(b):  <span class="comment"># 任何一个指针都没有走完</span></span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; b[h]:   <span class="comment"># 比较左右两边数组的元素，谁小就将谁放入 c 中，并且指针后移</span></span><br><span class="line">            c.append(a[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(b[h])</span><br><span class="line">            h += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有一边走完了，或者两边都走完了</span></span><br><span class="line">    <span class="keyword">if</span> j == len(a):   <span class="comment"># 如果右边走完了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> b[h:]:  <span class="comment"># 那么就将左边剩余的元素放到 c 中</span></span><br><span class="line">            c.append(i)</span><br><span class="line">    <span class="keyword">else</span>:             <span class="comment"># 左边走完了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[j:]:  <span class="comment"># 那么就将右边剩余的元素放入到 c 中</span></span><br><span class="line">            c.append(i)</span><br><span class="line">    <span class="keyword">return</span> c  <span class="comment"># 最后返回有序的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(lists)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(lists) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lists</span><br><span class="line">    middle = len(lists) // <span class="number">2</span>  <span class="comment"># 获取中间位置</span></span><br><span class="line">    left = merge_sort(lists[:middle])  <span class="comment"># 递归左边</span></span><br><span class="line">    right = merge_sort(lists[middle:])  <span class="comment"># 递归右边</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)  <span class="comment"># 最后合并左右两边</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">14</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">43</span>, <span class="number">21</span>, <span class="number">19</span>]</span><br><span class="line">    print(merge_sort(a))</span><br></pre></td></tr></table></figure>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://github.com/HuberTRoy/leetCode" target="_blank" rel="noopener">https://github.com/HuberTRoy/leetCode</a> </p>
<p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a> </p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/技术/" rel="tag"><i class="fa fa-tag"></i> 技术</a>
              <a href="/tags/算法/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/07/29/Vue-cli搭建项目/" rel="prev" title="Vue-cli搭建项目">
      <i class="fa fa-chevron-left"></i> Vue-cli搭建项目
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/08/20/Google Voice/" rel="next" title="Google Voice + Wechat Out + 防回收">
      Google Voice + Wechat Out + 防回收 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组及其相关"><span class="nav-number">1.</span> <span class="nav-text">数组及其相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#20200825"><span class="nav-number">1.1.</span> <span class="nav-text">20200825</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-公平的糖果交换"><span class="nav-number">1.1.1.</span> <span class="nav-text">2. 公平的糖果交换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-在排序数组中查找元素的第一个和最后一个位置"><span class="nav-number">1.1.2.</span> <span class="nav-text">3. 在排序数组中查找元素的第一个和最后一个位置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20200831"><span class="nav-number">1.2.</span> <span class="nav-text">20200831</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-旋转数组的最小数字"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 旋转数组的最小数字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈和队列"><span class="nav-number">1.3.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-最小栈"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 最小栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-用两个栈实现队列"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 用两个栈实现队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-用两个队列实现栈"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 用两个队列实现栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-有效的括号"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 有效的括号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-删除字符串中的所有相邻重复项"><span class="nav-number">1.3.5.</span> <span class="nav-text">5. 删除字符串中的所有相邻重复项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-柱状图中最大的矩形"><span class="nav-number">1.3.6.</span> <span class="nav-text">6. 柱状图中最大的矩形</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-滑动窗口最大值"><span class="nav-number">1.3.7.</span> <span class="nav-text">7. 滑动窗口最大值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-设计循环队列"><span class="nav-number">1.3.8.</span> <span class="nav-text">8. 设计循环队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-设计循环双端队列"><span class="nav-number">1.3.9.</span> <span class="nav-text">9. 设计循环双端队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-接雨水"><span class="nav-number">1.3.10.</span> <span class="nav-text">10. 接雨水</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组，哈希表"><span class="nav-number">1.4.</span> <span class="nav-text">数组，哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-搜索插入位置"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 搜索插入位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-移除元素"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 移除元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-删除排序数组中的重复项"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最长不含重复字符的子字符串"><span class="nav-number">1.4.4.</span> <span class="nav-text">最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-长度最小的子数组"><span class="nav-number">1.4.5.</span> <span class="nav-text">4. 长度最小的子数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-螺旋矩阵-II"><span class="nav-number">1.4.6.</span> <span class="nav-text">5. 螺旋矩阵 II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-两数之和"><span class="nav-number">1.4.7.</span> <span class="nav-text">6. 两数之和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-三数之和"><span class="nav-number">1.4.8.</span> <span class="nav-text">7. 三数之和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-盛最多水的容器"><span class="nav-number">1.4.9.</span> <span class="nav-text">8. 盛最多水的容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-移动零"><span class="nav-number">1.4.10.</span> <span class="nav-text">9. 移动零</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-爬楼梯"><span class="nav-number">1.4.11.</span> <span class="nav-text">10. 爬楼梯</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-合并两个有序数组"><span class="nav-number">1.4.12.</span> <span class="nav-text">11. 合并两个有序数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-加一"><span class="nav-number">1.4.13.</span> <span class="nav-text">12. 加一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-有效的字母异位词"><span class="nav-number">1.4.14.</span> <span class="nav-text">13. 有效的字母异位词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-字母异位词分组"><span class="nav-number">1.4.15.</span> <span class="nav-text">14. 字母异位词分组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表"><span class="nav-number">1.5.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单"><span class="nav-number">1.5.1.</span> <span class="nav-text">简单</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-合并两个有序链表"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">1. 合并两个有序链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-删除排序链表中的重复元素"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">2. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-环形链表"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">3. 环形链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-相交链表"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">4. 相交链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-移除链表元素"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">5. 移除链表元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-反转链表"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">6. 反转链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-回文链表"><span class="nav-number">1.5.1.7.</span> <span class="nav-text">7. 回文链表</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中等"><span class="nav-number">1.5.2.</span> <span class="nav-text">中等</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-两两交换链表中的节点"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">1. 两两交换链表中的节点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树"><span class="nav-number">1.6.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-二叉树的中序遍历"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-二叉树的前序遍历"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. 二叉树的前序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-二叉树的后序遍历"><span class="nav-number">1.6.3.</span> <span class="nav-text">3. 二叉树的后序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-N叉树的前序遍历"><span class="nav-number">1.6.4.</span> <span class="nav-text">4.  N叉树的前序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-N叉树的后序遍历"><span class="nav-number">1.6.5.</span> <span class="nav-text">5. N叉树的后序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-括号生成"><span class="nav-number">1.6.6.</span> <span class="nav-text">6. 括号生成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-翻转二叉树"><span class="nav-number">1.6.7.</span> <span class="nav-text">7. 翻转二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-验证二叉搜索树"><span class="nav-number">1.6.8.</span> <span class="nav-text">8. 验证二叉搜索树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#平衡二叉树"><span class="nav-number">1.6.9.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-二叉树的最大深度"><span class="nav-number">1.6.10.</span> <span class="nav-text">9. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-二叉树的最小深度"><span class="nav-number">1.6.11.</span> <span class="nav-text">10. 二叉树的最小深度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-树的广度优先遍历"><span class="nav-number">1.6.12.</span> <span class="nav-text">11. 树的广度优先遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-树的深度优先遍历"><span class="nav-number">1.6.13.</span> <span class="nav-text">12. 树的深度优先遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">2.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Pow-x-n"><span class="nav-number">2.0.1.</span> <span class="nav-text">1. Pow(x, n)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-子集"><span class="nav-number">2.0.2.</span> <span class="nav-text">2. 子集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-多数元素"><span class="nav-number">2.0.3.</span> <span class="nav-text">3.  多数元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#贪心"><span class="nav-number">3.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-柠檬水找零"><span class="nav-number">3.0.1.</span> <span class="nav-text">1. 柠檬水找零</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-买卖股票的最佳时机-II"><span class="nav-number">3.0.2.</span> <span class="nav-text">2. 买卖股票的最佳时机 II</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-分发饼干"><span class="nav-number">3.0.3.</span> <span class="nav-text">3.  分发饼干</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">4.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#冒泡排序"><span class="nav-number">4.0.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择排序"><span class="nav-number">4.0.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入排序"><span class="nav-number">4.0.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速排序（重点）"><span class="nav-number">4.0.4.</span> <span class="nav-text">快速排序（重点）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#归并排序（重点）"><span class="nav-number">4.0.5.</span> <span class="nav-text">归并排序（重点）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#堆排序"><span class="nav-number">4.0.6.</span> <span class="nav-text">堆排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">5.</span> <span class="nav-text">其他</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rex"
      src="https://raw.githubusercontent.com/rexyan/warehouse/master/20230809141242.jpg">
  <p class="site-author-name" itemprop="name">Rex</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">446</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">183</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa-hand-o-right"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rex</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
